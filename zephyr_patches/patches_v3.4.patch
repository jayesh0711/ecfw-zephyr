From 1709d9ec8d007627140cbcf5a70876175baa7bfd Mon Sep 17 00:00:00 2001
From: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
Date: Mon, 30 Mar 2020 10:32:05 -0400
Subject: [PATCH 01/12] drivers: espi: Clear virtual wire interrupt before
 calling handler

Clearing virtual wire interrupt after calling handler may cause next
interrupt miss if the same virtual wire changes due to action in handler.
As the interrupt source is read from register, it can be cleared before
calling handler to avoid next interrupt miss due to action/delay in the
callback handler.

Signed-off-by: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 2474c666ce..6b88d96fe5 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -1360,6 +1360,7 @@ static void espi_xec_vw_isr(const struct device *dev)
 	uint32_t girq_result;
 
 	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_ids[0]);
+	MCHP_GIRQ_SRC(config->vw_girq_ids[0]) = girq_result;
 
 	for (int i = 0; i < m2s_vwires_isr_cnt; i++) {
 		struct espi_isr entry = m2s_vwires_isr[i];
@@ -1370,8 +1371,6 @@ static void espi_xec_vw_isr(const struct device *dev)
 			}
 		}
 	}
-
-	REG32(MCHP_GIRQ_SRC_ADDR(config->vw_girq_ids[0])) = girq_result;
 }
 
 #if DT_INST_PROP_HAS_IDX(0, vw_girqs, 1)
-- 
2.25.1


From 6dfa7a237b42dcef1ad89d589c122cf18ffef414 Mon Sep 17 00:00:00 2001
From: Kunal Shah <kunal.a.shah@intel.com>
Date: Wed, 3 Mar 2021 17:06:31 +0530
Subject: [PATCH 02/12] espi:driver: espi ltr support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

LTR stands for “Latency Tolerance Report”.
This feature allows the EC slave to declare an upper bound on
latency through the chipset. The effect of setting a Latency Tolerance
is to restrict the low-power states that the chipset may enter.

LTR needs to be programmed only after Bus Mastering is enabled by eSPI master
using peripheral configuration message.

This patch will send LTR message to the eSPI Master and also provides callback
on reception of bus master enabling from espi master.

Signed-off-by: Kunal Shah <kunal.a.shah@intel.com>
---
 drivers/espi/espi_mchp_xec.c  | 38 ++++++++++++++++++++--
 include/zephyr/drivers/espi.h | 60 +++++++++++++++++++++++++++++++++++
 2 files changed, 96 insertions(+), 2 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 6b88d96fe5..55a8564baa 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -432,7 +432,26 @@ static int espi_xec_write_lpc_request(const struct device *dev,
 
 	return 0;
 }
+static int espi_xec_send_ltr(const struct device *dev, struct ltr_cfg_pkt *req)
+{
+	if (!(ESPI_PC_REGS->PC_STATUS & MCHP_ESPI_PC_STS_BM_EN)) {
+		return -ENOTSUP;
+	}
+
+	if (req->ltr_req) {
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_VAL |
+				(req->latency << MCHP_ESPI_LTR_MSG_VAL_POS) |
+				(req->ltr_scale << MCHP_ESPI_LTR_MSG_SC_POS);
+	} else {
+		/* set infinite latency tolrated */
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_INF;
+	}
 
+	/* Send LTR Packet */
+	ESPI_LTR_REGS->LTR_CTRL = MCHP_ESPI_LTR_CTRL_START;
+
+	return 0;
+}
 static int espi_xec_send_vwire(const struct device *dev,
 			       enum espi_vwire_signal signal, uint8_t level)
 {
@@ -962,6 +981,10 @@ static void setup_espi_io_config(const struct device *dev,
 static void espi_pc_isr(const struct device *dev)
 {
 	uint32_t status = ESPI_PC_REGS->PC_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_CHANNEL_READY,
+				  .evt_details = ESPI_CHANNEL_PERIPHERAL,
+				  .evt_data = 0 };
+	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
 
 	if (status & MCHP_ESPI_PC_STS_EN_CHG) {
 		if (status & MCHP_ESPI_PC_STS_EN) {
@@ -969,6 +992,13 @@ static void espi_pc_isr(const struct device *dev)
 		}
 
 		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
+	} else if (status & MCHP_ESPI_PC_STS_BM_EN_CHG) {
+		if (status & MCHP_ESPI_PC_STS_BM_EN) {
+			evt.evt_data = ESPI_PC_EVT_BUS_MASTER_ENABLE;
+			espi_send_callbacks(&data->callbacks, dev, evt);
+		}
+
+		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_BM_EN_CHG;
 	}
 }
 
@@ -1442,6 +1472,7 @@ static const struct espi_driver_api espi_xec_driver_api = {
 	.manage_callback = espi_xec_manage_callback,
 	.read_lpc_request = espi_xec_read_lpc_request,
 	.write_lpc_request = espi_xec_write_lpc_request,
+	.send_ltr = espi_xec_send_ltr,
 };
 
 static struct espi_xec_data espi_xec_data;
@@ -1513,8 +1544,11 @@ static int espi_xec_init(const struct device *dev)
 	/* Clear reset interrupt status and enable interrupts */
 	ESPI_CAP_REGS->ERST_STS = MCHP_ESPI_RST_ISTS;
 	ESPI_CAP_REGS->ERST_IEN |= MCHP_ESPI_RST_IEN;
-	ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
-	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG;
+	ESPI_PC_REGS->PC_STATUS |= MCHP_ESPI_PC_STS_EN_CHG |
+				 MCHP_ESPI_PC_STS_BM_EN_CHG;
+	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG |
+				MCHP_ESPI_PC_IEN_BM_EN_CHG;
+
 
 	/* Enable VWires interrupts */
 	for (int i = 0; i < sizeof(vw_wires_int_en); i++) {
diff --git a/include/zephyr/drivers/espi.h b/include/zephyr/drivers/espi.h
index d2f77622fc..fce72ed16b 100644
--- a/include/zephyr/drivers/espi.h
+++ b/include/zephyr/drivers/espi.h
@@ -120,6 +120,20 @@ enum espi_bus_event {
 	ESPI_BUS_SAF_NOTIFICATION           = BIT(5),
 };
 
+/**
+ * @brief eSPI LTR Scale
+ *
+ * eSPI LTR scale value used for LTR register programming
+ */
+enum espi_ltr_scale {
+	ESPI_LTR_SCALE_1NSEC = 0,
+	ESPI_LTR_SCALE_32NSEC = BIT(0),
+	ESPI_LTR_SCALE_1024NSEC = BIT(1),
+	ESPI_LTR_SCALE_32USEC = BIT(0) | BIT(1),
+	ESPI_LTR_SCALE_1MSEC = BIT(2),
+	ESPI_LTR_SCALE_33MSEC = BIT(0) | BIT(2),
+};
+
 /**
  * @brief eSPI peripheral channel events.
  *
@@ -369,6 +383,18 @@ struct espi_flash_packet {
 	uint16_t len;
 };
 
+/**
+ * @brief eSPI LTR configuration parameters
+ */
+struct ltr_cfg_pkt {
+	/** Latency scale */
+	enum espi_ltr_scale ltr_scale;
+	/** Latency value in unit of scale */
+	uint16_t latency;
+	/** LTR Required bit 1-ltr as per scale, 0 -Infinite latency */
+	uint8_t ltr_req;
+};
+
 struct espi_callback;
 
 /**
@@ -431,6 +457,8 @@ typedef int (*espi_api_lpc_read_request)(const struct device *dev,
 typedef int (*espi_api_lpc_write_request)(const struct device *dev,
 					  enum lpc_peripheral_opcode op,
 					  uint32_t *data);
+typedef int (*espi_api_ltr_write_request)(const struct device *dev,
+					  struct ltr_cfg_pkt *req);
 /* Logical Channel 1 APIs */
 typedef int (*espi_api_send_vwire)(const struct device *dev,
 				   enum espi_vwire_signal vw,
@@ -462,6 +490,7 @@ __subsystem struct espi_driver_api {
 	espi_api_write_request write_request;
 	espi_api_lpc_read_request read_lpc_request;
 	espi_api_lpc_write_request write_lpc_request;
+	espi_api_ltr_write_request send_ltr;
 	espi_api_send_vwire send_vwire;
 	espi_api_receive_vwire receive_vwire;
 	espi_api_send_oob send_oob;
@@ -686,6 +715,37 @@ static inline int z_impl_espi_write_lpc_request(const struct device *dev,
 	return api->write_lpc_request(dev, op, data);
 }
 
+
+/**
+ * @brief Send LTR request to eSPI host which generates an eSPI transaction.
+ *
+ * This routine provides a generic interface to send ltr value to eSPI host
+ * which triggers an eSPI transaction. The eSPI packet is assembled by the
+ * hardware block.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param req Address of a structure representing LTR configuration request.
+ *
+ * @retval 0 If successful.
+ * @retval -ENOTSUP espi master has not enabled LTR.
+ */
+__syscall int espi_send_ltr(const struct device *dev,
+			    struct ltr_cfg_pkt *req);
+
+static inline int z_impl_espi_send_ltr(const struct device *dev,
+				       struct ltr_cfg_pkt *req)
+{
+	const struct espi_driver_api *api =
+		(const struct espi_driver_api *)dev->api;
+
+	if (!api->send_ltr) {
+		return -ENOTSUP;
+	}
+
+	return api->send_ltr(dev, req);
+}
+
+
 /**
  * @brief Sends system/platform signal as a virtual wire packet.
  *
-- 
2.25.1


From eb4e3838f4837eecc9991093cf5e989b0aad5d2f Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 5 Jun 2023 16:44:18 -0700
Subject: [PATCH 03/12] boards: arm: mec172xmodular: Perform device tree
 corrections

MEC172x modular card has no onboard I2C IO expander.
Remove obsolote dts SPI properties and choose LDMA driver.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 .../mec172xmodular_assy6930.dts               | 24 +++++--------------
 1 file changed, 6 insertions(+), 18 deletions(-)

diff --git a/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts b/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts
index 928991124e..f44c554c88 100644
--- a/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts
+++ b/boards/arm/mec172xmodular_assy6930/mec172xmodular_assy6930.dts
@@ -138,22 +138,6 @@
 
 	pinctrl-0 = < &i2c00_scl_gpio004 &i2c00_sda_gpio003 >;
 	pinctrl-names = "default";
-
-	pca9555@26 {
-		compatible = "nxp,pca95xx";
-
-		/* Depends on JP53 for device address.
-		 * Pin 1-2 = A0, pin 3-4 = A1, pin 5-6 = A2.
-		 * Address is: 0100<A2><A1><A0>b.
-		 *
-		 * Default has pin 1-2 on JP53 connected,
-		 * resulting in device address 0x26.
-		 */
-		reg = <0x26>;
-
-		gpio-controller;
-		#gpio-cells = <2>;
-	};
 };
 
 &i2c00_scl_gpio004 {
@@ -208,10 +192,10 @@
 
 &spi0 {
 	status = "okay";
+	compatible = "microchip,xec-qmspi-ldma";
 	clock-frequency = <4000000>;
 	lines = <4>;
-	chip_select = <0>;
-	port_sel = <0>; /* Shared SPI */
+	chip-select = <0>;
 
 	pinctrl-0 = < &shd_cs0_n_gpio055
 		      &shd_clk_gpio056
@@ -299,3 +283,7 @@
 	pinctrl-0 = <&ps2_clk0a_gpio114 &ps2_dat0a_gpio115>;
 	pinctrl-names = "default";
 };
+
+&timer5 {
+	status = "okay";
+};
-- 
2.25.1


From c9097ef377fc7544c27ac3f73453e3457e163bca Mon Sep 17 00:00:00 2001
From: Manimaran A <manimaran.a@microchip.com>
Date: Thu, 31 Aug 2023 16:40:41 +0530
Subject: [PATCH 04/12] drivers: spi: Microchip MEC172x SPI fix for Zephyr 3.4
 breakage

Zephyr version 3.4 changed the SPI context structure and macros
which broke the logic in the MEC172x SPI driver configuration API.
This was not detected by CI due to no tests for this driver are in
the tree. The driver now behaves like most other SPI drivers requiring
a different configuration structure pointer to be passed if any item
in the configuration changes.

Signed-off-by: Manimaran A <manimaran.a@microchip.com>
---
 drivers/spi/spi_xec_qmspi_ldma.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/drivers/spi/spi_xec_qmspi_ldma.c b/drivers/spi/spi_xec_qmspi_ldma.c
index a5ba08e600..ab48e49c09 100644
--- a/drivers/spi/spi_xec_qmspi_ldma.c
+++ b/drivers/spi/spi_xec_qmspi_ldma.c
@@ -346,7 +346,6 @@ static int qmspi_configure(const struct device *dev,
 {
 	const struct spi_qmspi_config *cfg = dev->config;
 	struct spi_qmspi_data *qdata = dev->data;
-	const struct spi_config *curr_cfg = qdata->ctx.config;
 	struct qmspi_regs *regs = cfg->regs;
 	uint32_t smode;
 	int ret;
@@ -355,13 +354,11 @@ static int qmspi_configure(const struct device *dev,
 		return -EINVAL;
 	}
 
-	if (curr_cfg->frequency != config->frequency) {
-		qmspi_set_frequency(qdata, regs, config->frequency);
+	if (spi_context_configured(&qdata->ctx, config)) {
+		return 0;
 	}
 
-	if (curr_cfg->operation == config->operation) {
-		return 0; /* no change required */
-	}
+	qmspi_set_frequency(qdata, regs, config->frequency);
 
 	/* check new configuration */
 	ret = spi_feature_support(config);
-- 
2.25.1


From 0caf37e9b71139d2f480b49cfe7a51f5bceac5e9 Mon Sep 17 00:00:00 2001
From: Manimaran A <manimaran.a@microchip.com>
Date: Thu, 31 Aug 2023 16:42:50 +0530
Subject: [PATCH 05/12] tests: boards: mec172xevb_assy6906 Add SPI driver test

Add a test for the Microchip MEC172x SPI driver using the
mec172xevb_assy6906 board with an external SPI dongle.

Signed-off-by: Manimaran A <manimaran.a@microchip.com>
---
 .../mec172xevb_assy6906/qspi/CMakeLists.txt   |   8 +
 .../mec172xevb_assy6906/qspi/README.txt       |   2 +
 .../qspi/boards/mec172xevb_assy6906.overlay   |  18 +
 .../boards/mec172xevb_assy6906/qspi/prj.conf  |   5 +
 .../mec172xevb_assy6906/qspi/src/main.c       | 657 ++++++++++++++++++
 .../mec172xevb_assy6906/qspi/testcase.yaml    |   7 +
 6 files changed, 697 insertions(+)
 create mode 100644 tests/boards/mec172xevb_assy6906/qspi/CMakeLists.txt
 create mode 100644 tests/boards/mec172xevb_assy6906/qspi/README.txt
 create mode 100644 tests/boards/mec172xevb_assy6906/qspi/boards/mec172xevb_assy6906.overlay
 create mode 100644 tests/boards/mec172xevb_assy6906/qspi/prj.conf
 create mode 100644 tests/boards/mec172xevb_assy6906/qspi/src/main.c
 create mode 100644 tests/boards/mec172xevb_assy6906/qspi/testcase.yaml

diff --git a/tests/boards/mec172xevb_assy6906/qspi/CMakeLists.txt b/tests/boards/mec172xevb_assy6906/qspi/CMakeLists.txt
new file mode 100644
index 0000000000..5c67227190
--- /dev/null
+++ b/tests/boards/mec172xevb_assy6906/qspi/CMakeLists.txt
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(qspi)
+
+target_sources(app PRIVATE src/main.c)
diff --git a/tests/boards/mec172xevb_assy6906/qspi/README.txt b/tests/boards/mec172xevb_assy6906/qspi/README.txt
new file mode 100644
index 0000000000..6cab25952b
--- /dev/null
+++ b/tests/boards/mec172xevb_assy6906/qspi/README.txt
@@ -0,0 +1,2 @@
+Build test for:
+  Microchip mec172xevb_assy6906 qspi driver test.
diff --git a/tests/boards/mec172xevb_assy6906/qspi/boards/mec172xevb_assy6906.overlay b/tests/boards/mec172xevb_assy6906/qspi/boards/mec172xevb_assy6906.overlay
new file mode 100644
index 0000000000..c59d40a485
--- /dev/null
+++ b/tests/boards/mec172xevb_assy6906/qspi/boards/mec172xevb_assy6906.overlay
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+&spi0 {
+        status = "okay";
+        chip-select = <0>;
+        lines = <4>;
+
+        pinctrl-0 = < &shd_cs0_n_gpio055
+                      &shd_clk_gpio056
+                      &shd_io0_gpio223
+                      &shd_io1_gpio224
+                      &shd_io2_gpio227
+                      &shd_io3_gpio016 >;
+};
diff --git a/tests/boards/mec172xevb_assy6906/qspi/prj.conf b/tests/boards/mec172xevb_assy6906/qspi/prj.conf
new file mode 100644
index 0000000000..0637abd47e
--- /dev/null
+++ b/tests/boards/mec172xevb_assy6906/qspi/prj.conf
@@ -0,0 +1,5 @@
+CONFIG_SPI=y
+CONFIG_SPI_EXTENDED_MODES=y
+CONFIG_ZTEST=y
+CONFIG_ZTEST_NEW_API=y
+CONFIG_TEST_USERSPACE=y
diff --git a/tests/boards/mec172xevb_assy6906/qspi/src/main.c b/tests/boards/mec172xevb_assy6906/qspi/src/main.c
new file mode 100644
index 0000000000..feac946c46
--- /dev/null
+++ b/tests/boards/mec172xevb_assy6906/qspi/src/main.c
@@ -0,0 +1,657 @@
+/*
+ * Copyright (c) 2020 Intel Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/ztest.h>
+#include <zephyr/drivers/spi.h>
+
+#define TEST_FREQ_HZ 24000000U
+#define W25Q128_JEDEC_ID 0x001840efU
+
+#define TEST_BUF_SIZE 4096U
+/* #define MAX_SPI_BUF 8 */
+
+#define SPI_STATUS1_BUSY 0x01U
+#define SPI_STATUS1_WEL 0x02U
+#define SPI_STATUS2_QE 0x02U
+#define SPI_READ_JEDEC_ID 0x9FU
+#define SPI_READ_STATUS1 0x05U
+#define SPI_READ_STATUS2 0x35U
+#define SPI_WRITE_STATUS2 0x31U
+#define SPI_WRITE_ENABLE_VS 0x50U
+#define SPI_WRITE_ENABLE 0x06U
+#define SPI_SECTOR_ERASE 0x20U
+#define SPI_SINGLE_WRITE_DATA 0x02U
+#define SPI_QUAD_WRITE_DATA 0x32U
+
+/* bits[7:0] = spi opcode,
+ * bits[15:8] = bytes number of clocks with data lines tri-stated
+ */
+#define SPI_FAST_READ_DATA 0x080BU
+#define SPI_DUAL_FAST_READ_DATA 0x083BU
+#define SPI_QUAD_FAST_READ_DATA 0x086BU
+#define SPI_OCTAL_QUAD_READ_DATA 0xE3U
+
+#define BUF_SIZE 11
+uint8_t buffer_tx[] = "0123456789\0";
+#define BUF_SIZE_2 7
+uint8_t buffer_tx_2[] = "abcdef\0";
+
+#define SPI_TEST_ADDRESS 0x000010U
+#define SPI_TEST_ADDRESS_2 0x000020U
+
+static uint8_t safbuf[TEST_BUF_SIZE] __aligned(4);
+static uint8_t safbuf2[TEST_BUF_SIZE] __aligned(4);
+static const struct device *const spi_dev = DEVICE_DT_GET(DT_NODELABEL(spi0));
+
+/* static struct spi_buf spi_bufs[MAX_SPI_BUF]; */
+
+static const struct spi_config spi_cfg_single = {
+	.frequency = TEST_FREQ_HZ,
+	.operation = (SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8)
+		      | SPI_LINES_SINGLE),
+};
+
+static const struct spi_config spi_cfg_single_hold_cs = {
+	.frequency = TEST_FREQ_HZ,
+	.operation = (SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8)
+		      | SPI_LINES_SINGLE | SPI_HOLD_ON_CS),
+};
+
+static const struct spi_config spi_cfg_dual = {
+	.frequency = TEST_FREQ_HZ,
+	.operation = (SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8)
+		      | SPI_LINES_DUAL),
+};
+
+static const struct spi_config spi_cfg_quad = {
+	.frequency = TEST_FREQ_HZ,
+	.operation = (SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8)
+		      | SPI_LINES_QUAD),
+};
+
+static void spi_single_init(void)
+{
+	zassert_true(device_is_ready(spi_dev), "SPI controller device is not ready");
+}
+
+static void clear_buffers(void)
+{
+	memset(safbuf, 0, sizeof(safbuf));
+	memset(safbuf2, 0, sizeof(safbuf2));
+}
+
+/* Compute the number of bytes required to generate the requested number of
+ * SPI clocks based on single, dual, or quad mode.
+ * mode = 1(full-duplex), 2(dual), 4(quad)
+ * full-duplex: 8 clocks per byte
+ * dual: 4 clocks per byte
+ * quad: 2 clocks per byte
+ */
+static uint32_t spi_clocks_to_bytes(uint32_t spi_clocks, uint8_t mode)
+{
+	uint32_t nbytes;
+
+	if (mode == 4u) {
+		nbytes = spi_clocks / 2U;
+	} else if (mode == 2u) {
+		nbytes = spi_clocks / 4U;
+	} else {
+		nbytes = spi_clocks / 8U;
+	}
+
+	return nbytes;
+}
+
+
+static int spi_flash_address_format(uint8_t *dest, size_t destsz,
+				    uint32_t spi_addr, size_t addrsz)
+{
+	if (!dest || (addrsz == 0) || (addrsz > 4U) || (addrsz > destsz)) {
+		return -EINVAL;
+	}
+
+	for (size_t i = 0; i < addrsz; i++) {
+		dest[i] = (uint8_t)((spi_addr >> ((addrsz - (i + 1U)) * 8U)) & 0xffU);
+	}
+
+	return 0;
+}
+
+static int spi_flash_read_status(const struct device *dev, uint8_t opcode, uint8_t *status)
+{
+	struct spi_buf spi_bufs[2] = { 0 };
+	uint32_t txdata = 0;
+	uint32_t rxdata = 0;
+	int ret = 0;
+
+	txdata = opcode;
+
+	spi_bufs[0].buf = &txdata;
+	spi_bufs[0].len = 1U;
+	spi_bufs[1].buf = &rxdata;
+	spi_bufs[1].len = 1U;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 2U,
+	};
+	const struct spi_buf_set rxset = {
+		.buffers = &spi_bufs[0],
+		.count = 2U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, &rxset);
+	if (ret) {
+		return ret;
+	}
+
+	if (status) {
+		*status = (uint8_t)(rxdata & 0xffu);
+	}
+
+	return 0;
+}
+
+static int spi_flash_write_status(const struct device *dev, uint8_t opcode, uint8_t spi_status)
+{
+	struct spi_buf spi_bufs[1] = { 0 };
+	uint32_t txdata = 0;
+	int ret = 0;
+
+	txdata = spi_status;
+	txdata <<= 8U;
+	txdata |= opcode;
+
+	spi_bufs[0].buf = &txdata;
+	spi_bufs[0].len = 2U;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 1U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, NULL);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int spi_flash_tx_one_byte_cmd(const struct device *dev, uint8_t opcode)
+{
+	struct spi_buf spi_bufs[1] = { 0 };
+	uint32_t txdata = 0;
+	int ret = 0;
+
+	txdata = opcode;
+	spi_bufs[0].buf = &txdata;
+	spi_bufs[0].len = 1U;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 1U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, NULL);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Test spi device
+ * @details
+ * - Find spi device
+ * - Read flash jedec id
+ */
+ZTEST_USER(spi, test_spi_device)
+{
+	struct spi_buf spi_bufs[2] = { 0 };
+	uint32_t txdata = 0;
+	uint32_t jedec_id = 0;
+	int ret = 0;
+
+	/* read jedec id */
+	txdata = SPI_READ_JEDEC_ID;
+
+	spi_bufs[0].buf = &txdata;
+	spi_bufs[0].len = 1U;
+	spi_bufs[1].buf = &jedec_id;
+	spi_bufs[1].len = 3U;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 2U,
+	};
+	const struct spi_buf_set rxset = {
+		.buffers = &spi_bufs[0],
+		.count = 2U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, &rxset);
+	zassert_true(ret == 0, "Read JEDEC ID spi_transceive failure: "
+			"error %d", ret);
+	zassert_true(jedec_id == W25Q128_JEDEC_ID,
+		     "JEDEC ID doesn't match: expected 0x%08x, read 0x%08x",
+		     W25Q128_JEDEC_ID, jedec_id);
+}
+
+/**
+ * @brief Test spi sector erase
+ * @details
+ * - write enable
+ * - erase data in flash device
+ * - read register1 and wait for erase operation completed
+ */
+ZTEST_USER(spi_sector_erase, test_spi_sector_erase)
+{
+	struct spi_buf spi_bufs[2] = { 0 };
+	int ret = 0;
+	uint8_t spi_status = 0;
+
+	clear_buffers();
+
+	/* write enable */
+	ret = spi_flash_tx_one_byte_cmd(spi_dev, SPI_WRITE_ENABLE);
+	zassert_true(ret == 0, "Send write enable spi_transceive failure: error %d", ret);
+
+	/* erase data start from address SPI_TEST_ADDRESS */
+	safbuf[0] = SPI_SECTOR_ERASE;
+	spi_flash_address_format(&safbuf[1], 4U, SPI_TEST_ADDRESS, 3U);
+
+	spi_bufs[0].buf = &safbuf;
+	spi_bufs[0].len = 4;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 1U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, NULL);
+	zassert_true(ret == 0, "Send sector erase data spi_transceive failure: error %d", ret);
+
+	/* read SPI flash status  register1 to check whether erase operation completed */
+	spi_status = SPI_STATUS1_BUSY;
+	while (spi_status & SPI_STATUS1_BUSY) {
+		ret = spi_flash_read_status(spi_dev, SPI_READ_STATUS1, &spi_status);
+		zassert_true(ret == 0, "Send read register1 spi_transceive "
+			     "failure: error %d", ret);
+	}
+}
+
+/**
+ * @brief Write data into flash using spi api
+ * @details
+ * - flash write enable
+ * - write data into flash using spi api
+ */
+static void test_spi_single_write(void)
+{
+	struct spi_buf spi_bufs[1] = { 0 };
+	int ret = 0;
+	uint8_t spi_status = 0;
+
+	clear_buffers();
+
+	ret = spi_flash_tx_one_byte_cmd(spi_dev, SPI_WRITE_ENABLE);
+	zassert_true(ret == 0, "Send write enable spi_transceive failure: "
+			       "error %d", ret);
+
+	/* write data start from address SPI_TEST_ADDRESS */
+	safbuf[0] = SPI_SINGLE_WRITE_DATA;
+	spi_flash_address_format(&safbuf[1], 4U, SPI_TEST_ADDRESS, 3U);
+
+	memcpy(&safbuf[4], buffer_tx, BUF_SIZE);
+
+	spi_bufs[0].buf = &safbuf;
+	spi_bufs[0].len = 4U + BUF_SIZE;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 1U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, NULL);
+	zassert_true(ret == 0, "Send write data spi_transceive failure: error %d", ret);
+
+	/* read register1 to check whether program operation completed */
+	spi_status = SPI_STATUS1_BUSY;
+	while (spi_status & SPI_STATUS1_BUSY) {
+		ret = spi_flash_read_status(spi_dev, SPI_READ_STATUS1, &spi_status);
+		zassert_true(ret == 0, "Read SPI flash STATUS opcode 0x%02x error: %d",
+			     SPI_READ_STATUS1, ret);
+	}
+}
+
+/**
+ * @brief Read data from flash using spi single mode
+ * @details
+ * - read data using spi single mode
+ * - check read buffer data whether correct
+ * @note SPI flash fast instructions require a certain number of SPI clocks
+ * to be generated with I/O lines tri-stated after the address has been
+ * transmitted. The purpose is allow SPI flash time to move get data ready
+ * and enable its output line(s). The MCHP XEC SPI driver can do this by
+ * specifying a struct spi_buf with buf pointer set to NULL and length set
+ * to the number of bytes which will generate the required number of clocks.
+ * For full-duplex one byte is 8 clocks, dual one byte is 4 clocks, and for
+ * quad one byte is 2 clocks.
+ */
+ZTEST_USER(spi, test_spi_single_read)
+{
+	struct spi_buf spi_bufs[3] = { 0 };
+	int ret = 0;
+	uint16_t spi_opcode = 0;
+	uint8_t cnt = 0;
+
+	clear_buffers();
+
+	/* bits[7:0] = opcode,
+	 * bits[15:8] = number of SPI clocks with I/O lines tri-stated after
+	 * address transmit before data read phase.
+	 */
+	spi_opcode = SPI_FAST_READ_DATA;
+
+	/* read data using spi single mode */
+	/* set the spi operation code and address */
+	safbuf[0] = spi_opcode & 0xFFU;
+	spi_flash_address_format(&safbuf[1], 4U, SPI_TEST_ADDRESS, 3U);
+
+	spi_bufs[cnt].buf = &safbuf;
+	spi_bufs[cnt].len = 4U;
+
+	/* set the dummy clocks */
+	if (spi_opcode & 0xFF00U) {
+		cnt++;
+		spi_bufs[cnt].buf = NULL;
+		spi_bufs[cnt].len = spi_clocks_to_bytes(((spi_opcode >> 8) & 0xffU), 1u);
+	}
+
+	cnt++;
+	spi_bufs[cnt].buf = &safbuf2;
+	spi_bufs[cnt].len = BUF_SIZE;
+	cnt++; /* total number of buffers */
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = cnt,
+	};
+
+	const struct spi_buf_set rxset = {
+		.buffers = &spi_bufs[0],
+		.count = cnt,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single, &txset, &rxset);
+	zassert_true(ret == 0, "Send fast read data spi_transceive failure: error %d", ret);
+
+	/* check read buffer data whether correct */
+	zassert_true(memcmp(buffer_tx, safbuf2, BUF_SIZE) == 0,
+		     "Buffer read data is different to write data");
+}
+
+static void spi_dual_init(void)
+{
+	zassert_true(device_is_ready(spi_dev), "SPI controller device is not ready");
+}
+
+/**
+ * @brief Read data from flash using spi dual mode
+ * @details
+ * - read data using spi dual mode
+ * - check read buffer data whether correct
+ */
+ZTEST_USER(spi, test_spi_dual_read)
+{
+	struct spi_buf spi_bufs[3] = { 0 };
+	int ret = 0;
+	uint16_t spi_opcode = 0;
+	uint8_t cnt = 0;
+
+	clear_buffers();
+
+	spi_dual_init();
+
+	spi_opcode = SPI_DUAL_FAST_READ_DATA;
+
+	/* read data using spi dual mode */
+	/* set the spi operation code and address */
+	safbuf[0] = spi_opcode & 0xFFU;
+	spi_flash_address_format(&safbuf[1], 4U, SPI_TEST_ADDRESS, 3U);
+
+	spi_bufs[cnt].buf = &safbuf;
+	spi_bufs[cnt].len = 4U;
+
+	/* set the dummy clocks */
+	if (spi_opcode & 0xFF00U) {
+		cnt++;
+		spi_bufs[cnt].buf = NULL;
+		spi_bufs[cnt].len = spi_clocks_to_bytes(((spi_opcode >> 8) & 0xffU), 1u);
+	}
+
+	cnt++;
+	spi_bufs[cnt].buf = &safbuf2;
+	spi_bufs[cnt].len = BUF_SIZE;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = cnt,
+	};
+
+	const struct spi_buf_set rxset = {
+		.buffers = &spi_bufs[cnt],
+		.count = 1U,
+	};
+
+	/* send opcode, address, and tri-state clocks  using single mode */
+	ret = spi_transceive(spi_dev, &spi_cfg_single_hold_cs, &txset, NULL);
+	zassert_true(ret == 0, "Send fast read data spi_transceive failure: error %d", ret);
+
+	/* get read data using dual mode */
+	ret = spi_transceive(spi_dev, &spi_cfg_dual, NULL, &rxset);
+	zassert_true(ret == 0, "Receive fast read data spi_transceive failure: error %d", ret);
+
+	/* check read buffer data whether correct */
+	zassert_true(memcmp(buffer_tx, safbuf2, BUF_SIZE) == 0,
+		     "Buffer read data is different to write data");
+
+	/* release spi device */
+	ret = spi_release(spi_dev, &spi_cfg_single);
+	zassert_true(ret == 0, "Spi release failure: error %d", ret);
+}
+
+/**
+ * @brief Write data into flash using spi quad mode
+ * @details
+ * - check and make sure spi quad mode is enabled
+ * - write data using spi quad mode
+ */
+static void test_spi_quad_write(void)
+{
+	struct spi_buf spi_bufs[2] = { 0 };
+	int ret = 0;
+	uint8_t spi_status = 0;
+	uint8_t spi_status2 = 0;
+
+	clear_buffers();
+
+	/* read register2 to judge whether quad mode is enabled */
+	ret = spi_flash_read_status(spi_dev, SPI_READ_STATUS2, &spi_status2);
+	zassert_true(ret == 0, "SPI read flash STATUS2 failure: error %d", ret);
+
+	/* set register2 QE=1 to enable quad mode. We write the volatile STATUS2 register
+	 * not the normal STATUS2 which retains the value across a power cycle.
+	 */
+	if ((spi_status2 & SPI_STATUS2_QE) == 0U) {
+		ret = spi_flash_tx_one_byte_cmd(spi_dev, SPI_WRITE_ENABLE_VS);
+		zassert_true(ret == 0, "Send write enable volatile spi_transceive failure: "
+			     "error %d", ret);
+
+		spi_status2 |= SPI_STATUS2_QE;
+		ret = spi_flash_write_status(spi_dev, SPI_WRITE_STATUS2, spi_status2);
+		zassert_true(ret == 0, "Write spi status2 QE=1 spi_transceive failure: "
+			     "error %d", ret);
+
+		/* read register2 to confirm quad mode is enabled */
+		spi_status2 = 0u;
+		ret = spi_flash_read_status(spi_dev, SPI_READ_STATUS2, &spi_status2);
+		zassert_true(ret == 0, "Read register2 status spi_transceive failure: "
+			     "error %d", ret);
+
+		zassert_true((spi_status2 & SPI_STATUS2_QE) == SPI_STATUS2_QE,
+			     "Enable QSPI mode failure");
+	}
+
+	/* write enable */
+	ret = spi_flash_tx_one_byte_cmd(spi_dev, SPI_WRITE_ENABLE);
+	zassert_true(ret == 0, "Send write enable spi_transceive failure: error %d", ret);
+
+	/* write data using spi quad mode */
+	/* send quad write opcode and address using single mode */
+	safbuf[0] = SPI_QUAD_WRITE_DATA;
+	spi_flash_address_format(&safbuf[1], 4U, SPI_TEST_ADDRESS_2, 3U);
+
+	spi_bufs[0].buf = &safbuf;
+	spi_bufs[0].len = 4;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = 1U,
+	};
+
+	ret = spi_transceive(spi_dev, &spi_cfg_single_hold_cs, &txset, NULL);
+	zassert_true(ret == 0, "Send quad write data spi_transceive failure: error %d", ret);
+
+	/* send data using quad mode */
+	memcpy(&safbuf[0], buffer_tx_2, BUF_SIZE_2);
+
+	spi_bufs[0].buf = &safbuf;
+	spi_bufs[0].len = BUF_SIZE_2;
+
+	ret = spi_transceive(spi_dev, &spi_cfg_quad, &txset, NULL);
+	zassert_true(ret == 0, "Send quad write data spi_transceive failure: error %d", ret);
+
+	/* call SPI release API to clear SPI CS Hold On lock */
+	ret = spi_release(spi_dev, &spi_cfg_single);
+	zassert_true(ret == 0, "Spi release failure: error %d", ret);
+
+	/* poll busy bit in flash status1 register */
+	spi_status = SPI_STATUS1_BUSY;
+	while (spi_status & SPI_STATUS1_BUSY) {
+		ret = spi_flash_read_status(spi_dev, SPI_READ_STATUS1, &spi_status);
+		zassert_true(ret == 0, "Read flash STATUS1 register error %d", ret);
+	}
+}
+
+/**
+ * @brief Read data from flash using spi quad mode
+ * @details
+ * - read data using spi quad mode
+ * - check read buffer data whether correct
+ */
+ZTEST_USER(spi_quad, test_spi_quad_read)
+{
+	struct spi_buf spi_bufs[3] = {0};
+	int ret = 0;
+	uint16_t spi_opcode = 0;
+	uint8_t cnt = 0;
+
+	clear_buffers();
+
+	spi_opcode = SPI_QUAD_FAST_READ_DATA;
+
+	/* read data using spi quad mode
+	 * Transmit opcode, address, and tri-state clocks using full-duplex mode
+	 * with driver Hold CS ON flag.
+	 * Next, read data using dual configuration.
+	 * Call driver release API to release lock set by Hold CS ON flag.
+	 */
+
+	/* set the spi operation code and address */
+	safbuf[0] = spi_opcode & 0xFFU;
+	spi_flash_address_format(&safbuf[1], 4U, SPI_TEST_ADDRESS_2, 3U);
+
+	spi_bufs[cnt].buf = &safbuf;
+	spi_bufs[cnt].len = 4U;
+
+	/* set the dummy clocks */
+	if (spi_opcode & 0xFF00U) {
+		cnt++;
+		spi_bufs[cnt].buf = NULL;
+		spi_bufs[cnt].len = spi_clocks_to_bytes(((spi_opcode >> 8) & 0xffU), 1u);
+	}
+
+	cnt++;
+	spi_bufs[cnt].buf = &safbuf2;
+	spi_bufs[cnt].len = BUF_SIZE_2;
+
+	const struct spi_buf_set txset = {
+		.buffers = &spi_bufs[0],
+		.count = cnt,
+	};
+
+	const struct spi_buf_set rxset = {
+		.buffers = &spi_bufs[cnt],
+		.count = 1U,
+	};
+
+	/* send opcode and address using single mode with Hold CS ON flag */
+	ret = spi_transceive(spi_dev, &spi_cfg_single_hold_cs, &txset, NULL);
+	zassert_true(ret == 0, "Send fast read data spi_transceive failure: error %d", ret);
+
+	/* read data using quad mode */
+	ret = spi_transceive(spi_dev, &spi_cfg_quad, NULL, &rxset);
+	zassert_true(ret == 0, "Receive fast read data spi_transceive failure: error %d", ret);
+
+	/* release spi device */
+	ret = spi_release(spi_dev, &spi_cfg_single);
+	zassert_true(ret == 0, "Spi release failure: error %d", ret);
+
+	/* check read buffer data whether correct */
+	zassert_true(memcmp(buffer_tx_2, safbuf2, BUF_SIZE_2) == 0,
+		     "Buffer read data is different to write data");
+}
+
+void *spi_setup(void)
+{
+	spi_single_init();
+
+	return NULL;
+}
+
+void *spi_single_setup(void)
+{
+	spi_single_init();
+
+	/* The writing test goes
+	 * first berfore testing
+	 * the reading.
+	 */
+	test_spi_single_write();
+
+	return NULL;
+}
+
+void *spi_quad_setup(void)
+{
+	spi_dual_init();
+
+	/* The writing test goes
+	 * first berfore testing
+	 * the reading.
+	 */
+	test_spi_quad_write();
+
+	return NULL;
+}
+
+/* Test assumes flash test regions is in erased state */
+ZTEST_SUITE(spi, NULL, spi_single_setup, NULL, NULL, NULL);
+ZTEST_SUITE(spi_quad, NULL, spi_quad_setup, NULL, NULL, NULL);
+ZTEST_SUITE(spi_sector_erase, NULL, spi_setup, NULL, NULL, NULL);
diff --git a/tests/boards/mec172xevb_assy6906/qspi/testcase.yaml b/tests/boards/mec172xevb_assy6906/qspi/testcase.yaml
new file mode 100644
index 0000000000..f0302f66cb
--- /dev/null
+++ b/tests/boards/mec172xevb_assy6906/qspi/testcase.yaml
@@ -0,0 +1,7 @@
+tests:
+  boards.mec172xevb_assy6906.qspi:
+    platform_allow: mec172xevb_assy6906
+    tags:
+      - drivers
+      - spi
+      - qspi
-- 
2.25.1


From 6987283f25c7afee6ef41c85572f36a58f79a040 Mon Sep 17 00:00:00 2001
From: Jeff Daly <jeffd@silicom-usa.com>
Date: Mon, 14 Aug 2023 17:29:16 -0400
Subject: [PATCH 06/12] Microchip: MEC172X DTS files reorganization

MEC172X series SoCs share most IP but the -LJ series expands the PWM and
ADC channels available as well as defines extra pinctrl pins.
Separating these better to be able to simplify their inclusion and
driver code.  Any board based on either the -SZ or -LJ package can just
include the mec172x<sz/lj> dtsi files for their specific package.

Signed-off-by: Jeff Daly <jeffd@silicom-usa.com>
Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/arm/microchip/mec1727nsz.dtsi             |   41 +-
 .../microchip/mec172x/mec172xnlj-pinctrl.dtsi |    2 +-
 dts/arm/microchip/mec172x_common.dtsi         | 1001 +++++++++++++++++
 dts/arm/microchip/mec172xnlj.dtsi             |   67 +-
 dts/arm/microchip/mec172xnsz.dtsi             |  995 +---------------
 5 files changed, 1109 insertions(+), 997 deletions(-)
 create mode 100644 dts/arm/microchip/mec172x_common.dtsi

diff --git a/dts/arm/microchip/mec1727nsz.dtsi b/dts/arm/microchip/mec1727nsz.dtsi
index 565e5f9ff4..62d4d0985d 100644
--- a/dts/arm/microchip/mec1727nsz.dtsi
+++ b/dts/arm/microchip/mec1727nsz.dtsi
@@ -11,14 +11,53 @@
 #include <zephyr/dt-bindings/clock/mchp_xec_pcr.h>
 #include <zephyr/dt-bindings/interrupt-controller/mchp-xec-ecia.h>
 
-#include "mec172xnsz.dtsi"
 #include "mec172x/mec172x-vw-routing.dtsi"
 #include "mec172x/mec172xnsz-pinctrl.dtsi"
 
 / {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-m4";
+			reg = <0>;
+			cpu-power-states = <&idle &suspend_to_ram>;
+		};
+
+		power-states {
+			idle: idle {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-idle";
+				min-residency-us = <1000000>;
+			};
+
+			suspend_to_ram: suspend_to_ram {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-ram";
+				min-residency-us = <2000000>;
+			};
+		};
+	};
+
+	flash0: flash@c0000 {
+		reg = <0x000C0000 0x58000>;
+	};
+
 	flash1: flash@60000000 {
 		reg = <0x60000000 0x80000>;
 	};
+
+	sram0: memory@118000 {
+		compatible = "mmio-sram";
+		reg = <0x00118000 0x10000>;
+	};
+
+	soc {
+		#include "mec172x_common.dtsi"
+	};
+
 };
 
 &spi0 {
diff --git a/dts/arm/microchip/mec172x/mec172xnlj-pinctrl.dtsi b/dts/arm/microchip/mec172x/mec172xnlj-pinctrl.dtsi
index ac5b43a67a..47502d289c 100644
--- a/dts/arm/microchip/mec172x/mec172xnlj-pinctrl.dtsi
+++ b/dts/arm/microchip/mec172x/mec172xnlj-pinctrl.dtsi
@@ -4,7 +4,7 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-#include <zephyr/dt-bindings/pinctrl/mchp-xec-pinctrl.h>
+#include "mec172xnsz-pinctrl.dtsi"
 
 &pinctrl {
 
diff --git a/dts/arm/microchip/mec172x_common.dtsi b/dts/arm/microchip/mec172x_common.dtsi
new file mode 100644
index 0000000000..03a6a00fb4
--- /dev/null
+++ b/dts/arm/microchip/mec172x_common.dtsi
@@ -0,0 +1,1001 @@
+/*
+ * Copyright (c) 2021 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+ecs: ecs@4000fc00 {
+	reg = <0x4000fc00 0x200>;
+};
+pcr: pcr@40080100 {
+	compatible = "microchip,xec-pcr";
+	reg = <0x40080100 0x100 0x4000a400 0x100>;
+	reg-names = "pcrr", "vbatr";
+	interrupts = <174 0>;
+	core-clock-div = <1>;
+	/* MEC172x allows sources to be different */
+	pll-32k-src = <MCHP_XEC_PLL_CLK32K_SRC_SIL_OSC>;
+	periph-32k-src = <MCHP_XEC_PERIPH_CLK32K_SRC_SO_SO>;
+	clk32kmon-period-min = <1435>;
+	clk32kmon-period-max = <1495>;
+	clk32kmon-duty-cycle-var-max = <132>;
+	clk32kmon-valid-min = <4>;
+	xtal-enable-delay-ms = <300>;
+	pll-lock-timeout-ms = <30>;
+	/* pin configured only if one of the sources is set to PIN */
+	pinctrl-0 = <&clk_32khz_in_gpio165>;
+	pinctrl-names = "default";
+	#clock-cells = <3>;
+};
+ecia: ecia@4000e000 {
+	compatible = "microchip,xec-ecia";
+	reg = <0x4000e000 0x400>;
+	direct-capable-girqs = <13 14 15 16 17 18 19 20 21 23>;
+	clocks = <&pcr 1 0 MCHP_XEC_PCR_CLK_PERIPH>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	ranges = <0x0 0x4000e000 0x400>;
+
+	girq8: girq8@0 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x0 0x14>;
+		interrupts = <0 0>;
+		girq-id = <0>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15
+			   16 17 18 21 22 24 25
+			   26 27 28 29>;
+		status = "disabled";
+	};
+	girq9: girq9@14 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x14 0x14>;
+		interrupts = <1 0>;
+		girq-id = <1>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15
+			   16 17 18 19 20 21 22 23
+			   24 25 26 27 28 29>;
+		status = "disabled";
+	};
+	girq10: girq10@28 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x28 0x14>;
+		interrupts = <2 0>;
+		girq-id = <2>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15
+			   16 17 18 19 20 21 22 23
+			   24 25 26 27 28 29 30>;
+		status = "disabled";
+	};
+	girq11: girq11@3c {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x3c 0x14>;
+		interrupts = <3 0>;
+		girq-id = <3>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15
+			   16 17 18 19 20 21 22 23
+			   24 25 26 27 28 29 30>;
+		status = "disabled";
+	};
+	girq12: girq12@50 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x50 0x14>;
+		interrupts = <4 0>;
+		girq-id = <4>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15
+			   16 17 18 19 20 21 22 23
+			   24 25 26 27 28 29 30>;
+		status = "disabled";
+	};
+	girq13: girq13@64 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x64 0x14>;
+		interrupts = <5 0>;
+		girq-id = <5>;
+		sources = <0 1 2 3 4>;
+		status = "disabled";
+	};
+	girq14: girq14@78 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x78 0x14>;
+		interrupts = <6 0>;
+		girq-id = <6>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15>;
+		status = "disabled";
+	};
+	girq15: girq15@8c {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x8c 0x14>;
+		interrupts = <7 0>;
+		girq-id = <7>;
+		sources = <0 1 2 3 4 5 6 7
+			   8 9 10 11 12 13 14 15
+			   16 17 18 19 20 22>;
+		status = "disabled";
+	};
+	girq16: girq16@a0 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0xa0 0x14>;
+		interrupts = <8 0>;
+		girq-id = <8>;
+		sources = <0 2 3>;
+		status = "disabled";
+	};
+	girq17: girq17@b4 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0xb4 0x14>;
+		interrupts = <9 0>;
+		girq-id = <9>;
+		sources = <0 1 2 3 4 8 9 10 11 12 13 14 15
+			   16 17 20 21 22 23>;
+		status = "disabled";
+	};
+	girq18: girq18@c8 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0xc8 0x14>;
+		interrupts = <10 0>;
+		girq-id = <10>;
+		sources = <0 1 2 3 4 5 6 7
+			   10 20 21 22 23
+			   24 25 26 27 28>;
+		status = "disabled";
+	};
+	girq19: girq19@dc {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0xdc 0x14>;
+		interrupts = <11 0>;
+		girq-id = <11>;
+		sources = <0 1 2 3 4 5 6 7 8 9 10>;
+		status = "disabled";
+	};
+	girq20: girq20@f0 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0xf0 0x14>;
+		interrupts = <12 0>;
+		girq-id = <12>;
+		sources = <3 9>;
+		status = "disabled";
+	};
+	girq21: girq21@104 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x104 0x14>;
+		interrupts = <13 0>;
+		girq-id = <13>;
+		sources = <2 3 4 5 6 7 8 9 10 11 12 13 14 15
+			   18 19 25 26>;
+		status = "disabled";
+	};
+	girq22: girq22@118 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x118 0x14>;
+		interrupts = <255 0>;
+		girq-id = <14>;
+		sources = <0 1 2 3 4 5 9 15>;
+		status = "disabled";
+	};
+	girq23: girq23@12c {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x12c 0x14>;
+		interrupts = <14 0>;
+		girq-id = <15>;
+		sources = <0 1 2 3 4 5 6 7 8 9 10 16 17>;
+		status = "disabled";
+	};
+	girq24: girq24@140 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x140 0x14>;
+		interrupts = <15 0>;
+		girq-id = <16>;
+		sources = <0 1 2 3 4 5 6 7 8 9 10 11
+			   12 13 14 15 16 17 18 19
+			   20 21 22 23 24 25 26 27>;
+		status = "disabled";
+	};
+	girq25: girq25@154 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x154 0x14>;
+		interrupts = <16 0>;
+		girq-id = <17>;
+		sources = <0 1 2 3 4 5 6 7 8 9 10 11
+			   12 13 14 15>;
+		status = "disabled";
+	};
+	girq26: girq26@168 {
+		compatible = "microchip,xec-ecia-girq";
+		reg = <0x168 0x14>;
+		interrupts = <17 0>;
+		girq-id = <18>;
+		sources = <0 1 2 3 4 5 6 12 13>;
+		status = "disabled";
+	};
+};
+pinctrl: pin-controller@40081000 {
+	compatible = "microchip,xec-pinctrl";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	reg = <0x40081000 0x1000>;
+
+	gpio_000_036: gpio@40081000 {
+		compatible = "microchip,xec-gpio-v2";
+		reg = < 0x40081000 0x80 0x40081300 0x04
+			0x40081380 0x04 0x400813fc 0x04>;
+		interrupts = <3 2>;
+		gpio-controller;
+		port-id = <0>;
+		girq-id = <11>;
+		#gpio-cells=<2>;
+	};
+	gpio_040_076: gpio@40081080 {
+		compatible = "microchip,xec-gpio-v2";
+		reg = < 0x40081080 0x80 0x40081304 0x04
+			0x40081384 0x04 0x400813f8 0x4>;
+		interrupts = <2 2>;
+		gpio-controller;
+		port-id = <1>;
+		girq-id = <10>;
+		#gpio-cells=<2>;
+	};
+	gpio_100_136: gpio@40081100 {
+		compatible = "microchip,xec-gpio-v2";
+		reg = < 0x40081100 0x80 0x40081308 0x04
+			0x40081388 0x04 0x400813f4 0x04>;
+		gpio-controller;
+		interrupts = <1 2>;
+		port-id = <2>;
+		girq-id = <9>;
+		#gpio-cells=<2>;
+	};
+	gpio_140_176: gpio@40081180 {
+		compatible = "microchip,xec-gpio-v2";
+		reg = < 0x40081180 0x80 0x4008130c 0x04
+			0x4008138c 0x04 0x400813f0 0x04>;
+		gpio-controller;
+		interrupts = <0 2>;
+		port-id = <3>;
+		girq-id = <8>;
+		#gpio-cells=<2>;
+	};
+	gpio_200_236: gpio@40081200 {
+		compatible = "microchip,xec-gpio-v2";
+		reg = < 0x40081200 0x80 0x40081310 0x04
+			0x40081390 0x04 0x400813ec 0x04>;
+		gpio-controller;
+		interrupts = <4 2>;
+		port-id = <4>;
+		girq-id = <12>;
+		#gpio-cells=<2>;
+	};
+	gpio_240_276: gpio@40081280 {
+		compatible = "microchip,xec-gpio-v2";
+		reg = < 0x40081280 0x80 0x40081314 0x04
+			0x40081394 0x04 0x400813e8 0x04>;
+		gpio-controller;
+		interrupts = <17 2>;
+		port-id = <5>;
+		girq-id = <26>;
+		#gpio-cells=<2>;
+	};
+};
+wdog: watchdog@40000400 {
+	compatible = "microchip,xec-watchdog";
+	reg = <0x40000400 0x400>;
+	interrupts = <171 0>;
+	girqs = <21 2>;
+	pcrs = <1 9>;
+};
+rtimer: timer@40007400 {
+	compatible = "microchip,xec-rtos-timer";
+	reg = <0x40007400 0x10>;
+	interrupts = <111 0>;
+	girqs = <23 10>;
+};
+timer0: timer@40000c00 {
+	compatible = "microchip,xec-timer";
+	clock-frequency = <48000000>;
+	reg = <0x40000c00 0x20>;
+	interrupts = <136 0>;
+	girqs = <23 0>;
+	pcrs = <1 30>;
+	max-value = <0xFFFF>;
+	prescaler = <0>;
+	status = "disabled";
+};
+timer1: timer@40000c20 {
+	compatible = "microchip,xec-timer";
+	clock-frequency = <48000000>;
+	reg = <0x40000c20 0x20>;
+	interrupts = <137 0>;
+	girqs = <23 1>;
+	pcrs = <1 31>;
+	max-value = <0xFFFF>;
+	prescaler = <0>;
+	status = "disabled";
+};
+timer2: timer@40000c40 {
+	compatible = "microchip,xec-timer";
+	clock-frequency = <48000000>;
+	reg = <0x40000c40 0x20>;
+	interrupts = <138 0>;
+	girqs = <23 2>;
+	pcrs = <3 21>;
+	max-value = <0xFFFF>;
+	prescaler = <0>;
+	status = "disabled";
+};
+timer3: timer@40000c60 {
+	compatible = "microchip,xec-timer";
+	clock-frequency = <48000000>;
+	reg = <0x40000c60 0x20>;
+	interrupts = <139 0>;
+	girqs = <23 3>;
+	pcrs = <3 22>;
+	max-value = <0xFFFF>;
+	prescaler = <0>;
+	status = "disabled";
+};
+/*
+ * NOTE: When RTOS timer used as kernel timer, timer4 used
+ * to provide high speed busy wait counter. Keep disabled to
+ * prevent counter driver from claiming it.
+ */
+timer4: timer@40000c80 {
+	compatible = "microchip,xec-timer";
+	clock-frequency = <48000000>;
+	reg = <0x40000c80 0x20>;
+	interrupts = <140 0>;
+	girqs = <23 4>;
+	pcrs = <3 23>;
+	max-value = <0xFFFFFFFF>;
+	prescaler = <0>;
+	status = "disabled";
+};
+timer5: timer@40000ca0 {
+	compatible = "microchip,xec-timer";
+	clock-frequency = <48000000>;
+	reg = <0x40000ca0 0x20>;
+	interrupts = <141 0>;
+	girqs = <23 5>;
+	pcrs = <3 24>;
+	max-value = <0xFFFFFFFF>;
+	prescaler = <0>;
+	status = "disabled";
+};
+cntr0: timer@40000d00 {
+	reg = <0x40000d00 0x20>;
+	interrupts = <142 0>;
+	girqs = <23 6>;
+	pcrs = <4 2>;
+	status = "disabled";
+};
+cntr1: timer@40000d20 {
+	reg = <0x40000d20 0x20>;
+	interrupts = <143 0>;
+	girqs = <23 7>;
+	pcrs = <4 3>;
+	status = "disabled";
+};
+cntr2: timer@40000d40 {
+	reg = <0x40000d40 0x20>;
+	interrupts = <144 0>;
+	girqs = <23 8>;
+	pcrs = <4 3>;
+	status = "disabled";
+};
+cntr3: timer@40000d60 {
+	reg = <0x40000d60 0x20>;
+	interrupts = <145 0>;
+	girqs = <23 9>;
+	pcrs = <4 4>;
+	status = "disabled";
+};
+cctmr0: timer@40001000 {
+	reg = <0x40001000 0x40>;
+	interrupts = <146 0>, <147 0>, <148 0>, <149 0>,
+		     <150 0>, <151 0>, <152 0>, <153 0>,
+		     <154 0>;
+	girqs = <18 20>, <18 21>, <18 22>, <18 23>, <18 24>,
+		<18 25>, <18 26>, <18 27>, <18 28>;
+	pcrs = <3 30>;
+	status = "disabled";
+};
+hibtimer0: timer@40009800 {
+	reg = <0x40009800 0x20>;
+	interrupts = <112 0>;
+	girqs = <23 16>;
+};
+hibtimer1: timer@40009820 {
+	reg = <0x40009820 0x20>;
+	interrupts = <113 0>;
+	girqs = <23 17>;
+};
+weektmr0: timer@4000ac80 {
+	reg = <0x4000ac80 0x80>;
+	interrupts = <114 0>, <115 0>, <116 0>,
+		     <117 0>, <118 0>;
+	girqs = <21 3>, <21 4>, <21 5>, <21 6>, <21 7>;
+	status = "disabled";
+};
+bbram: bb-ram@4000a800 {
+	compatible = "microchip,xec-bbram";
+	reg = <0x4000a800 0x100>;
+	reg-names = "memory";
+};
+vci0: vci@4000ae00 {
+	reg = <0x4000ae00 0x40>;
+	interrupts = <121 0>, <122 0>, <123 0>,
+		     <124 0>, <125 0>;
+	girqs = <21 10>, <21 11>, <21 12>, <21 13>, <21 14>;
+	status = "disabled";
+};
+dmac: dmac@40002400 {
+	compatible = "microchip,xec-dmac";
+	reg = <0x40002400 0xc00>;
+	interrupts = <24 1>, <25 1>, <26 1>, <27 1>,
+		     <28 1>, <29 1>, <30 1>, <31 1>,
+		     <32 1>, <33 1>, <34 1>, <35 1>,
+		     <36 1>, <37 1>, <38 1>, <39 1>;
+	girqs = < MCHP_XEC_ECIA(14, 0, 6, 24)
+		  MCHP_XEC_ECIA(14, 1, 6, 25)
+		  MCHP_XEC_ECIA(14, 2, 6, 26)
+		  MCHP_XEC_ECIA(14, 3, 6, 27)
+		  MCHP_XEC_ECIA(14, 4, 6, 28)
+		  MCHP_XEC_ECIA(14, 5, 6, 29)
+		  MCHP_XEC_ECIA(14, 6, 6, 30)
+		  MCHP_XEC_ECIA(14, 7, 6, 31)
+		  MCHP_XEC_ECIA(14, 8, 6, 32)
+		  MCHP_XEC_ECIA(14, 9, 6, 33)
+		  MCHP_XEC_ECIA(14, 10, 6, 34)
+		  MCHP_XEC_ECIA(14, 11, 6, 35)
+		  MCHP_XEC_ECIA(14, 12, 6, 36)
+		  MCHP_XEC_ECIA(14, 13, 6, 37)
+		  MCHP_XEC_ECIA(14, 14, 6, 38)
+		  MCHP_XEC_ECIA(14, 15, 6, 39) >;
+	pcrs = <1 6>;
+	#dma-cells = <2>;
+	dma-channels = <16>;
+	dma-requests = <16>;
+	status = "disabled";
+};
+i2c_smb_0: i2c@40004000 {
+	compatible = "microchip,xec-i2c-v2";
+	reg = <0x40004000 0x80>;
+	clock-frequency = <I2C_BITRATE_STANDARD>;
+	interrupts = <20 1>;
+	girqs = <13 0>;
+	pcrs = <1 10>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+i2c_smb_1: i2c@40004400 {
+	compatible = "microchip,xec-i2c-v2";
+	reg = <0x40004400 0x80>;
+	clock-frequency = <I2C_BITRATE_STANDARD>;
+	interrupts = <21 1>;
+	girqs = <13 1>;
+	pcrs = <3 13>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+i2c_smb_2: i2c@40004800 {
+	compatible = "microchip,xec-i2c-v2";
+	reg = <0x40004800 0x80>;
+	clock-frequency = <I2C_BITRATE_STANDARD>;
+	interrupts = <22 1>;
+	girqs = <13 2>;
+	pcrs = <3 14>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+i2c_smb_3: i2c@40004c00 {
+	compatible = "microchip,xec-i2c-v2";
+	reg = <0x40004C00 0x80>;
+	clock-frequency = <I2C_BITRATE_STANDARD>;
+	interrupts = <23 1>;
+	girqs = <13 3>;
+	pcrs = <3 15>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+i2c_smb_4: i2c@40005000 {
+	compatible = "microchip,xec-i2c-v2";
+	reg = <0x40005000 0x80>;
+	clock-frequency = <I2C_BITRATE_STANDARD>;
+	interrupts = <158 1>;
+	girqs = <13 4>;
+	pcrs = <3 20>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+ps2_0: ps2@40009000 {
+	compatible = "microchip,xec-ps2";
+	reg = <0x40009000 0x40>;
+	interrupts = <100 1>;
+	girqs = <18 10>, <21 18>;
+	pcrs = <3 5>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+pwm0: pwm@40005800 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005800 0x20>;
+	pcrs = <1 4>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm1: pwm@40005810 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005810 0x20>;
+	pcrs = <1 20>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm2: pwm@40005820 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005820 0x20>;
+	pcrs = <1 21>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm3: pwm@40005830 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005830 0x20>;
+	pcrs = <1 22>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm4: pwm@40005840 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005840 0x20>;
+	pcrs = <1 23>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm5: pwm@40005850 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005850 0x20>;
+	pcrs = <1 24>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm6: pwm@40005860 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005860 0x20>;
+	pcrs = <1 25>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm7: pwm@40005870 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005870 0x20>;
+	pcrs = <1 26>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+pwm8: pwm@40005880 {
+	compatible = "microchip,xec-pwm";
+	reg = <0x40005880 0x20>;
+	pcrs = <1 27>;
+	status = "disabled";
+	#pwm-cells = <3>;
+};
+tach0: tach@40006000 {
+	compatible = "microchip,xec-tach";
+	reg = <0x40006000 0x10>;
+	interrupts = <71 4>;
+	girqs = <17 1>;
+	pcrs = <1 2>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+tach1: tach@40006010 {
+	compatible = "microchip,xec-tach";
+	reg = <0x40006010 0x10>;
+	interrupts = <72 4>;
+	girqs = <17 2>;
+	pcrs = <1 11>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+tach2: tach@40006020 {
+	compatible = "microchip,xec-tach";
+	reg = <0x40006020 0x10>;
+	interrupts = <73 4>;
+	girqs = <17 3>;
+	pcrs = <1 12>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+tach3: tach@40006030 {
+	compatible = "microchip,xec-tach";
+	reg = <0x40006030 0x10>;
+	interrupts = <159 4>;
+	girqs = <17 4>;
+	pcrs = <1 13>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+rpmfan0: rpmfan@4000a000 {
+	reg = <0x4000a000 0x80>;
+	interrupts = <74 1>, <75 1>;
+	girqs = <17 20>, <17 21>;
+	pcrs = <3 12>;
+	status = "disabled";
+};
+rpmfan1: rpmfan@4000a080 {
+	reg = <0x4000a080 0x80>;
+	interrupts = <76 1>, <77 1>;
+	girqs = <17 22>, <17 23>;
+	pcrs = <4 7>;
+	status = "disabled";
+};
+adc0: adc@40007c00 {
+	compatible = "microchip,xec-adc";
+	reg = <0x40007c00 0x90>;
+	interrupts = <78 0>, <79 0>;
+	girqs = <17 8>, <17 9>;
+	pcrs = <3 3>;
+	status = "disabled";
+	#io-channel-cells = <1>;
+	clktime = <32>;
+};
+kscan0: kscan@40009c00 {
+	compatible = "microchip,xec-kscan";
+	reg = <0x40009c00 0x18>;
+	interrupts = <135 0>;
+	girqs = <21 25>;
+	pcrs = <3 11>;
+	status = "disabled";
+	#address-cells = <1>;
+	#size-cells = <0>;
+};
+peci0: peci@40006400 {
+	compatible = "microchip,xec-peci";
+	reg = <0x40006400 0x80>;
+	interrupts = <70 4>;
+	girqs = <17 0>;
+	pcrs = <1 1>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+};
+spi0: spi@40070000 {
+	reg = <0x40070000 0x400>;
+	interrupts = <91 2>;
+	girqs = < MCHP_XEC_ECIA(18, 1, 10, 91) >;
+	clocks = <&pcr 4 8 MCHP_XEC_PCR_CLK_PERIPH>;
+	clock-frequency = <12000000>;
+	lines = <1>;
+	chip-select = <0>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+spi1: spi@40009400 {
+	reg = <0x40009400 0x80>;
+	interrupts = <92 2>, <93 2>;
+	girqs = <18 2>, <18 3>;
+	pcrs = <3 9>;
+	status = "disabled";
+};
+spi2: spi@40009480 {
+	reg = <0x40009480 0x80>;
+	interrupts = <94 2>, <95 2>;
+	girqs = <18 4>, <18 5>;
+	pcrs = <4 22>;
+	status = "disabled";
+};
+prochot0: prochot@40003400 {
+	reg = <0x40003400 0x20>;
+	interrupts = <87 0>;
+	girqs = <17 17>;
+	pcrs = <4 13>;
+	status = "disabled";
+};
+rcid0: rcid@40001400 {
+	reg = <0x40001400 0x80>;
+	interrupts = <80 0>;
+	girqs = <17 10>;
+	pcrs = <4 10>;
+	status = "disabled";
+};
+rcid1: rcid@40001480 {
+	reg = <0x40001480 0x80>;
+	interrupts = <81 0>;
+	girqs = <17 11>;
+	pcrs = <4 11>;
+	status = "disabled";
+};
+rcid2: rcid@40001500 {
+	reg = <0x40001500 0x80>;
+	interrupts = <82 0>;
+	girqs = <17 12>;
+	pcrs = <4 12>;
+	status = "disabled";
+};
+spip0: spip@40007000 {
+	reg = <0x40007000 0x100>;
+	interrupts = <90 0>;
+	girqs = <18 0>;
+	pcrs = <4 16>;
+	status = "disabled";
+};
+bbled0: bbled@4000b800 {
+	reg = <0x4000b800 0x100>;
+	interrupts = <83 0>;
+	girqs = <17 13>;
+	pcrs = <3 16>;
+	status = "disabled";
+};
+bbled1: bbled@4000b900 {
+	reg = <0x4000b900 0x100>;
+	interrupts = <84 0>;
+	girqs = <17 14>;
+	pcrs = <3 17>;
+	status = "disabled";
+};
+bbled2: bbled@4000ba00 {
+	reg = <0x4000ba00 0x100>;
+	interrupts = <85 0>;
+	girqs = <17 15>;
+	pcrs = <3 18>;
+	status = "disabled";
+};
+bbled3: bbled@4000bb00 {
+	reg = <0x4000bb00 0x100>;
+	interrupts = <86 0>;
+	girqs = <17 16>;
+	pcrs = <3 25>;
+	status = "disabled";
+};
+bclink0: bclink@4000cd00 {
+	reg = <0x4000cd00 0x20>;
+	interrupts = <96 0>, <97 0>;
+	girqs = <18 7>, <18 6>;
+	pcrs = <3 19>;
+	status = "disabled";
+};
+tfdp0: tfdp@40008c00 {
+	reg = <0x40008c00 0x10>;
+	pcrs = <1 7>;
+	status = "disabled";
+};
+glblcfg0: glblcfg@400fff00 {
+	reg = <0x400fff00 0x40>;
+	pcrs = <2 12>;
+	status = "disabled";
+};
+uart0: uart@400f2400 {
+	compatible = "microchip,xec-uart";
+	reg = <0x400f2400 0x400>;
+	interrupts = <40 1>;
+	clock-frequency = <1843200>;
+	current-speed = <38400>;
+	girqs = <15 0>;
+	pcrs = <2 1>;
+	ldn = <9>;
+	status = "disabled";
+};
+uart1: uart@400f2800 {
+	compatible = "microchip,xec-uart";
+	reg = <0x400f2800 0x400>;
+	interrupts = <41 1>;
+	clock-frequency = <1843200>;
+	current-speed = <38400>;
+	girqs = <15 1>;
+	pcrs = <2 2>;
+	ldn = <10>;
+	status = "disabled";
+};
+espi0: espi@400f3400 {
+	compatible = "microchip,xec-espi-v2";
+	/* reg tuple contains one 32-bit address cell and one
+	 * 32-bit length(size) cell.
+	 */
+	#address-cells = <1>;
+	#size-cells = <1>;
+	reg = < 0x400f3400 0x400
+		0x400f3800 0x400
+		0x400f9c00 0x400>;
+	reg-names = "io", "mem", "vw";
+	interrupts = <103 3>, <104 3>, <105 3>, <106 3>,
+		     <107 3>, <108 3>, <109 3>, <110 2>,
+		     <156 3>;
+	interrupt-names = "pc", "bm1", "bm2", "ltr", "oob_up",
+			  "oob_dn", "fc", "rst", "vw_chan_en";
+	girqs = < MCHP_XEC_ECIA(19, 0, 11, 103)
+		  MCHP_XEC_ECIA(19, 1, 11, 104)
+		  MCHP_XEC_ECIA(19, 2, 11, 105)
+		  MCHP_XEC_ECIA(19, 3, 11, 106)
+		  MCHP_XEC_ECIA(19, 4, 11, 107)
+		  MCHP_XEC_ECIA(19, 5, 11, 108)
+		  MCHP_XEC_ECIA(19, 6, 11, 109)
+		  MCHP_XEC_ECIA(19, 7, 11, 110)
+		  MCHP_XEC_ECIA(19, 8, 11, 156) >;
+	pcrs = <2 19>;
+	status = "disabled";
+
+	espi_saf0: espi_saf@40008000 {
+		compatible = "microchip,xec-espi-saf-v2";
+		reg = <0x40008000 0x400>, <0x40070000 0x400>,
+		      <0x40071000 0x400>;
+		reg-names = "safbr", "safqspi", "safcomm";
+		interrupts = <166 3>, <167 3>;
+		interrupt-names = "done", "err";
+		girqs = < MCHP_XEC_ECIA(19, 9, 11, 166) >,
+			< MCHP_XEC_ECIA(19, 10, 11, 167) >;
+		pcrs = <2 27>;
+		status = "disabled";
+	};
+
+	mbox0: mbox@400f0000 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f0000 0x200>;
+		interrupts = <60 3>;
+		girqs = < MCHP_XEC_ECIA(15, 20, 7, 60) >;
+		pcrs = <2 17>;
+		ldn = <0>;
+		status = "disabled";
+	};
+	kbc0: kbc@400f0400 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f0400 0x400>;
+		interrupts = <58 3>, <59 3>;
+		interrupt-names = "kbc_obe", "kbc_ibf";
+		girqs = < MCHP_XEC_ECIA(15, 18, 7, 58)
+			  MCHP_XEC_ECIA(15, 19, 7, 59) >;
+		ldn = <1>;
+		status = "disabled";
+	};
+	acpi_ec0: acpi_ec@400f0800 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f0800 0x400>;
+		interrupts = <45 3>, <46 3>;
+		interrupt-names = "acpi_ibf", "acpi_obe";
+		girqs = < MCHP_XEC_ECIA(15, 5, 7, 45)
+			  MCHP_XEC_ECIA(15, 6, 7, 46) >;
+		ldn = <2>;
+		status = "disabled";
+	};
+	acpi_ec1: acpi_ec@400f0c00 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f0c00 0x400>;
+		interrupts = <47 3>, <48 3>;
+		interrupt-names = "acpi_ibf", "acpi_obe";
+		girqs = < MCHP_XEC_ECIA(15, 7, 7, 47)
+			  MCHP_XEC_ECIA(15, 8, 7, 48) >;
+		ldn = <3>;
+		status = "disabled";
+	};
+	acpi_ec2: acpi_ec@400f1000 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f1000 0x400>;
+		interrupts = <49 3>, <50 3>;
+		interrupt-names = "acpi_ibf", "acpi_obe";
+		girqs = < MCHP_XEC_ECIA(15, 9, 7, 49)
+			  MCHP_XEC_ECIA(15, 10, 7, 50) >;
+		ldn = <4>;
+		status = "disabled";
+	};
+	acpi_ec3: acpi_ec@400f1400 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f1400 0x400>;
+		interrupts = <51 3>, <52 3>;
+		interrupt-names = "acpi_ibf", "acpi_obe";
+		girqs = < MCHP_XEC_ECIA(15, 11, 7, 51)
+			  MCHP_XEC_ECIA(15, 12, 7, 52) >;
+		ldn = <5>;
+		status = "disabled";
+	};
+	acpi_ec4: acpi_ec@400f1800 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f1800 0x400>;
+		interrupts = <53 3>, <54 3>;
+		interrupt-names = "acpi_ibf", "acpi_obe";
+		girqs = < MCHP_XEC_ECIA(15, 13, 7, 53)
+			  MCHP_XEC_ECIA(15, 14, 7, 54) >;
+		ldn = <6>;
+		status = "disabled";
+	};
+	acpi_pm1: acpi_pm1@400f1c00 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f1c00 0x400>;
+		interrupts = <55 3>, <56 3>, <57 3>;
+		interrupt-names = "pm1_ctl", "pm1_en", "pm1_sts";
+		girqs = < MCHP_XEC_ECIA(15, 15, 7, 55)
+			  MCHP_XEC_ECIA(15, 16, 7, 56)
+			  MCHP_XEC_ECIA(15, 17, 7, 57) >;
+		ldn = <7>;
+		status = "disabled";
+	};
+	port92: port92@400f2000 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f2000 0x400>;
+		ldn = <8>;
+		status = "disabled";
+	};
+	emi0: emi@400f4000 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f4000 0x400>;
+		interrupts = <42 3>;
+		girqs = < MCHP_XEC_ECIA(15, 2, 7, 42) >;
+		ldn = <16>;
+		status = "disabled";
+	};
+	emi1: emi@400f4400 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f4400 0x400>;
+		interrupts = <43 3>;
+		girqs = < MCHP_XEC_ECIA(15, 3, 7, 43) >;
+		ldn = <17>;
+		status = "disabled";
+	};
+	emi2: emi@400f4800 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f4800 0x400>;
+		interrupts = <44 3>;
+		girqs = < MCHP_XEC_ECIA(15, 4, 7, 44) >;
+		ldn = <18>;
+		status = "disabled";
+	};
+	rtc0: rtc@400f5000 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f5000 0x100>;
+		interrupts = <119 3>, <120 3>;
+		girqs = < MCHP_XEC_ECIA(21, 8, 13, 119)
+			  MCHP_XEC_ECIA(21, 9, 13, 120) >;
+		pcrs = <2 18>;
+		ldn = <20>;
+		status = "disabled";
+	};
+	/* Capture writes to host I/O 0x80 - 0x83 */
+	p80bd0: p80bd@400f8000 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f8000 0x400>;
+		interrupts = <62 0>;
+		girqs = < MCHP_XEC_ECIA(15, 22, 7, 62) >;
+		pcrs = <2 25>;
+		ldn = <32>;
+		status = "disabled";
+	};
+	/* Capture writes to an 8-bit I/O and map to one of 0x80 to 0x83 */
+	p80bd0_alias: p80bd@400f8400 {
+		compatible = "microchip,xec-espi-host-dev";
+		reg = <0x400f8400 0x400>;
+		ldn = <33>;
+		host-io = <0x90>;
+		/* map 0x90 to 0x80 */
+		host-io-addr-mask = <0x01>;
+		status = "disabled";
+	};
+};
+
+symcr: symcr@40100000 {
+	compatible = "microchip,xec-symcr";
+	reg = <0x40100000 0x1000>;
+	interrupts = <68 1>;
+	clocks = <&pcr 3 26 MCHP_XEC_PCR_CLK_PERIPH>;
+	girqs = <16 3>;
+	status = "disabled";
+	#address-cells = <1>;
+	#size-cells = <1>;
+};
+
+rom_api: rom_api@1f000 {
+	reg = <0x1f000 0x1000>;
+	status = "disabled";
+};
diff --git a/dts/arm/microchip/mec172xnlj.dtsi b/dts/arm/microchip/mec172xnlj.dtsi
index 968c1e95c3..00d27b422c 100644
--- a/dts/arm/microchip/mec172xnlj.dtsi
+++ b/dts/arm/microchip/mec172xnlj.dtsi
@@ -4,11 +4,68 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-#include "mec172xnsz.dtsi"
+#include <arm/armv7-m.dtsi>
+
+#include <zephyr/dt-bindings/adc/adc.h>
+#include <zephyr/dt-bindings/clock/mchp_xec_pcr.h>
+#include <zephyr/dt-bindings/gpio/gpio.h>
+#include <zephyr/dt-bindings/gpio/microchip-xec-gpio.h>
+#include <zephyr/dt-bindings/i2c/i2c.h>
+#include <zephyr/dt-bindings/interrupt-controller/mchp-xec-ecia.h>
+#include <freq.h>
+#include <mem.h>
+
+#include "mec172x/mec172x-vw-routing.dtsi"
 
 / {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-m4";
+			reg = <0>;
+			cpu-power-states = <&idle &suspend_to_ram>;
+		};
+
+		power-states {
+			idle: idle {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-idle";
+				min-residency-us = <1000000>;
+			};
+
+			suspend_to_ram: suspend_to_ram {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-ram";
+				min-residency-us = <2000000>;
+			};
+		};
+	};
+
+	flash0: flash@c0000 {
+		reg = <0x000C0000 0x58000>;
+	};
+
+	sram0: memory@118000 {
+		compatible = "mmio-sram";
+		reg = <0x00118000 0x10000>;
+	};
 
 	soc {
+		#include "mec172x_common.dtsi"
+
+		eeprom: eeprom@40002c00 {
+			compatible = "microchip,xec-eeprom";
+			reg = <0x40002c00 0x400>;
+			interrupts = <155 2>;
+			size = <8192>;
+			girqs = <18 13>;
+			pcrs = <4 14>;
+			status = "disabled";
+		};
+
 		pwm9: pwm@40005890 {
 			compatible = "microchip,xec-pwm";
 			reg = <0x40005890 0x20>;
@@ -32,6 +89,14 @@
 			status = "disabled";
 			#pwm-cells = <3>;
 		};
+
 	};
 };
 
+&nvic {
+	arm,num-irq-priority-bits = <3>;
+};
+
+&systick {
+	status = "disabled";
+};
diff --git a/dts/arm/microchip/mec172xnsz.dtsi b/dts/arm/microchip/mec172xnsz.dtsi
index ca65168b8d..2e14106a6e 100644
--- a/dts/arm/microchip/mec172xnsz.dtsi
+++ b/dts/arm/microchip/mec172xnsz.dtsi
@@ -39,464 +39,8 @@
 	};
 
 	soc {
-		ecs: ecs@4000fc00 {
-			reg = <0x4000fc00 0x200>;
-		};
-		pcr: pcr@40080100 {
-			compatible = "microchip,xec-pcr";
-			reg = <0x40080100 0x100 0x4000a400 0x100>;
-			reg-names = "pcrr", "vbatr";
-			interrupts = <174 0>;
-			core-clock-div = <1>;
-			/* MEC172x allows sources to be different */
-			pll-32k-src = <MCHP_XEC_PLL_CLK32K_SRC_SIL_OSC>;
-			periph-32k-src = <MCHP_XEC_PERIPH_CLK32K_SRC_SO_SO>;
-			clk32kmon-period-min = <1435>;
-			clk32kmon-period-max = <1495>;
-			clk32kmon-duty-cycle-var-max = <132>;
-			clk32kmon-valid-min = <4>;
-			xtal-enable-delay-ms = <300>;
-			pll-lock-timeout-ms = <30>;
-			/* pin configured only if one of the sources is set to PIN */
-			pinctrl-0 = <&clk_32khz_in_gpio165>;
-			pinctrl-names = "default";
-			#clock-cells = <3>;
-		};
-		ecia: ecia@4000e000 {
-			compatible = "microchip,xec-ecia";
-			reg = <0x4000e000 0x400>;
-			direct-capable-girqs = <13 14 15 16 17 18 19 20 21 23>;
-			clocks = <&pcr 1 0 MCHP_XEC_PCR_CLK_PERIPH>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			ranges = <0x0 0x4000e000 0x400>;
-
-			girq8: girq8@0 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x0 0x14>;
-				interrupts = <0 0>;
-				girq-id = <0>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15
-					   16 17 18 21 22 24 25
-					   26 27 28 29>;
-				status = "disabled";
-			};
-			girq9: girq9@14 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x14 0x14>;
-				interrupts = <1 0>;
-				girq-id = <1>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15
-					   16 17 18 19 20 21 22 23
-					   24 25 26 27 28 29>;
-				status = "disabled";
-			};
-			girq10: girq10@28 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x28 0x14>;
-				interrupts = <2 0>;
-				girq-id = <2>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15
-					   16 17 18 19 20 21 22 23
-					   24 25 26 27 28 29 30>;
-				status = "disabled";
-			};
-			girq11: girq11@3c {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x3c 0x14>;
-				interrupts = <3 0>;
-				girq-id = <3>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15
-					   16 17 18 19 20 21 22 23
-					   24 25 26 27 28 29 30>;
-				status = "disabled";
-			};
-			girq12: girq12@50 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x50 0x14>;
-				interrupts = <4 0>;
-				girq-id = <4>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15
-					   16 17 18 19 20 21 22 23
-					   24 25 26 27 28 29 30>;
-				status = "disabled";
-			};
-			girq13: girq13@64 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x64 0x14>;
-				interrupts = <5 0>;
-				girq-id = <5>;
-				sources = <0 1 2 3 4>;
-				status = "disabled";
-			};
-			girq14: girq14@78 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x78 0x14>;
-				interrupts = <6 0>;
-				girq-id = <6>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15>;
-				status = "disabled";
-			};
-			girq15: girq15@8c {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x8c 0x14>;
-				interrupts = <7 0>;
-				girq-id = <7>;
-				sources = <0 1 2 3 4 5 6 7
-					   8 9 10 11 12 13 14 15
-					   16 17 18 19 20 22>;
-				status = "disabled";
-			};
-			girq16: girq16@a0 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0xa0 0x14>;
-				interrupts = <8 0>;
-				girq-id = <8>;
-				sources = <0 2 3>;
-				status = "disabled";
-			};
-			girq17: girq17@b4 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0xb4 0x14>;
-				interrupts = <9 0>;
-				girq-id = <9>;
-				sources = <0 1 2 3 4 8 9 10 11 12 13 14 15
-					   16 17 20 21 22 23>;
-				status = "disabled";
-			};
-			girq18: girq18@c8 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0xc8 0x14>;
-				interrupts = <10 0>;
-				girq-id = <10>;
-				sources = <0 1 2 3 4 5 6 7
-					   10 20 21 22 23
-					   24 25 26 27 28>;
-				status = "disabled";
-			};
-			girq19: girq19@dc {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0xdc 0x14>;
-				interrupts = <11 0>;
-				girq-id = <11>;
-				sources = <0 1 2 3 4 5 6 7 8 9 10>;
-				status = "disabled";
-			};
-			girq20: girq20@f0 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0xf0 0x14>;
-				interrupts = <12 0>;
-				girq-id = <12>;
-				sources = <3 9>;
-				status = "disabled";
-			};
-			girq21: girq21@104 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x104 0x14>;
-				interrupts = <13 0>;
-				girq-id = <13>;
-				sources = <2 3 4 5 6 7 8 9 10 11 12 13 14 15
-					   18 19 25 26>;
-				status = "disabled";
-			};
-			girq22: girq22@118 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x118 0x14>;
-				interrupts = <255 0>;
-				girq-id = <14>;
-				sources = <0 1 2 3 4 5 9 15>;
-				status = "disabled";
-			};
-			girq23: girq23@12c {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x12c 0x14>;
-				interrupts = <14 0>;
-				girq-id = <15>;
-				sources = <0 1 2 3 4 5 6 7 8 9 10 16 17>;
-				status = "disabled";
-			};
-			girq24: girq24@140 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x140 0x14>;
-				interrupts = <15 0>;
-				girq-id = <16>;
-				sources = <0 1 2 3 4 5 6 7 8 9 10 11
-					   12 13 14 15 16 17 18 19
-					   20 21 22 23 24 25 26 27>;
-				status = "disabled";
-			};
-			girq25: girq25@154 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x154 0x14>;
-				interrupts = <16 0>;
-				girq-id = <17>;
-				sources = <0 1 2 3 4 5 6 7 8 9 10 11
-					   12 13 14 15>;
-				status = "disabled";
-			};
-			girq26: girq26@168 {
-				compatible = "microchip,xec-ecia-girq";
-				reg = <0x168 0x14>;
-				interrupts = <17 0>;
-				girq-id = <18>;
-				sources = <0 1 2 3 4 5 6 12 13>;
-				status = "disabled";
-			};
-		};
-		pinctrl: pin-controller@40081000 {
-			compatible = "microchip,xec-pinctrl";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			reg = <0x40081000 0x1000>;
+		#include "mec172x_common.dtsi"
 
-			gpio_000_036: gpio@40081000 {
-				compatible = "microchip,xec-gpio-v2";
-				reg = < 0x40081000 0x80 0x40081300 0x04
-					0x40081380 0x04 0x400813fc 0x04>;
-				interrupts = <3 2>;
-				gpio-controller;
-				port-id = <0>;
-				girq-id = <11>;
-				#gpio-cells=<2>;
-			};
-			gpio_040_076: gpio@40081080 {
-				compatible = "microchip,xec-gpio-v2";
-				reg = < 0x40081080 0x80 0x40081304 0x04
-					0x40081384 0x04 0x400813f8 0x4>;
-				interrupts = <2 2>;
-				gpio-controller;
-				port-id = <1>;
-				girq-id = <10>;
-				#gpio-cells=<2>;
-			};
-			gpio_100_136: gpio@40081100 {
-				compatible = "microchip,xec-gpio-v2";
-				reg = < 0x40081100 0x80 0x40081308 0x04
-					0x40081388 0x04 0x400813f4 0x04>;
-				gpio-controller;
-				interrupts = <1 2>;
-				port-id = <2>;
-				girq-id = <9>;
-				#gpio-cells=<2>;
-			};
-			gpio_140_176: gpio@40081180 {
-				compatible = "microchip,xec-gpio-v2";
-				reg = < 0x40081180 0x80 0x4008130c 0x04
-					0x4008138c 0x04 0x400813f0 0x04>;
-				gpio-controller;
-				interrupts = <0 2>;
-				port-id = <3>;
-				girq-id = <8>;
-				#gpio-cells=<2>;
-			};
-			gpio_200_236: gpio@40081200 {
-				compatible = "microchip,xec-gpio-v2";
-				reg = < 0x40081200 0x80 0x40081310 0x04
-					0x40081390 0x04 0x400813ec 0x04>;
-				gpio-controller;
-				interrupts = <4 2>;
-				port-id = <4>;
-				girq-id = <12>;
-				#gpio-cells=<2>;
-			};
-			gpio_240_276: gpio@40081280 {
-				compatible = "microchip,xec-gpio-v2";
-				reg = < 0x40081280 0x80 0x40081314 0x04
-					0x40081394 0x04 0x400813e8 0x04>;
-				gpio-controller;
-				interrupts = <17 2>;
-				port-id = <5>;
-				girq-id = <26>;
-				#gpio-cells=<2>;
-			};
-		};
-		wdog: watchdog@40000400 {
-			compatible = "microchip,xec-watchdog";
-			reg = <0x40000400 0x400>;
-			interrupts = <171 0>;
-			girqs = <21 2>;
-			pcrs = <1 9>;
-		};
-		rtimer: timer@40007400 {
-			compatible = "microchip,xec-rtos-timer";
-			reg = <0x40007400 0x10>;
-			interrupts = <111 0>;
-			girqs = <23 10>;
-		};
-		timer0: timer@40000c00 {
-			compatible = "microchip,xec-timer";
-			clock-frequency = <48000000>;
-			reg = <0x40000c00 0x20>;
-			interrupts = <136 0>;
-			girqs = <23 0>;
-			pcrs = <1 30>;
-			max-value = <0xFFFF>;
-			prescaler = <0>;
-			status = "disabled";
-		};
-		timer1: timer@40000c20 {
-			compatible = "microchip,xec-timer";
-			clock-frequency = <48000000>;
-			reg = <0x40000c20 0x20>;
-			interrupts = <137 0>;
-			girqs = <23 1>;
-			pcrs = <1 31>;
-			max-value = <0xFFFF>;
-			prescaler = <0>;
-			status = "disabled";
-		};
-		timer2: timer@40000c40 {
-			compatible = "microchip,xec-timer";
-			clock-frequency = <48000000>;
-			reg = <0x40000c40 0x20>;
-			interrupts = <138 0>;
-			girqs = <23 2>;
-			pcrs = <3 21>;
-			max-value = <0xFFFF>;
-			prescaler = <0>;
-			status = "disabled";
-		};
-		timer3: timer@40000c60 {
-			compatible = "microchip,xec-timer";
-			clock-frequency = <48000000>;
-			reg = <0x40000c60 0x20>;
-			interrupts = <139 0>;
-			girqs = <23 3>;
-			pcrs = <3 22>;
-			max-value = <0xFFFF>;
-			prescaler = <0>;
-			status = "disabled";
-		};
-		/*
-		 * NOTE: When RTOS timer used as kernel timer, timer4 used
-		 * to provide high speed busy wait counter. Keep disabled to
-		 * prevent counter driver from claiming it.
-		 */
-		timer4: timer@40000c80 {
-			compatible = "microchip,xec-timer";
-			clock-frequency = <48000000>;
-			reg = <0x40000c80 0x20>;
-			interrupts = <140 0>;
-			girqs = <23 4>;
-			pcrs = <3 23>;
-			max-value = <0xFFFFFFFF>;
-			prescaler = <0>;
-			status = "disabled";
-		};
-		timer5: timer@40000ca0 {
-			compatible = "microchip,xec-timer";
-			clock-frequency = <48000000>;
-			reg = <0x40000ca0 0x20>;
-			interrupts = <141 0>;
-			girqs = <23 5>;
-			pcrs = <3 24>;
-			max-value = <0xFFFFFFFF>;
-			prescaler = <0>;
-			status = "disabled";
-		};
-		cntr0: timer@40000d00 {
-			reg = <0x40000d00 0x20>;
-			interrupts = <142 0>;
-			girqs = <23 6>;
-			pcrs = <4 2>;
-			status = "disabled";
-		};
-		cntr1: timer@40000d20 {
-			reg = <0x40000d20 0x20>;
-			interrupts = <143 0>;
-			girqs = <23 7>;
-			pcrs = <4 3>;
-			status = "disabled";
-		};
-		cntr2: timer@40000d40 {
-			reg = <0x40000d40 0x20>;
-			interrupts = <144 0>;
-			girqs = <23 8>;
-			pcrs = <4 3>;
-			status = "disabled";
-		};
-		cntr3: timer@40000d60 {
-			reg = <0x40000d60 0x20>;
-			interrupts = <145 0>;
-			girqs = <23 9>;
-			pcrs = <4 4>;
-			status = "disabled";
-		};
-		cctmr0: timer@40001000 {
-			reg = <0x40001000 0x40>;
-			interrupts = <146 0>, <147 0>, <148 0>, <149 0>,
-				     <150 0>, <151 0>, <152 0>, <153 0>,
-				     <154 0>;
-			girqs = <18 20>, <18 21>, <18 22>, <18 23>, <18 24>,
-				<18 25>, <18 26>, <18 27>, <18 28>;
-			pcrs = <3 30>;
-			status = "disabled";
-		};
-		hibtimer0: timer@40009800 {
-			reg = <0x40009800 0x20>;
-			interrupts = <112 0>;
-			girqs = <23 16>;
-		};
-		hibtimer1: timer@40009820 {
-			reg = <0x40009820 0x20>;
-			interrupts = <113 0>;
-			girqs = <23 17>;
-		};
-		weektmr0: timer@4000ac80 {
-			reg = <0x4000ac80 0x80>;
-			interrupts = <114 0>, <115 0>, <116 0>,
-				     <117 0>, <118 0>;
-			girqs = <21 3>, <21 4>, <21 5>, <21 6>, <21 7>;
-			status = "disabled";
-		};
-		bbram: bb-ram@4000a800 {
-			compatible = "microchip,xec-bbram";
-			reg = <0x4000a800 0x100>;
-			reg-names = "memory";
-		};
-		vci0: vci@4000ae00 {
-			reg = <0x4000ae00 0x40>;
-			interrupts = <121 0>, <122 0>, <123 0>,
-				     <124 0>, <125 0>;
-			girqs = <21 10>, <21 11>, <21 12>, <21 13>, <21 14>;
-			status = "disabled";
-		};
-		dmac: dmac@40002400 {
-			compatible = "microchip,xec-dmac";
-			reg = <0x40002400 0xc00>;
-			interrupts = <24 1>, <25 1>, <26 1>, <27 1>,
-				     <28 1>, <29 1>, <30 1>, <31 1>,
-				     <32 1>, <33 1>, <34 1>, <35 1>,
-				     <36 1>, <37 1>, <38 1>, <39 1>;
-			girqs = < MCHP_XEC_ECIA(14, 0, 6, 24)
-				  MCHP_XEC_ECIA(14, 1, 6, 25)
-				  MCHP_XEC_ECIA(14, 2, 6, 26)
-				  MCHP_XEC_ECIA(14, 3, 6, 27)
-				  MCHP_XEC_ECIA(14, 4, 6, 28)
-				  MCHP_XEC_ECIA(14, 5, 6, 29)
-				  MCHP_XEC_ECIA(14, 6, 6, 30)
-				  MCHP_XEC_ECIA(14, 7, 6, 31)
-				  MCHP_XEC_ECIA(14, 8, 6, 32)
-				  MCHP_XEC_ECIA(14, 9, 6, 33)
-				  MCHP_XEC_ECIA(14, 10, 6, 34)
-				  MCHP_XEC_ECIA(14, 11, 6, 35)
-				  MCHP_XEC_ECIA(14, 12, 6, 36)
-				  MCHP_XEC_ECIA(14, 13, 6, 37)
-				  MCHP_XEC_ECIA(14, 14, 6, 38)
-				  MCHP_XEC_ECIA(14, 15, 6, 39) >;
-			pcrs = <1 6>;
-			#dma-cells = <2>;
-			dma-channels = <16>;
-			dma-requests = <16>;
-			status = "disabled";
-		};
 		eeprom: eeprom@40002c00 {
 			compatible = "microchip,xec-eeprom";
 			reg = <0x40002c00 0x400>;
@@ -506,543 +50,6 @@
 			pcrs = <4 14>;
 			status = "disabled";
 		};
-		i2c_smb_0: i2c@40004000 {
-			compatible = "microchip,xec-i2c-v2";
-			reg = <0x40004000 0x80>;
-			clock-frequency = <I2C_BITRATE_STANDARD>;
-			interrupts = <20 1>;
-			girqs = <13 0>;
-			pcrs = <1 10>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		i2c_smb_1: i2c@40004400 {
-			compatible = "microchip,xec-i2c-v2";
-			reg = <0x40004400 0x80>;
-			clock-frequency = <I2C_BITRATE_STANDARD>;
-			interrupts = <21 1>;
-			girqs = <13 1>;
-			pcrs = <3 13>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		i2c_smb_2: i2c@40004800 {
-			compatible = "microchip,xec-i2c-v2";
-			reg = <0x40004800 0x80>;
-			clock-frequency = <I2C_BITRATE_STANDARD>;
-			interrupts = <22 1>;
-			girqs = <13 2>;
-			pcrs = <3 14>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		i2c_smb_3: i2c@40004c00 {
-			compatible = "microchip,xec-i2c-v2";
-			reg = <0x40004C00 0x80>;
-			clock-frequency = <I2C_BITRATE_STANDARD>;
-			interrupts = <23 1>;
-			girqs = <13 3>;
-			pcrs = <3 15>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		i2c_smb_4: i2c@40005000 {
-			compatible = "microchip,xec-i2c-v2";
-			reg = <0x40005000 0x80>;
-			clock-frequency = <I2C_BITRATE_STANDARD>;
-			interrupts = <158 1>;
-			girqs = <13 4>;
-			pcrs = <3 20>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		ps2_0: ps2@40009000 {
-			compatible = "microchip,xec-ps2";
-			reg = <0x40009000 0x40>;
-			interrupts = <100 1>;
-			girqs = <18 10>;
-			pcrs = <3 5>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		pwm0: pwm@40005800 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005800 0x20>;
-			pcrs = <1 4>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm1: pwm@40005810 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005810 0x20>;
-			pcrs = <1 20>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm2: pwm@40005820 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005820 0x20>;
-			pcrs = <1 21>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm3: pwm@40005830 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005830 0x20>;
-			pcrs = <1 22>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm4: pwm@40005840 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005840 0x20>;
-			pcrs = <1 23>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm5: pwm@40005850 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005850 0x20>;
-			pcrs = <1 24>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm6: pwm@40005860 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005860 0x20>;
-			pcrs = <1 25>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm7: pwm@40005870 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005870 0x20>;
-			pcrs = <1 26>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		pwm8: pwm@40005880 {
-			compatible = "microchip,xec-pwm";
-			reg = <0x40005880 0x20>;
-			pcrs = <1 27>;
-			status = "disabled";
-			#pwm-cells = <3>;
-		};
-		tach0: tach@40006000 {
-			compatible = "microchip,xec-tach";
-			reg = <0x40006000 0x10>;
-			interrupts = <71 4>;
-			girqs = <17 1>;
-			pcrs = <1 2>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		tach1: tach@40006010 {
-			compatible = "microchip,xec-tach";
-			reg = <0x40006010 0x10>;
-			interrupts = <72 4>;
-			girqs = <17 2>;
-			pcrs = <1 11>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		tach2: tach@40006020 {
-			compatible = "microchip,xec-tach";
-			reg = <0x40006020 0x10>;
-			interrupts = <73 4>;
-			girqs = <17 3>;
-			pcrs = <1 12>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		tach3: tach@40006030 {
-			compatible = "microchip,xec-tach";
-			reg = <0x40006030 0x10>;
-			interrupts = <159 4>;
-			girqs = <17 4>;
-			pcrs = <1 13>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		rpmfan0: rpmfan@4000a000 {
-			reg = <0x4000a000 0x80>;
-			interrupts = <74 1>, <75 1>;
-			girqs = <17 20>, <17 21>;
-			pcrs = <3 12>;
-			status = "disabled";
-		};
-		rpmfan1: rpmfan@4000a080 {
-			reg = <0x4000a080 0x80>;
-			interrupts = <76 1>, <77 1>;
-			girqs = <17 22>, <17 23>;
-			pcrs = <4 7>;
-			status = "disabled";
-		};
-		adc0: adc@40007c00 {
-			compatible = "microchip,xec-adc";
-			reg = <0x40007c00 0x90>;
-			interrupts = <78 0>, <79 0>;
-			girqs = <17 8>, <17 9>;
-			pcrs = <3 3>;
-			status = "disabled";
-			#io-channel-cells = <1>;
-			clktime = <32>;
-		};
-		kscan0: kscan@40009c00 {
-			compatible = "microchip,xec-kscan";
-			reg = <0x40009c00 0x18>;
-			interrupts = <135 0>;
-			girqs = <21 25>;
-			pcrs = <3 11>;
-			status = "disabled";
-			#address-cells = <1>;
-			#size-cells = <0>;
-		};
-		peci0: peci@40006400 {
-			compatible = "microchip,xec-peci";
-			reg = <0x40006400 0x80>;
-			interrupts = <70 4>;
-			girqs = <17 0>;
-			pcrs = <1 1>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-		};
-		spi0: spi@40070000 {
-			reg = <0x40070000 0x400>;
-			interrupts = <91 2>;
-			girqs = < MCHP_XEC_ECIA(18, 1, 10, 91) >;
-			clocks = <&pcr 4 8 MCHP_XEC_PCR_CLK_PERIPH>;
-			clock-frequency = <12000000>;
-			lines = <1>;
-			chip-select = <0>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-		spi1: spi@40009400 {
-			reg = <0x40009400 0x80>;
-			interrupts = <92 2>, <93 2>;
-			girqs = <18 2>, <18 3>;
-			pcrs = <3 9>;
-			status = "disabled";
-		};
-		spi2: spi@40009480 {
-			reg = <0x40009480 0x80>;
-			interrupts = <94 2>, <95 2>;
-			girqs = <18 4>, <18 5>;
-			pcrs = <4 22>;
-			status = "disabled";
-		};
-		prochot0: prochot@40003400 {
-			reg = <0x40003400 0x20>;
-			interrupts = <87 0>;
-			girqs = <17 17>;
-			pcrs = <4 13>;
-			status = "disabled";
-		};
-		rcid0: rcid@40001400 {
-			reg = <0x40001400 0x80>;
-			interrupts = <80 0>;
-			girqs = <17 10>;
-			pcrs = <4 10>;
-			status = "disabled";
-		};
-		rcid1: rcid@40001480 {
-			reg = <0x40001480 0x80>;
-			interrupts = <81 0>;
-			girqs = <17 11>;
-			pcrs = <4 11>;
-			status = "disabled";
-		};
-		rcid2: rcid@40001500 {
-			reg = <0x40001500 0x80>;
-			interrupts = <82 0>;
-			girqs = <17 12>;
-			pcrs = <4 12>;
-			status = "disabled";
-		};
-		spip0: spip@40007000 {
-			reg = <0x40007000 0x100>;
-			interrupts = <90 0>;
-			girqs = <18 0>;
-			pcrs = <4 16>;
-			status = "disabled";
-		};
-		bbled0: bbled@4000b800 {
-			reg = <0x4000b800 0x100>;
-			interrupts = <83 0>;
-			girqs = <17 13>;
-			pcrs = <3 16>;
-			status = "disabled";
-		};
-		bbled1: bbled@4000b900 {
-			reg = <0x4000b900 0x100>;
-			interrupts = <84 0>;
-			girqs = <17 14>;
-			pcrs = <3 17>;
-			status = "disabled";
-		};
-		bbled2: bbled@4000ba00 {
-			reg = <0x4000ba00 0x100>;
-			interrupts = <85 0>;
-			girqs = <17 15>;
-			pcrs = <3 18>;
-			status = "disabled";
-		};
-		bbled3: bbled@4000bb00 {
-			reg = <0x4000bb00 0x100>;
-			interrupts = <86 0>;
-			girqs = <17 16>;
-			pcrs = <3 25>;
-			status = "disabled";
-		};
-		bclink0: bclink@4000cd00 {
-			reg = <0x4000cd00 0x20>;
-			interrupts = <96 0>, <97 0>;
-			girqs = <18 7>, <18 6>;
-			pcrs = <3 19>;
-			status = "disabled";
-		};
-		tfdp0: tfdp@40008c00 {
-			reg = <0x40008c00 0x10>;
-			pcrs = <1 7>;
-			status = "disabled";
-		};
-		glblcfg0: glblcfg@400fff00 {
-			reg = <0x400fff00 0x40>;
-			pcrs = <2 12>;
-			status = "disabled";
-		};
-		uart0: uart@400f2400 {
-			compatible = "microchip,xec-uart";
-			reg = <0x400f2400 0x400>;
-			interrupts = <40 1>;
-			clock-frequency = <1843200>;
-			current-speed = <38400>;
-			girqs = <15 0>;
-			pcrs = <2 1>;
-			ldn = <9>;
-			status = "disabled";
-		};
-		uart1: uart@400f2800 {
-			compatible = "microchip,xec-uart";
-			reg = <0x400f2800 0x400>;
-			interrupts = <41 1>;
-			clock-frequency = <1843200>;
-			current-speed = <38400>;
-			girqs = <15 1>;
-			pcrs = <2 2>;
-			ldn = <10>;
-			status = "disabled";
-		};
-		espi0: espi@400f3400 {
-			compatible = "microchip,xec-espi-v2";
-			/* reg tuple contains one 32-bit address cell and one
-			 * 32-bit length(size) cell.
-			 */
-			#address-cells = <1>;
-			#size-cells = <1>;
-			reg = < 0x400f3400 0x400
-				0x400f3800 0x400
-				0x400f9c00 0x400>;
-			reg-names = "io", "mem", "vw";
-			interrupts = <103 3>, <104 3>, <105 3>, <106 3>,
-				     <107 3>, <108 3>, <109 3>, <110 2>,
-				     <156 3>;
-			interrupt-names = "pc", "bm1", "bm2", "ltr", "oob_up",
-					  "oob_dn", "fc", "rst", "vw_chan_en";
-			girqs = < MCHP_XEC_ECIA(19, 0, 11, 103)
-				  MCHP_XEC_ECIA(19, 1, 11, 104)
-				  MCHP_XEC_ECIA(19, 2, 11, 105)
-				  MCHP_XEC_ECIA(19, 3, 11, 106)
-				  MCHP_XEC_ECIA(19, 4, 11, 107)
-				  MCHP_XEC_ECIA(19, 5, 11, 108)
-				  MCHP_XEC_ECIA(19, 6, 11, 109)
-				  MCHP_XEC_ECIA(19, 7, 11, 110)
-				  MCHP_XEC_ECIA(19, 8, 11, 156) >;
-			pcrs = <2 19>;
-			status = "disabled";
-
-			espi_saf0: espi_saf@40008000 {
-				compatible = "microchip,xec-espi-saf-v2";
-				reg = <0x40008000 0x400>, <0x40070000 0x400>,
-				      <0x40071000 0x400>;
-				reg-names = "safbr", "safqspi", "safcomm";
-				interrupts = <166 3>, <167 3>;
-				interrupt-names = "done", "err";
-				girqs = < MCHP_XEC_ECIA(19, 9, 11, 166) >,
-					< MCHP_XEC_ECIA(19, 10, 11, 167) >;
-				pcrs = <2 27>;
-				status = "disabled";
-			};
-
-			mbox0: mbox@400f0000 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f0000 0x200>;
-				interrupts = <60 3>;
-				girqs = < MCHP_XEC_ECIA(15, 20, 7, 60) >;
-				pcrs = <2 17>;
-				ldn = <0>;
-				status = "disabled";
-			};
-			kbc0: kbc@400f0400 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f0400 0x400>;
-				interrupts = <58 3>, <59 3>;
-				interrupt-names = "kbc_obe", "kbc_ibf";
-				girqs = < MCHP_XEC_ECIA(15, 18, 7, 58)
-					  MCHP_XEC_ECIA(15, 19, 7, 59) >;
-				ldn = <1>;
-				status = "disabled";
-			};
-			acpi_ec0: acpi_ec@400f0800 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f0800 0x400>;
-				interrupts = <45 3>, <46 3>;
-				interrupt-names = "acpi_ibf", "acpi_obe";
-				girqs = < MCHP_XEC_ECIA(15, 5, 7, 45)
-					  MCHP_XEC_ECIA(15, 6, 7, 46) >;
-				ldn = <2>;
-				status = "disabled";
-			};
-			acpi_ec1: acpi_ec@400f0c00 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f0c00 0x400>;
-				interrupts = <47 3>, <48 3>;
-				interrupt-names = "acpi_ibf", "acpi_obe";
-				girqs = < MCHP_XEC_ECIA(15, 7, 7, 47)
-					  MCHP_XEC_ECIA(15, 8, 7, 48) >;
-				ldn = <3>;
-				status = "disabled";
-			};
-			acpi_ec2: acpi_ec@400f1000 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f1000 0x400>;
-				interrupts = <49 3>, <50 3>;
-				interrupt-names = "acpi_ibf", "acpi_obe";
-				girqs = < MCHP_XEC_ECIA(15, 9, 7, 49)
-					  MCHP_XEC_ECIA(15, 10, 7, 50) >;
-				ldn = <4>;
-				status = "disabled";
-			};
-			acpi_ec3: acpi_ec@400f1400 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f1400 0x400>;
-				interrupts = <51 3>, <52 3>;
-				interrupt-names = "acpi_ibf", "acpi_obe";
-				girqs = < MCHP_XEC_ECIA(15, 11, 7, 51)
-					  MCHP_XEC_ECIA(15, 12, 7, 52) >;
-				ldn = <5>;
-				status = "disabled";
-			};
-			acpi_ec4: acpi_ec@400f1800 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f1800 0x400>;
-				interrupts = <53 3>, <54 3>;
-				interrupt-names = "acpi_ibf", "acpi_obe";
-				girqs = < MCHP_XEC_ECIA(15, 13, 7, 53)
-					  MCHP_XEC_ECIA(15, 14, 7, 54) >;
-				ldn = <6>;
-				status = "disabled";
-			};
-			acpi_pm1: acpi_pm1@400f1c00 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f1c00 0x400>;
-				interrupts = <55 3>, <56 3>, <57 3>;
-				interrupt-names = "pm1_ctl", "pm1_en", "pm1_sts";
-				girqs = < MCHP_XEC_ECIA(15, 15, 7, 55)
-					  MCHP_XEC_ECIA(15, 16, 7, 56)
-					  MCHP_XEC_ECIA(15, 17, 7, 57) >;
-				ldn = <7>;
-				status = "disabled";
-			};
-			port92: port92@400f2000 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f2000 0x400>;
-				ldn = <8>;
-				status = "disabled";
-			};
-			emi0: emi@400f4000 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f4000 0x400>;
-				interrupts = <42 3>;
-				girqs = < MCHP_XEC_ECIA(15, 2, 7, 42) >;
-				ldn = <16>;
-				status = "disabled";
-			};
-			emi1: emi@400f4400 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f4400 0x400>;
-				interrupts = <43 3>;
-				girqs = < MCHP_XEC_ECIA(15, 3, 7, 43) >;
-				ldn = <17>;
-				status = "disabled";
-			};
-			emi2: emi@400f4800 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f4800 0x400>;
-				interrupts = <44 3>;
-				girqs = < MCHP_XEC_ECIA(15, 4, 7, 44) >;
-				ldn = <18>;
-				status = "disabled";
-			};
-			rtc0: rtc@400f5000 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f5000 0x100>;
-				interrupts = <119 3>, <120 3>;
-				girqs = < MCHP_XEC_ECIA(21, 8, 13, 119)
-					  MCHP_XEC_ECIA(21, 9, 13, 120) >;
-				pcrs = <2 18>;
-				ldn = <20>;
-				status = "disabled";
-			};
-			/* Capture writes to host I/O 0x80 - 0x83 */
-			p80bd0: p80bd@400f8000 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f8000 0x400>;
-				interrupts = <62 0>;
-				girqs = < MCHP_XEC_ECIA(15, 22, 7, 62) >;
-				pcrs = <2 25>;
-				ldn = <32>;
-				status = "disabled";
-			};
-			/* Capture writes to an 8-bit I/O and map to one of 0x80 to 0x83 */
-			p80bd0_alias: p80bd@400f8400 {
-				compatible = "microchip,xec-espi-host-dev";
-				reg = <0x400f8400 0x400>;
-				ldn = <33>;
-				host-io = <0x90>;
-				/* map 0x90 to 0x80 */
-				host-io-addr-mask = <0x01>;
-				status = "disabled";
-			};
-		};
-
-		symcr: symcr@40100000 {
-			compatible = "microchip,xec-symcr";
-			reg = <0x40100000 0x1000>;
-			interrupts = <68 1>;
-			clocks = <&pcr 3 26 MCHP_XEC_PCR_CLK_PERIPH>;
-			girqs = <16 3>;
-			status = "disabled";
-			#address-cells = <1>;
-			#size-cells = <1>;
-		};
-
-		rom_api: rom_api@1f000 {
-			reg = <0x1f000 0x1000>;
-			status = "disabled";
-		};
 	};
 };
 
-- 
2.25.1


From 759d9b257e9dad13da4428dbbe09d4f47e4a274e Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 25 Jan 2024 16:02:42 -0800
Subject: [PATCH 07/12] dts: bindings: clock: pinctrl is not required for all
 clock options

Pinctrl is not required when internal oscillator is used

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/bindings/clock/microchip,xec-pcr.yaml | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/dts/bindings/clock/microchip,xec-pcr.yaml b/dts/bindings/clock/microchip,xec-pcr.yaml
index 5a07aec6d4..7915da25aa 100644
--- a/dts/bindings/clock/microchip,xec-pcr.yaml
+++ b/dts/bindings/clock/microchip,xec-pcr.yaml
@@ -87,12 +87,6 @@ properties:
       for PLL and Periheral devices then disable the internal 32KHz
       oscillator to save power.
 
-  pinctrl-0:
-    required: true
-
-  pinctrl-names:
-    required: true
-
   "#clock-cells":
     const: 3
 
-- 
2.25.1


From d7753c71f32b86743f6637d32a6a1fec6778e716 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 1 Feb 2024 17:10:33 -0800
Subject: [PATCH 08/12] dts: arm: microchip: mec1501: mec172xnsz: Remove
 pinctrl from SoC dts

Remove pinctrl from device tree since it is not required
when internal oscillator is used.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/arm/microchip/mec1501hsz.dtsi     | 3 ---
 dts/arm/microchip/mec172x_common.dtsi | 3 ---
 2 files changed, 6 deletions(-)

diff --git a/dts/arm/microchip/mec1501hsz.dtsi b/dts/arm/microchip/mec1501hsz.dtsi
index 4700a2d746..6fc7799802 100644
--- a/dts/arm/microchip/mec1501hsz.dtsi
+++ b/dts/arm/microchip/mec1501hsz.dtsi
@@ -59,9 +59,6 @@
 			clk32kmon-valid-min = <4>;
 			xtal-enable-delay-ms = <300>;
 			pll-lock-timeout-ms = <30>;
-			/* pin configured only if the sources is set to PIN */
-			pinctrl-0 = <&clk_32khz_in_gpio165>;
-			pinctrl-names = "default";
 			#clock-cells = <3>;
 		};
 		ecia: ecia@4000e000 {
diff --git a/dts/arm/microchip/mec172x_common.dtsi b/dts/arm/microchip/mec172x_common.dtsi
index 03a6a00fb4..44c1f5190d 100644
--- a/dts/arm/microchip/mec172x_common.dtsi
+++ b/dts/arm/microchip/mec172x_common.dtsi
@@ -22,9 +22,6 @@ pcr: pcr@40080100 {
 	clk32kmon-valid-min = <4>;
 	xtal-enable-delay-ms = <300>;
 	pll-lock-timeout-ms = <30>;
-	/* pin configured only if one of the sources is set to PIN */
-	pinctrl-0 = <&clk_32khz_in_gpio165>;
-	pinctrl-names = "default";
 	#clock-cells = <3>;
 };
 ecia: ecia@4000e000 {
-- 
2.25.1


From 2e1f7b05327fd88ec0f72558e72707fc924d0140 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Wed, 23 Aug 2023 14:51:37 -0700
Subject: [PATCH 09/12] dts: arm: mec172x: Allow to use VCI pins as GPIOs

Allow to VCI pins to be used as GPIOS using zephyr user dts entry

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/arm/microchip/mec172x/mec172xnsz-pinctrl.dtsi | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dts/arm/microchip/mec172x/mec172xnsz-pinctrl.dtsi b/dts/arm/microchip/mec172x/mec172xnsz-pinctrl.dtsi
index 6968c1c3cf..70c0f85134 100644
--- a/dts/arm/microchip/mec172x/mec172xnsz-pinctrl.dtsi
+++ b/dts/arm/microchip/mec172x/mec172xnsz-pinctrl.dtsi
@@ -1034,6 +1034,16 @@
 		pinmux = < MCHP_XEC_PINMUX(00, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio000_gpio000: gpio000_gpio000 {
+		pinmux = < MCHP_XEC_PINMUX(000, MCHP_AF0) >;
+	};
+	/omit-if-no-ref/ gpio161_gpio161: gpio161_gpio161 {
+		pinmux = < MCHP_XEC_PINMUX(0161, MCHP_AF0) >;
+	};
+	/omit-if-no-ref/ gpio162_gpio162: gpio162_gpio162 {
+		pinmux = < MCHP_XEC_PINMUX(0162, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ sys_shdn_fw_n_gpio221: sys_shdn_fw_n_gpio221 {
 		pinmux = < MCHP_XEC_PINMUX(0221, MCHP_AF5) >;
 	};
-- 
2.25.1


From afce3e460d631e0ab83e9e19ed68ce1831e99e12 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 1 Feb 2024 17:01:06 -0800
Subject: [PATCH 10/12] dts: arm: mec152x: Allow to use VCI pins as GPIOs

Allow to VCI pins to be used as GPIOS using zephyr user device
tree node entry.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 .../microchip/mec152x/mec152xhsz-pinctrl.dtsi | 28 +++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dts/arm/microchip/mec152x/mec152xhsz-pinctrl.dtsi b/dts/arm/microchip/mec152x/mec152xhsz-pinctrl.dtsi
index ba1556519a..63e1cc4a53 100644
--- a/dts/arm/microchip/mec152x/mec152xhsz-pinctrl.dtsi
+++ b/dts/arm/microchip/mec152x/mec152xhsz-pinctrl.dtsi
@@ -923,26 +923,50 @@
 		pinmux = < MCHP_XEC_PINMUX(0172, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio172_gpio172: gpio172_gpio172 {
+		pinmux = < MCHP_XEC_PINMUX(0172, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ vci_in0_n_gpio253: vci_in0_n_gpio253 {
 		pinmux = < MCHP_XEC_PINMUX(0253, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio253_gpio253: gpio253_gpio253 {
+		pinmux = < MCHP_XEC_PINMUX(0253, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ vci_in1_n_gpio162: vci_in1_n_gpio162 {
 		pinmux = < MCHP_XEC_PINMUX(0162, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio162_gpio162: gpio162_gpio162 {
+		pinmux = < MCHP_XEC_PINMUX(0162, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ vci_in2_n_gpio161: vci_in2_n_gpio161 {
 		pinmux = < MCHP_XEC_PINMUX(0161, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio161_gpio161: gpio161_gpio161 {
+		pinmux = < MCHP_XEC_PINMUX(0161, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ vci_in3_n_gpio000: vci_in3_n_gpio000 {
 		pinmux = < MCHP_XEC_PINMUX(000, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio000_gpio000: gpio000_gpio000 {
+		pinmux = < MCHP_XEC_PINMUX(0000, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ vci_out_gpio250: vci_out_gpio250 {
 		pinmux = < MCHP_XEC_PINMUX(0250, MCHP_AF1) >;
 	};
 
+	/omit-if-no-ref/ gpio250_gpio250: gpio250_gpio250 {
+		pinmux = < MCHP_XEC_PINMUX(0250, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ sys_shdn_n_gpio221: sys_shdn_n_gpio221 {
 		pinmux = < MCHP_XEC_PINMUX(0221, MCHP_AF3) >;
 	};
@@ -1047,6 +1071,10 @@
 		pinmux = < MCHP_XEC_PINMUX(0163, MCHP_AF2) >;
 	};
 
+	/omit-if-no-ref/ gpio163_gpio163: gpio163_gpio163 {
+		pinmux = < MCHP_XEC_PINMUX(0163, MCHP_AF0) >;
+	};
+
 	/omit-if-no-ref/ sgpio3_datain_gpio242: sgpio3_datain_gpio242 {
 		pinmux = < MCHP_XEC_PINMUX(0242, MCHP_AF2) >;
 	};
-- 
2.25.1


From de3254a3ca5c756309ba608bef36b24e8c40bd6b Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 8 Feb 2024 20:04:46 -0800
Subject: [PATCH 11/12] drivers: espi: mec172x: Do not enable interrupt if VW
 is disabled

Do check if a VW is enabled before enabling interrupt

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_mchp_xec_v2.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/espi/espi_mchp_xec_v2.c b/drivers/espi/espi_mchp_xec_v2.c
index 52d74973e9..ba9486add8 100644
--- a/drivers/espi/espi_mchp_xec_v2.c
+++ b/drivers/espi/espi_mchp_xec_v2.c
@@ -1431,6 +1431,12 @@ static int xec_register_vw_handlers(const struct device *dev)
 		const struct espi_vw_isr *vwi = &m2s_vwires_isr[i];
 		struct xec_signal signal_info = vw_tbl[vwi->signal];
 		uint8_t xec_id = signal_info.xec_reg_idx;
+		uint8_t en = (signal_info.flags & BIT(MCHP_DT_ESPI_VW_FLAG_STATUS_POS));
+
+		if (!en) {
+			LOG_INF("VW %d not enabled, skipping", vwi->signal);
+			continue;
+		}
 
 		/* enables interrupt in eSPI MSVWn register */
 		xec_espi_vw_intr_ctrl(dev, xec_id, signal_info.bit,
-- 
2.25.1


From 93c300368b4ce842c879ee0e50b294a36f5ba1a1 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Wed, 6 Dec 2023 12:35:07 -0800
Subject: [PATCH 12/12] drivers: ecia: microchip: Prevent lost eSPI interrupts

Clearing virtual wire interrupt after calling callback may cause
interrupt miss if the same virtual wire changes due to action
in handler.

e.g. HOST_RST_WRN pulse within 50 us

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/interrupt_controller/intc_mchp_ecia_xec.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/interrupt_controller/intc_mchp_ecia_xec.c b/drivers/interrupt_controller/intc_mchp_ecia_xec.c
index 29692c9dbd..4f7d97c6c9 100644
--- a/drivers/interrupt_controller/intc_mchp_ecia_xec.c
+++ b/drivers/interrupt_controller/intc_mchp_ecia_xec.c
@@ -476,6 +476,10 @@ static void xec_girq_isr(const struct device *dev_girq)
 	for (int i = 0; result && i < 32; i++) {
 		uint8_t bitpos = 31 - (__builtin_clz(result) & 0x1f);
 
+		/* clear GIRQ latched status */
+		girq->SRC = BIT(bitpos);
+		result &= ~BIT(bitpos);
+
 		/* is it an implemented source? */
 		if (cfg->sources[bitpos] & BIT(7)) {
 			/* yes, get the index by removing bit[7] flag */
@@ -489,10 +493,6 @@ static void xec_girq_isr(const struct device *dev_girq)
 		} else { /* paranoia, we should not get here... */
 			girq->EN_CLR = BIT(bitpos);
 		}
-
-		/* clear GIRQ latched status */
-		girq->SRC = BIT(bitpos);
-		result &= ~BIT(bitpos);
 	}
 }
 #endif
-- 
2.25.1

