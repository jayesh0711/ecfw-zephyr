From a4f05fbabc64ca29e4e24a515af45579986812fb Mon Sep 17 00:00:00 2001
From: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
Date: Mon, 30 Mar 2020 10:32:05 -0400
Subject: [PATCH 01/36] drivers: espi: Clear virtual wire interrupt before
 calling handler

Clearing virtual wire interrupt after calling handler may cause next
interrupt miss if the same virtual wire changes due to action in handler.
As the interrupt source is read from register, it can be cleared before
calling handler to avoid next interrupt miss due to action/delay in the
callback handler.

Signed-off-by: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 0354b9989b..fa23a7fe4a 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -1289,6 +1289,7 @@ static void espi_xec_vw_isr(const struct device *dev)
 	uint32_t girq_result;
 
 	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_id);
+	MCHP_GIRQ_SRC(config->vw_girq_id) = girq_result;
 
 	for (int i = 0; i < m2s_vwires_isr_cnt; i++) {
 		struct espi_isr entry = m2s_vwires_isr[i];
@@ -1299,8 +1300,6 @@ static void espi_xec_vw_isr(const struct device *dev)
 			}
 		}
 	}
-
-	REG32(MCHP_GIRQ_SRC_ADDR(config->vw_girq_id)) = girq_result;
 }
 
 static void espi_xec_periph_isr(const struct device *dev)
-- 
2.17.1


From a420c5e1eddfab603bb1aead7d600dbfd8f2cdd0 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 11 Aug 2020 10:36:25 -0700
Subject: [PATCH 02/36] samples: drivers: espi: Remove magic number

Define macro for number of times the temperatures will
be retrieved.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 samples/drivers/espi/src/main.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/samples/drivers/espi/src/main.c b/samples/drivers/espi/src/main.c
index e5f8fc8088..3f29d55b28 100644
--- a/samples/drivers/espi/src/main.c
+++ b/samples/drivers/espi/src/main.c
@@ -25,6 +25,7 @@ LOG_MODULE_DECLARE(espi, CONFIG_ESPI_LOG_LEVEL);
 
 /* Maximum bytes for OOB transactions */
 #define MAX_RESP_SIZE         20u
+#define MIN_GET_TEMP_CYCLES   5u
 
 /* eSPI flash parameters */
 #define MAX_TEST_BUF_SIZE     1024u
@@ -673,7 +674,7 @@ int espi_test(void)
 	/*  Attempt to use OOB channel to read temperature, regardless of
 	 * if is enabled or not.
 	 */
-	for (int i = 0; i < 5; i++) {
+	for (int i = 0; i < MIN_GET_TEMP_CYCLES; i++) {
 		int temp;
 
 		ret = get_pch_temp(espi_dev, &temp);
-- 
2.17.1


From 0fd2ac5af26e71f881f26cfc19f68665601de730 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 27 Aug 2020 14:29:31 -0700
Subject: [PATCH 03/36] drivers: espi: xec: support for eSPI slaves with long
 initializations

Add Kconfig switch to disable automatic eSPI slave boot
acknowledgement.
This allows to perform lenghty operations before continue any eSPI
handshake with eSPI master.

Required for eSPI SAF boot configuration.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/espi/Kconfig b/drivers/espi/Kconfig
index b04c58c46d..7c3c531bf6 100644
--- a/drivers/espi/Kconfig
+++ b/drivers/espi/Kconfig
@@ -50,7 +50,7 @@ config ESPI_AUTOMATIC_WARNING_ACKNOWLEDGE
 	depends on ESPI_VWIRE_CHANNEL
 	depends on ESPI_SLAVE
 	help
-	  Enable automatic acknowledge from eSPI slave towards eSPI host
+	  Enable automatic acknowledgent from eSPI slave towards eSPI host
 	  whenever it receives suspend or reset warning.
 	  If this is disabled, it means the app wants to be give the opportunity
 	  to prepare for either HOST suspend or reset.
@@ -61,7 +61,7 @@ config ESPI_AUTOMATIC_BOOT_DONE_ACKNOWLEDGE
 	depends on ESPI_VWIRE_CHANNEL
 	depends on ESPI_SLAVE
 	help
-	  Enable automatic acknowledge of slave basic configuration been
+	  Enable automatic acknowledgment from slave basic configuration been
 	  completed by sending a virtual wire message to the eSPI master.
 	  This depends on SPI boot configuration. It could be either very
 	  early in the flow after the VW channel is configured. Or it could be
-- 
2.17.1


From 9743b07e2e2a8eaf5e814c62979dcd2aa67b1c5b Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 24 Nov 2020 13:01:20 -0800
Subject: [PATCH 04/36] drivers: espi: config: Add configuration option for
 systems with host-initiated traffic

Assume by default OOB traffic over eSPI bus is always client
initiated.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/espi/Kconfig b/drivers/espi/Kconfig
index 7c3c531bf6..9168a43d6e 100644
--- a/drivers/espi/Kconfig
+++ b/drivers/espi/Kconfig
@@ -167,4 +167,11 @@ config ESPI_PERIPHERAL_HOST_CMD_PARAM_PORT_NUM
 
 endif # ESPI_PERIPHERAL_CHANNEL
 
+config ESPI_OOB_CHANNEL_RX_ASYNC
+	bool "OOB host-initiated traffic handling"
+	depends on ESPI_OOB_CHANNEL
+	help
+	  Enables asynchronous handling for host-initiated OOB traffic.
+	  Otherwise OOB traffic is assumed to be always client-initiated.
+
 endif # ESPI
-- 
2.17.1


From cc95c4b65b2a3a4f930fa65d080ce5e6a6900303 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 24 Nov 2020 13:02:43 -0800
Subject: [PATCH 05/36] drivers: espi: xec: Add support for host-initiated
 traffic

Keep OOB Rx channel and interrupt always enabled.

Send callback when packet is received in OOB Rx channel
if asynchronous host-initiated handling is enabled.

Note that driver doesn't perform any buffering from packets,
so access to OOB Rx channel is gated by client's driver
packet retrieval.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 42 +++++++++++++++++++++++++-----------
 1 file changed, 30 insertions(+), 12 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index fa23a7fe4a..8dfffb742b 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -21,8 +21,8 @@
  */
 #define ESPI_XEC_VWIRE_SEND_TIMEOUT 100ul
 
-/* 100ms */
-#define MAX_OOB_TIMEOUT             100ul
+/* 200ms */
+#define MAX_OOB_TIMEOUT             200ul
 /* 1s */
 #define MAX_FLASH_TIMEOUT           1000ul
 
@@ -529,7 +529,6 @@ static int espi_xec_send_oob(const struct device *dev,
 static int espi_xec_receive_oob(const struct device *dev,
 				struct espi_oob_packet *pckt)
 {
-	int ret;
 	uint8_t err_mask = MCHP_ESPI_OOB_RX_STS_IBERR |
 			MCHP_ESPI_OOB_RX_STS_OVRUN;
 	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
@@ -538,16 +537,16 @@ static int espi_xec_receive_oob(const struct device *dev,
 		return -EIO;
 	}
 
-	/* Enable Rx only when we want to receive data */
-	ESPI_OOB_REGS->RX_IEN |= MCHP_ESPI_OOB_RX_IEN;
-	ESPI_OOB_REGS->RX_CTRL |= MCHP_ESPI_OOB_RX_CTRL_AVAIL;
+#ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	int ret;
+	struct espi_xec_data *data = (struct espi_xec_data *)(dev->driver_data);
 
 	/* Wait until ISR or timeout */
 	ret = k_sem_take(&data->rx_lock, K_MSEC(MAX_OOB_TIMEOUT));
 	if (ret == -EAGAIN) {
 		return -ETIMEDOUT;
 	}
-
+#endif
 	/* Check if buffer passed to driver can fit the received buffer */
 	uint32_t rcvd_len = ESPI_OOB_REGS->RX_LEN & MCHP_ESPI_OOB_RX_LEN_MASK;
 
@@ -558,6 +557,12 @@ static int espi_xec_receive_oob(const struct device *dev,
 
 	pckt->len = rcvd_len;
 	memcpy(pckt->buf, slave_rx_mem, pckt->len);
+	memset(slave_rx_mem, 0, pckt->len);
+
+	/* Only after data has been copied from SRAM, indicate channel
+	 * is available for next packet
+	 */
+	ESPI_OOB_REGS->RX_CTRL |= MCHP_ESPI_OOB_RX_CTRL_AVAIL;
 
 	return 0;
 }
@@ -656,8 +661,6 @@ static int espi_xec_flash_write(const struct device *dev,
 		return -EIO;
 	}
 
-	memcpy(pckt->buf, slave_rx_mem, pckt->len);
-
 	return 0;
 }
 
@@ -754,6 +757,12 @@ static void espi_init_oob(const struct device *dev)
 	/* Enable OOB Tx channel enable change status interrupt */
 	ESPI_OOB_REGS->TX_IEN |= MCHP_ESPI_OOB_TX_IEN_CHG_EN |
 				MCHP_ESPI_OOB_TX_IEN_DONE;
+
+	/* Enable Rx channel to receive data any time
+	 * there are case where OOB is not initiated by a previous OOB Tx
+	 */
+	ESPI_OOB_REGS->RX_IEN |= MCHP_ESPI_OOB_RX_IEN;
+	ESPI_OOB_REGS->RX_CTRL |= MCHP_ESPI_OOB_RX_CTRL_AVAIL;
 }
 #endif
 
@@ -950,6 +959,11 @@ static void espi_oob_down_isr(const struct device *dev)
 {
 	uint32_t status;
 	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_OOB_RECEIVED,
+				  .evt_details = 0,
+				  .evt_data = 0 };
+#endif
 
 	status = ESPI_OOB_REGS->RX_STS;
 
@@ -958,10 +972,12 @@ static void espi_oob_down_isr(const struct device *dev)
 		/* Register is write-on-clear, ensure only 1 bit is affected */
 		ESPI_OOB_REGS->RX_STS = MCHP_ESPI_OOB_RX_STS_DONE;
 
-		/* Disable Rx interrupt */
-		ESPI_OOB_REGS->RX_IEN &= ~MCHP_ESPI_OOB_RX_IEN;
-
+#ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
 		k_sem_give(&data->rx_lock);
+#else
+		evt.evt_details = ESPI_OOB_REGS->RX_LEN & MCHP_ESPI_OOB_RX_LEN_MASK;
+		espi_send_callbacks(&data->callbacks, dev, evt);
+#endif
 	}
 }
 
@@ -1377,7 +1393,9 @@ static int espi_xec_init(const struct device *dev)
 	ESPI_CAP_REGS->OOB_CAP |= MCHP_ESPI_OOB_CAP_MAX_PLD_SZ_73;
 
 	k_sem_init(&data->tx_lock, 0, 1);
+#ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
 	k_sem_init(&data->rx_lock, 0, 1);
+#endif /* CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC */
 #else
 	ESPI_CAP_REGS->GLB_CAP0 &= ~MCHP_ESPI_GBL_CAP0_OOB_SUPP;
 #endif
-- 
2.17.1


From dfa3d18c50315bd247b929ca094ce97c5a8092bf Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 24 Nov 2020 13:59:34 -0800
Subject: [PATCH 06/36] samples: drivers: espi: Showcase OOB Rx asynchronous
 handling

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_mchp_xec.c                  |   3 +-
 .../espi/prj_mec1501modular_assy6885.conf     |   2 +
 samples/drivers/espi/src/espi_oob_handler.c   | 214 ++++++++++++++++++
 samples/drivers/espi/src/espi_oob_handler.h   |  59 +++++
 samples/drivers/espi/src/main.c               |  98 ++------
 5 files changed, 296 insertions(+), 80 deletions(-)
 create mode 100644 samples/drivers/espi/src/espi_oob_handler.c
 create mode 100644 samples/drivers/espi/src/espi_oob_handler.h

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 8dfffb742b..22adbf7b93 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -531,7 +531,6 @@ static int espi_xec_receive_oob(const struct device *dev,
 {
 	uint8_t err_mask = MCHP_ESPI_OOB_RX_STS_IBERR |
 			MCHP_ESPI_OOB_RX_STS_OVRUN;
-	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
 
 	if (ESPI_OOB_REGS->TX_STS & err_mask) {
 		return -EIO;
@@ -539,7 +538,7 @@ static int espi_xec_receive_oob(const struct device *dev,
 
 #ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
 	int ret;
-	struct espi_xec_data *data = (struct espi_xec_data *)(dev->driver_data);
+	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
 
 	/* Wait until ISR or timeout */
 	ret = k_sem_take(&data->rx_lock, K_MSEC(MAX_OOB_TIMEOUT));
diff --git a/samples/drivers/espi/prj_mec1501modular_assy6885.conf b/samples/drivers/espi/prj_mec1501modular_assy6885.conf
index cabf9b528e..a4d3129ffa 100644
--- a/samples/drivers/espi/prj_mec1501modular_assy6885.conf
+++ b/samples/drivers/espi/prj_mec1501modular_assy6885.conf
@@ -7,3 +7,5 @@ CONFIG_LOG_PROCESS_THREAD_SLEEP_MS=100
 CONFIG_ESPI_AUTOMATIC_WARNING_ACKNOWLEDGE=n
 # Sample code doesn't handle ACPI host communication
 CONFIG_ESPI_PERIPHERAL_HOST_IO=n
+# This only makes sense for system using this board
+CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC=y
diff --git a/samples/drivers/espi/src/espi_oob_handler.c b/samples/drivers/espi/src/espi_oob_handler.c
new file mode 100644
index 0000000000..dc95d8d89e
--- /dev/null
+++ b/samples/drivers/espi/src/espi_oob_handler.c
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <device.h>
+#include <soc.h>
+#include <drivers/gpio.h>
+#include <drivers/espi.h>
+#include <logging/log_ctrl.h>
+#include <logging/log.h>
+#include "espi_oob_handler.h"
+
+LOG_MODULE_DECLARE(espi, CONFIG_ESPI_LOG_LEVEL);
+
+struct oob_header {
+	uint8_t dest_slave_addr;
+	uint8_t oob_cmd_code;
+	uint8_t byte_cnt;
+	uint8_t src_slave_addr;
+};
+
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+
+#define OOB_THREAD_STACK_SIZE  512ul
+#define OOB_THREAD_PRIORITY    K_PRIO_COOP(5)
+#define OOB_THREAD_WAIT        -1
+
+/* Thread to process asynchronous callbacks */
+void espihub_thread(void *p1, void *p2, void *p3);
+
+void temperature_timer(struct k_timer *timer_id);
+
+K_TIMER_DEFINE(temp_timer, temperature_timer, NULL);
+K_THREAD_DEFINE(espihub_thrd_id, OOB_THREAD_STACK_SIZE, espihub_thread,
+		NULL, NULL, NULL,
+		OOB_THREAD_PRIORITY, K_INHERIT_PERMS, OOB_THREAD_WAIT);
+
+K_MSGQ_DEFINE(from_host, sizeof(uint8_t), 8, 4);
+
+struct thread_context {
+	const struct device  *espi_dev;
+	int                  cycles;
+};
+
+static struct thread_context context;
+#endif
+
+static struct espi_oob_packet resp_pckt;
+static uint8_t buf[MAX_ESPI_BUF_LEN];
+
+static int request_temp(const struct device *dev)
+{
+	int ret;
+	struct oob_header oob_hdr;
+	struct espi_oob_packet req_pckt;
+
+	LOG_WRN("%s", __func__);
+
+	oob_hdr.dest_slave_addr = PCH_DEST_SLV_ADDR;
+	oob_hdr.oob_cmd_code = OOB_CMDCODE;
+	oob_hdr.byte_cnt = 1;
+	oob_hdr.src_slave_addr = SRC_SLV_ADDR;
+
+	/* Packetize OOB request */
+	req_pckt.buf = (uint8_t *)&oob_hdr;
+	req_pckt.len = sizeof(struct oob_header);
+
+	ret = espi_send_oob(dev, &req_pckt);
+	if (ret) {
+		LOG_ERR("OOB Tx failed %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int retrieve_packet(const struct device *dev, uint8_t *sender)
+{
+	int ret;
+
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	/* Note that no data is in the item */
+	uint8_t response_len;
+
+	if (k_msgq_num_used_get(&from_host) == 0U) {
+		return -EINVAL;
+	}
+
+	k_msgq_get(&from_host, &response_len, K_FOREVER);
+#endif
+
+	resp_pckt.buf = (uint8_t *)&buf;
+	resp_pckt.len = MAX_ESPI_BUF_LEN;
+
+	ret = espi_receive_oob(dev, &resp_pckt);
+	if (ret) {
+		LOG_ERR("OOB Rx failed %d", ret);
+		return ret;
+	}
+
+	LOG_INF("OOB transaction completed rcvd: %d bytes", resp_pckt.len);
+	for (int i = 0; i < resp_pckt.len; i++) {
+		LOG_INF("%x ", buf[i]);
+	}
+
+	if (sender) {
+		*sender = buf[OOB_RESPONSE_SENDER_INDEX];
+	}
+
+	return 0;
+}
+
+int get_pch_temp_sync(const struct device *dev)
+{
+	int ret;
+
+	for (int i = 0; i < MIN_GET_TEMP_CYCLES; i++) {
+		ret = request_temp(dev);
+		if (ret) {
+			LOG_ERR("OOB req failed %d", ret);
+			return ret;
+		}
+
+		ret = retrieve_packet(dev, NULL);
+		if (ret) {
+			LOG_ERR("OOB retrieve failed %d", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int get_pch_temp_async(const struct device *dev)
+{
+#if !defined(CONFIG_ESPI_OOB_CHANNEL) || \
+    !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
+	return -ENOTSUP;
+#else
+	context.espi_dev = dev;
+	context.cycles = MIN_GET_TEMP_CYCLES;
+
+	k_thread_start(espihub_thrd_id);
+	k_thread_join(espihub_thrd_id, K_FOREVER);
+
+	return 0;
+#endif
+}
+
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+
+void oob_rx_handler(const struct device *dev, struct espi_callback *cb,
+		    struct espi_event event)
+{
+	uint8_t last_resp_len = event.evt_details;
+
+	LOG_WRN("%s", __func__);
+	/* Post for post-processing in a thread
+	 * Should not attempt to retrieve in callback context
+	 */
+	k_msgq_put(&from_host, &last_resp_len, K_NO_WAIT);
+}
+
+
+bool need_temp;
+
+void temperature_timer(struct k_timer *timer_id)
+{
+	LOG_WRN("%s", __func__);
+	need_temp = true;
+}
+
+void espihub_thread(void *p1, void *p2, void *p3)
+{
+	int ret;
+	uint8_t temp;
+	uint8_t sender;
+	LOG_INF("%s", __func__);
+
+	k_timer_start(&temp_timer, K_MSEC(100), K_MSEC(100));
+	while (context.cycles > 0) {
+		k_msleep(50);
+
+		ret = retrieve_packet(context.espi_dev, &sender);
+		if (!ret) {
+			switch (sender) {
+			case PCH_DEST_SLV_ADDR:
+				LOG_INF("PCH response");
+				/* Any other checks */
+				if (resp_pckt.len == OOB_RESPONSE_LEN) {
+					temp = buf[OOB_RESPONSE_DATA_INDEX];
+					LOG_INF("Temp %d", temp);
+				} else {
+					LOG_ERR("Incorrect size response");
+				}
+
+				context.cycles--;
+				break;
+			default:
+				LOG_INF("Other host sender %x", sender);
+			}
+
+		}
+
+		if (need_temp) {
+			request_temp(context.espi_dev);
+			need_temp = false;
+		}
+	}
+	k_timer_stop(&temp_timer);
+}
+#endif /* CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC */
diff --git a/samples/drivers/espi/src/espi_oob_handler.h b/samples/drivers/espi/src/espi_oob_handler.h
new file mode 100644
index 0000000000..ed09d5b803
--- /dev/null
+++ b/samples/drivers/espi/src/espi_oob_handler.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef __ESPI_OOB_HANDLER_H__
+#define __ESPI_OOB_HANDLER_H__
+
+/* eSPI host entity address  */
+#define PCH_DEST_SLV_ADDR     0x02u
+#define SRC_SLV_ADDR          0x21u
+
+#define OOB_RESPONSE_SENDER_INDEX   0x02u
+#define OOB_RESPONSE_DATA_INDEX     0x04u
+
+
+/* Temperature command opcode */
+#define OOB_CMDCODE           0x01u
+#define OOB_RESPONSE_LEN            0x05u
+
+/* Maximum bytes for OOB transactions */
+#define MAX_ESPI_BUF_LEN      80u
+#define MIN_GET_TEMP_CYCLES   5u
+
+/* 100ms */
+#define MAX_OOB_TIMEOUT       100ul
+
+void oob_rx_handler(const struct device *dev, struct espi_callback *cb,
+		    struct espi_event event);
+
+/**
+ * @brief Retrieve PCH temperature over OOB channel.
+ * Assumes OOB Tx and Rx as synchronous operation.
+ *
+ * @param dev eSPI driver handle.
+ *
+ * @retval 0 If successful.
+ * @retval -ENOTSUP returned when OOB channel is not supported.
+ * @retval -EINVAL is returned when OOB parameters are invalid.
+ *
+ */
+int get_pch_temp_sync(const struct device *dev);
+
+
+/**
+ * @brief Retrieve PCH temperature over OOB channel.
+ * Assumes OOB Tx and Rx as synchronous operation.
+ *
+ * @param dev eSPI driver handle.
+ *
+ * @retval 0 If successful.
+ * @retval -ENOTSUP returned when OOB channel is not supported.
+ * @retval -ETIMEOUT OOB operations could not be started.
+ *
+ */
+int get_pch_temp_async(const struct device *dev);
+
+#endif /* __ESPI_OOB_HANDLER_H__ */
diff --git a/samples/drivers/espi/src/main.c b/samples/drivers/espi/src/main.c
index 3f29d55b28..8907ff6503 100644
--- a/samples/drivers/espi/src/main.c
+++ b/samples/drivers/espi/src/main.c
@@ -12,21 +12,11 @@
 #include <drivers/espi.h>
 #include <logging/log_ctrl.h>
 #include <logging/log.h>
+#ifdef CONFIG_ESPI_OOB_CHANNEL
+#include "espi_oob_handler.h"
+#endif
 LOG_MODULE_DECLARE(espi, CONFIG_ESPI_LOG_LEVEL);
 
-/* eSPI host entity address  */
-#define DEST_SLV_ADDR         0x02u
-#define SRC_SLV_ADDR          0x21u
-
-/* Temperature command opcode */
-#define OOB_CMDCODE           0x01u
-#define OOB_RESPONSE_LEN      0x05u
-#define OOB_RESPONSE_INDEX    0x03u
-
-/* Maximum bytes for OOB transactions */
-#define MAX_RESP_SIZE         20u
-#define MIN_GET_TEMP_CYCLES   5u
-
 /* eSPI flash parameters */
 #define MAX_TEST_BUF_SIZE     1024u
 #define MAX_FLASH_REQUEST     64u
@@ -45,13 +35,6 @@ LOG_MODULE_DECLARE(espi, CONFIG_ESPI_LOG_LEVEL);
 #define EVENT_TYPE(x)         (x & EVENT_MASK)
 #define EVENT_DETAILS(x)      ((x & EVENT_DETAILS_MASK) >> EVENT_DETAILS_POS)
 
-struct oob_header {
-	uint8_t dest_slave_addr;
-	uint8_t oob_cmd_code;
-	uint8_t byte_cnt;
-	uint8_t src_slave_addr;
-};
-
 #define PWR_SEQ_TIMEOUT    3000u
 
 /* The devicetree node identifier for the board power rails pins. */
@@ -74,8 +57,10 @@ static struct espi_callback espi_bus_cb;
 static struct espi_callback vw_rdy_cb;
 static struct espi_callback vw_cb;
 static struct espi_callback p80_cb;
-
 static uint8_t espi_rst_sts;
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+static struct espi_callback oob_cb;
+#endif
 
 #ifdef CONFIG_ESPI_FLASH_CHANNEL
 static uint8_t flash_write_buf[MAX_TEST_BUF_SIZE];
@@ -226,6 +211,10 @@ int espi_init(void)
 			   ESPI_BUS_EVENT_VWIRE_RECEIVED);
 	espi_init_callback(&p80_cb, periph_handler,
 			   ESPI_BUS_PERIPHERAL_NOTIFICATION);
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+			   espi_init_callback(&oob_cb, oob_rx_handler,
+			   ESPI_BUS_EVENT_OOB_RECEIVED);
+#endif
 	LOG_INF("complete");
 
 	LOG_INF("eSPI test - callbacks registration... ");
@@ -233,6 +222,9 @@ int espi_init(void)
 	espi_add_callback(espi_dev, &vw_rdy_cb);
 	espi_add_callback(espi_dev, &vw_cb);
 	espi_add_callback(espi_dev, &p80_cb);
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	espi_add_callback(espi_dev, &oob_cb);
+#endif
 	LOG_INF("complete");
 
 	return ret;
@@ -479,53 +471,6 @@ static int espi_flash_test(uint32_t start_flash_addr, uint8_t blocks)
 }
 #endif /* CONFIG_ESPI_FLASH_CHANNEL */
 
-int get_pch_temp(const struct device *dev, int *temp)
-{
-	struct espi_oob_packet req_pckt;
-	struct espi_oob_packet resp_pckt;
-	struct oob_header oob_hdr;
-	uint8_t buf[MAX_RESP_SIZE];
-	int ret;
-
-	LOG_INF("%s", __func__);
-
-	oob_hdr.dest_slave_addr = DEST_SLV_ADDR;
-	oob_hdr.oob_cmd_code = OOB_CMDCODE;
-	oob_hdr.byte_cnt = 1;
-	oob_hdr.src_slave_addr = SRC_SLV_ADDR;
-
-	/* Packetize OOB request */
-	req_pckt.buf = (uint8_t *)&oob_hdr;
-	req_pckt.len = sizeof(struct oob_header);
-	resp_pckt.buf = (uint8_t *)&buf;
-	resp_pckt.len = MAX_RESP_SIZE;
-
-	ret = espi_send_oob(dev, &req_pckt);
-	if (ret) {
-		LOG_ERR("OOB Tx failed %d", ret);
-		return ret;
-	}
-
-	ret = espi_receive_oob(dev, &resp_pckt);
-	if (ret) {
-		LOG_ERR("OOB Rx failed %d", ret);
-		return ret;
-	}
-
-	LOG_INF("OOB transaction completed rcvd: %d bytes", resp_pckt.len);
-	for (int i = 0; i < resp_pckt.len; i++) {
-		LOG_INF("%x ", buf[i]);
-	}
-
-	if (resp_pckt.len == OOB_RESPONSE_LEN) {
-		*temp = buf[OOB_RESPONSE_INDEX];
-	} else {
-		LOG_ERR("Incorrect size response");
-	}
-
-	return 0;
-}
-
 #ifndef CONFIG_ESPI_AUTOMATIC_BOOT_DONE_ACKNOWLEDGE
 static void send_slave_bootdone(void)
 {
@@ -674,16 +619,13 @@ int espi_test(void)
 	/*  Attempt to use OOB channel to read temperature, regardless of
 	 * if is enabled or not.
 	 */
-	for (int i = 0; i < MIN_GET_TEMP_CYCLES; i++) {
-		int temp;
-
-		ret = get_pch_temp(espi_dev, &temp);
-		if (ret)  {
-			LOG_ERR("eSPI OOB transaction failed %d", ret);
-		} else {
-			LOG_INF("Temp: %d ", temp);
-		}
-	}
+#ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	/* System without host-initiated OOB Rx traffic */
+	get_pch_temp_sync(espi_dev);
+#else
+	/* System with host-initiated OOB Rx traffic */
+	get_pch_temp_async(espi_dev);
+#endif
 
 	/* Cleanup */
 	k_sleep(K_SECONDS(1));
-- 
2.17.1


From 056f11f929a75eaa1ca37216b28625d446b73804 Mon Sep 17 00:00:00 2001
From: Diwakar C <diwakar.c@intel.com>
Date: Mon, 30 Nov 2020 19:37:08 +0530
Subject: [PATCH 07/36] driver: peci: Add supported peci response codes

Add supported peci response codes 0x80 (Out of resources timeout)
0x81 (Resources required to service cmd are in low power state).

HSD: https://hsdes.intel.com/appstore/article/#/16012004157.

Signed-off-by: Diwakar C <diwakar.c@intel.com>
---
 include/drivers/peci.h | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/include/drivers/peci.h b/include/drivers/peci.h
index c8155da1ff..b4d134b95e 100644
--- a/include/drivers/peci.h
+++ b/include/drivers/peci.h
@@ -65,9 +65,11 @@ enum peci_command_code {
 };
 
 /** PECI read/write supported responses */
-#define PECI_RW_PKG_CFG_RSP_PASS       (0x40U)
-#define PECI_RW_PKG_CFG_RSP_TIMEOUT    (0x80U)
-#define PECI_RW_PKG_CFG_RSP_ILLEGAL    (0x90U)
+#define PECI_CC_RSP_SUCCESS              (0x40U)
+#define PECI_CC_RSP_TIMEOUT              (0x80U)
+#define PECI_CC_OUT_OF_RESOURCES_TIMEOUT (0x81U)
+#define PECI_CC_RESOURCES_LOWPWR_TIMEOUT (0x82U)
+#define PECI_CC_ILLEGAL_REQUEST          (0x90U)
 
 /** Ping command format. */
 #define PECI_PING_WR_LEN               (0U)
-- 
2.17.1


From e1b612c3ce055844729f8799663d04678b2bd5b6 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Wed, 30 Dec 2020 14:20:40 -0800
Subject: [PATCH 08/36] drivers: peci: xec: Handle corner case for PECI
 recovery

Handle case where PECI recovery occurs in ISR context.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/peci/peci_mchp_xec.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/drivers/peci/peci_mchp_xec.c b/drivers/peci/peci_mchp_xec.c
index a124e9c307..34724df3b2 100644
--- a/drivers/peci/peci_mchp_xec.c
+++ b/drivers/peci/peci_mchp_xec.c
@@ -17,6 +17,7 @@ LOG_MODULE_REGISTER(peci_mchp_xec, CONFIG_PECI_LOG_LEVEL);
 #define MAX_PECI_CORE_CLOCK 48000u
 /* 1 ms */
 #define PECI_RESET_DELAY    1000u
+#define PECI_RESET_DELAY_MS 1u
 /* 100 us */
 #define PECI_IDLE_DELAY     100u
 /* 5 ms */
@@ -133,7 +134,13 @@ static void peci_xec_bus_recovery(const struct device *dev, bool full_reset)
 	LOG_WRN("%s full_reset:%d", __func__, full_reset);
 	if (full_reset) {
 		base->CONTROL = MCHP_PECI_CTRL_PD | MCHP_PECI_CTRL_RST;
-		k_busy_wait(PECI_RESET_DELAY);
+
+		if (k_is_in_isr()) {
+			k_msleep(PECI_RESET_DELAY_MS);
+		} else {
+			k_busy_wait(PECI_RESET_DELAY);
+		}
+
 		base->CONTROL &= ~MCHP_PECI_CTRL_RST;
 
 		peci_xec_configure(dev, peci_data.bitrate);
@@ -362,7 +369,7 @@ static int peci_xec_init(const struct device *dev)
 
 	/* Reset PECI interface */
 	base->CONTROL |= MCHP_PECI_CTRL_RST;
-	k_busy_wait(PECI_RESET_DELAY);
+	k_msleep(PECI_RESET_DELAY_MS);
 	base->CONTROL &= ~MCHP_PECI_CTRL_RST;
 
 #ifdef CONFIG_PECI_INTERRUPT_DRIVEN
-- 
2.17.1


From 787ab739af747797d5384bd8fcec4f88dc6dd9f6 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Wed, 27 Jan 2021 19:18:55 +0530
Subject: [PATCH 09/36] drivers: pwm: xec: Add pwm led capability

Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 dts/bindings/pwm/microchip,xec-pwm.yaml | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dts/bindings/pwm/microchip,xec-pwm.yaml b/dts/bindings/pwm/microchip,xec-pwm.yaml
index 630b4a3129..4a292968fb 100644
--- a/dts/bindings/pwm/microchip,xec-pwm.yaml
+++ b/dts/bindings/pwm/microchip,xec-pwm.yaml
@@ -13,3 +13,9 @@ properties:
 
     label:
       required: true
+
+    "#pwm-cells":
+      const: 1
+
+pwm-cells:
+  - channel
-- 
2.17.1


From 7b4da319adcc7c8020eb5ccbc261cfbd2e17ee12 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Sun, 31 Jan 2021 23:03:22 +0530
Subject: [PATCH 10/36] peci: driver: Wait until rx fifo gets filled up
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

While running RdIaMsr peci cmd, observed when FW attempts to
read last byte (Response FCS), PECI host controller returned
“Read FIFO” empty. Since “Read FIFO” is empty FW didn’t read
response FCS. Due to this issue, FW getting corrupted response
from PECI controller for all the subsequent PECI commands.

Next GetTemp call from thermal thread, resulting in corrupted
response values (mapping to huge temperature number 200+ degC)
from SOC. Since EC observing temp > 103 degC, EC is triggering
shutdown.

To address this issue, FW waits for “Read FIFO” to be filled-up
by the PECI controller.

HSD: https://hsdes.intel.com/appstore/article/#/16012457215.

Signed-off-by: Diwakar C <diwakar.c@intel.com>
---
 drivers/peci/peci_mchp_xec.c | 40 +++++++++++++++++++++++-------------
 1 file changed, 26 insertions(+), 14 deletions(-)

diff --git a/drivers/peci/peci_mchp_xec.c b/drivers/peci/peci_mchp_xec.c
index 34724df3b2..b3e7093645 100644
--- a/drivers/peci/peci_mchp_xec.c
+++ b/drivers/peci/peci_mchp_xec.c
@@ -24,6 +24,8 @@ LOG_MODULE_REGISTER(peci_mchp_xec, CONFIG_PECI_LOG_LEVEL);
 #define PECI_IDLE_TIMEOUT   50u
 /* Maximum retries */
 #define PECI_TIMEOUT_RETRIES 3u
+/* Maximum read buffer fill wait retries */
+#define PECI_RX_BUF_FILL_WAIT_RETRY 100u
 
 /* 10 us */
 #define PECI_IO_DELAY       10
@@ -230,28 +232,38 @@ static int peci_xec_read(const struct device *dev, struct peci_msg *msg)
 	int ret;
 	uint8_t tx_fcs;
 	uint8_t bytes_rcvd;
+	uint8_t wait_timeout_cnt;
 	struct peci_buf *rx_buf = &msg->rx_buffer;
 	PECI_Type *base = peci_xec_config.base;
 
 	/* Attempt to read data from RX FIFO */
 	bytes_rcvd = 0;
 	for (i = 0; i < (rx_buf->len + PECI_FCS_LEN); i++) {
-		/* Check if data available */
-		if (!(base->STATUS2 & MCHP_PECI_STS2_RFE)) {
-			if (i == 0) {
-				/* Get write block FCS just for debug */
-				tx_fcs = base->RD_DATA;
-				LOG_DBG("TX FCS %x", tx_fcs);
-			} else if (i == (rx_buf->len + 1)) {
-				/* Get read block FCS, but don't count it */
-				rx_buf->buf[i-1] = base->RD_DATA;
-			} else {
-				/* Get response */
-				rx_buf->buf[i-1] = base->RD_DATA;
-				bytes_rcvd++;
+		/* Worst case timeout will be 1msec (100 * 10usec) */
+		wait_timeout_cnt = PECI_RX_BUF_FILL_WAIT_RETRY;
+		/* Wait for read buffer to fill up */
+		while (base->STATUS2 & MCHP_PECI_STS2_RFE) {
+			k_usleep(PECI_IO_DELAY);
+			wait_timeout_cnt--;
+			if (!wait_timeout_cnt) {
+				LOG_WRN("Rx buffer empty");
+				return -ETIMEDOUT;
 			}
 		}
-	}
+
+		if (i == 0) {
+			/* Get write block FCS just for debug */
+			tx_fcs = base->RD_DATA;
+			LOG_DBG("TX FCS %x", tx_fcs);
+		} else if (i == (rx_buf->len + 1)) {
+			/* Get read block FCS, but don't count it */
+			rx_buf->buf[i-1] = base->RD_DATA;
+		} else {
+			/* Get response */
+			rx_buf->buf[i-1] = base->RD_DATA;
+			bytes_rcvd++;
+		}
+ 	}
 
 	/* Check if transaction is as expected */
 	if (rx_buf->len != bytes_rcvd) {
-- 
2.17.1


From c7105cb437e7d98905c35cc3632e2704974d06ba Mon Sep 17 00:00:00 2001
From: Diwakar C <diwakar.c@intel.com>
Date: Wed, 27 Jan 2021 01:07:58 +0530
Subject: [PATCH 11/36] peci: driver: Reset Tx/Rx FIFOs after every successful
 peci tx

In the current implementation, FW reads FCS only for the commands
having read_len > 1. But PECI host controller (EC HW) expects, for
all commands (including Ping) either FW should read FCS or reset
Tx/Rx FIFOs for every successful transaction.

In case of Ping command, PECI controller reads FCS from SOC and
expected FW to read but FW didn't read since Ping have read_len=0.
Due to this issue, FW getting corrupted response from PECI controller
for all the subsequent PECI commands.

Next GetTemp call from thermal thread, resulting in corrupted response
values (mapping to huge temperature number 200+ degC) from SOC. Since
EC observing temperature > 103 degC, EC is triggering shutdown.

To address this issue, FW resets Tx/Rx FIFOs after every successful
transaction.

HSD: https://hsdes.intel.com/appstore/article/#/16012457215.

Signed-off-by: Diwakar C <diwakar.c@intel.com>
---
 drivers/peci/peci_mchp_xec.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/peci/peci_mchp_xec.c b/drivers/peci/peci_mchp_xec.c
index b3e7093645..1022ceb83d 100644
--- a/drivers/peci/peci_mchp_xec.c
+++ b/drivers/peci/peci_mchp_xec.c
@@ -337,6 +337,9 @@ static int peci_xec_transfer(const struct device *dev, struct peci_msg *msg)
 		return -EIO;
 	}
 
+	/* Reset Tx/Rx FIFO for successsful peci transactions */
+	peci_xec_bus_recovery(dev, false);
+
 	return 0;
 }
 
-- 
2.17.1


From 9186a860fc0f9c8dc3b179149a9f883a589cf011 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Sun, 31 Jan 2021 23:20:44 +0530
Subject: [PATCH 12/36] Revert "boards: mec1501modular: build without image gen
 tool"

This reverts commit 209e4ee1a14a86ab03b6c32bec2f56412f43d068.
It breaks the "spi_gen utility find" functionality.
---
 boards/arm/mec1501modular_assy6885/CMakeLists.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/boards/arm/mec1501modular_assy6885/CMakeLists.txt b/boards/arm/mec1501modular_assy6885/CMakeLists.txt
index f96a887b05..7b0c4c7898 100644
--- a/boards/arm/mec1501modular_assy6885/CMakeLists.txt
+++ b/boards/arm/mec1501modular_assy6885/CMakeLists.txt
@@ -24,7 +24,7 @@ else()
     set(EVERGLADES_SPI_GEN_FILENAME everglades_spi_gen.exe)
   endif()
 
-  find_file(EVERGLADES_SPI_GEN_FINDFILE ${EVERGLADES_SPI_GEN_FILENAME} NO_DEFAULT_PATH)
+  find_file(EVERGLADES_SPI_GEN_FINDFILE ${EVERGLADES_SPI_GEN_FILENAME})
   if(EVERGLADES_SPI_GEN_FINDFILE STREQUAL EVERGLADES_SPI_GEN_FINDFILE-NOTFOUND)
     message(WARNING "Microchip SPI Image Generation tool (${EVERGLADES_SPI_GEN_FILENAME}) is not available. SPI Image will not be generated.")
   else()
-- 
2.17.1


From a5e2613aa8482b25eb8d224b2c65694d989ce906 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 1 Feb 2021 10:11:17 -0800
Subject: [PATCH 13/36] soc: arm: mchp: Remove magic numbers

Add SoC MEC150x device ID macros.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 soc/arm/microchip_mec/mec1501/soc.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/soc/arm/microchip_mec/mec1501/soc.c b/soc/arm/microchip_mec/mec1501/soc.c
index a315ef1dd0..10f34bde7f 100644
--- a/soc/arm/microchip_mec/mec1501/soc.c
+++ b/soc/arm/microchip_mec/mec1501/soc.c
@@ -11,6 +11,9 @@
 #include <arch/cpu.h>
 #include <arch/arm/aarch32/cortex_m/cmsis.h>
 
+/* MEC devices IDs with special PLL handling */
+#define MCHP_GCFG_DID_DEV_ID_MEC150x    0x0020U
+#define MCHP_TRIM_ENABLE_INT_OSCILLATOR 0x06U
 
 /*
  * Make sure PCR sleep enables are clear except for crypto
@@ -79,9 +82,9 @@ static int soc_clk32_init(void)
 	/* Use internal 32KHz +/-2% silicon oscillator
 	 * if required performed OTP value override
 	 */
-	if (MCHP_DEVICE_ID() == 0x0020U) { /* MEC150x ? */
+	if (MCHP_DEVICE_ID() == MCHP_GCFG_DID_DEV_ID_MEC150x) {
 		if (MCHP_REVISION_ID() == MCHP_GCFG_REV_B0) {
-			VBATR_REGS->CKK32_TRIM = 0x06U;
+			VBATR_REGS->CKK32_TRIM = MCHP_TRIM_ENABLE_INT_OSCILLATOR;
 		}
 	}
 
-- 
2.17.1


From e587a6ab82b2409a1685cd222893b2ab5384d424 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 2 Mar 2021 10:24:07 -0800
Subject: [PATCH 14/36] drivers: i2c: mchp: Restore I2C logging control

Fix CONFIG_I2C_LOG_LEVEL_XXX were not having effect.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/i2c/i2c_mchp_xec.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 296192a39e..c06b47d62e 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -12,7 +12,7 @@
 #include <errno.h>
 #include <drivers/i2c.h>
 #include <logging/log.h>
-LOG_MODULE_REGISTER(i2c_mchp);
+LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
 
 #define SPEED_100KHZ_BUS    0
 #define SPEED_400KHZ_BUS    1
-- 
2.17.1


From f97e95000d7787cdc85f40617a255a376916f7e0 Mon Sep 17 00:00:00 2001
From: Scott Worley <scott.worley@microchip.com>
Date: Mon, 9 Nov 2020 12:06:22 -0500
Subject: [PATCH 15/36] drivers: espi: Microchip eSPI add SAF support

Add ESPI SAF features to the Microchip eSPI driver as
a separate file. ESPI SAF depends upon the core eSPI
driver adding the ability to attach the system SPI
flash to the EC eSPI endpoint instead of the host
eSPI controller.

Signed-off-by: Scott Worley <scott.worley@microchip.com>
---
 drivers/espi/CMakeLists.txt                   |   1 +
 drivers/espi/Kconfig.xec                      |  15 +
 drivers/espi/espi_saf_mchp_xec.c              | 878 ++++++++++++++++++
 dts/arm/microchip/mec1501hsz.dtsi             |  11 +
 dts/bindings/espi/microchip,xec-espi-saf.yaml |  44 +
 include/drivers/espi_saf.h                    | 523 +++++++++++
 soc/arm/microchip_mec/common/soc_espi_saf.h   | 407 ++++++++
 soc/arm/microchip_mec/mec1501/soc.h           |   1 +
 8 files changed, 1880 insertions(+)
 create mode 100644 drivers/espi/espi_saf_mchp_xec.c
 create mode 100644 dts/bindings/espi/microchip,xec-espi-saf.yaml
 create mode 100644 include/drivers/espi_saf.h
 create mode 100644 soc/arm/microchip_mec/common/soc_espi_saf.h

diff --git a/drivers/espi/CMakeLists.txt b/drivers/espi/CMakeLists.txt
index 601462a55e..f48f8318cb 100644
--- a/drivers/espi/CMakeLists.txt
+++ b/drivers/espi/CMakeLists.txt
@@ -7,3 +7,4 @@ zephyr_library_sources_ifdef(CONFIG_ESPI_NPCX           espi_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_NPCX           host_subs_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_USERSPACE           espi_handlers.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_EMUL           espi_emul.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_SAF		espi_saf_mchp_xec.c)
diff --git a/drivers/espi/Kconfig.xec b/drivers/espi/Kconfig.xec
index e7a7565e83..debbc921bd 100644
--- a/drivers/espi/Kconfig.xec
+++ b/drivers/espi/Kconfig.xec
@@ -37,4 +37,19 @@ config ESPI_PERIPHERAL_UART_SOC_MAPPING
 	  This tells the driver to which SoC UART to direct the UART traffic
 	  send over eSPI from host.
 
+config ESPI_SAF
+	bool "XEC Microchip ESPI SAF driver"
+	depends on ESPI_FLASH_CHANNEL
+	default n
+	help
+	  Enable Slave Attached Flash eSPI driver. SAF depends upon ESPI XEC driver
+	  and flash channel.
+
+config ESPI_SAF_INIT_PRIORITY
+	int "ESPI SAF driver initialization priority"
+	depends on ESPI_SAF
+	default 4
+	help
+	  Driver initialization priority for eSPI SAF driver.
+
 endif #ESPI_XEC
diff --git a/drivers/espi/espi_saf_mchp_xec.c b/drivers/espi/espi_saf_mchp_xec.c
new file mode 100644
index 0000000000..d5545a4382
--- /dev/null
+++ b/drivers/espi/espi_saf_mchp_xec.c
@@ -0,0 +1,878 @@
+/*
+ * Copyright (c) 2019 Intel Corporation
+ * Copyright (c) 2020 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT microchip_xec_espi_saf
+
+#include <kernel.h>
+#include <soc.h>
+#include <errno.h>
+#include <drivers/espi.h>
+#include <drivers/espi_saf.h>
+#include <logging/log.h>
+
+#include "espi_utils.h"
+LOG_MODULE_REGISTER(espi_saf, CONFIG_ESPI_LOG_LEVEL);
+
+/* SAF EC Portal read/write flash access limited to 1-64 bytes */
+#define MAX_SAF_ECP_BUFFER_SIZE 64ul
+
+/* 1 second maximum for flash operations */
+#define MAX_SAF_FLASH_TIMEOUT 125000ul /* 1000ul */
+
+/* 64 bytes @ 24MHz quad is approx. 6 us */
+#define SAF_WAIT_INTERVAL 8
+
+/* After 8 wait intervals yield */
+#define SAF_YIELD_THRESHOLD 64
+
+struct espi_isr {
+	uint32_t girq_bit;
+	void (*the_isr)(const struct device *dev);
+};
+
+/*
+ * SAF configuration from Device Tree
+ * SAF controller register block base address
+ * QMSPI controller register block base address
+ * SAF communications register block base address
+ * Flash STATUS1 poll timeout in 32KHz periods
+ * Flash consecutive read timeout in units of 20 ns
+ * Delay before first Poll-1 command after suspend in 20 ns units
+ * Hold off suspend for this interval if erase or program in 32KHz periods.
+ * Add delay between Poll STATUS1 commands in 20 ns units.
+ */
+struct espi_saf_xec_config {
+	uintptr_t saf_base_addr;
+	uintptr_t qmspi_base_addr;
+	uintptr_t saf_comm_base_addr;
+	uint32_t poll_timeout;
+	uint32_t consec_rd_timeout;
+	uint32_t sus_chk_delay;
+	uint16_t sus_rsm_interval;
+	uint16_t poll_interval;
+};
+
+struct espi_saf_xec_data {
+	sys_slist_t callbacks;
+	struct k_sem ecp_lock;
+	uint32_t hwstatus;
+};
+
+/* convenience defines */
+#define DEV_CFG(dev) ((const struct espi_saf_xec_config *const)(dev)->config)
+#define DEV_DATA(dev) ((struct espi_saf_xec_data *const)(dev)->data)
+
+/* EC portal local flash r/w buffer */
+static uint32_t slave_mem[MAX_SAF_ECP_BUFFER_SIZE];
+
+/*
+ * @brief eSPI SAF configuration
+ */
+
+static inline void mchp_saf_cs_descr_wr(MCHP_SAF_HW_REGS *regs, uint8_t cs,
+					uint32_t val)
+{
+	regs->SAF_CS_OP[cs].OP_DESCR = val;
+}
+
+static inline void mchp_saf_poll2_mask_wr(MCHP_SAF_HW_REGS *regs, uint8_t cs,
+					  uint16_t val)
+{
+	LOG_DBG("%s cs: %d mask %x", __func__, cs, val);
+	if (cs == 0) {
+		regs->SAF_CS0_CFG_P2M = val;
+	} else {
+		regs->SAF_CS1_CFG_P2M = val;
+	}
+}
+
+static inline void mchp_saf_cm_prefix_wr(MCHP_SAF_HW_REGS *regs, uint8_t cs,
+					 uint16_t val)
+{
+	if (cs == 0) {
+		regs->SAF_CS0_CM_PRF = val;
+	} else {
+		regs->SAF_CS1_CM_PRF = val;
+	}
+}
+
+/* busy wait or yield until we have SAF interrupt support */
+static int xec_saf_spin_yield(int *counter)
+{
+	*counter = *counter + 1;
+
+	if (*counter > MAX_SAF_FLASH_TIMEOUT) {
+		return -ETIMEDOUT;
+	}
+
+	if (*counter > SAF_YIELD_THRESHOLD) {
+		k_yield();
+	} else {
+		k_busy_wait(SAF_WAIT_INTERVAL);
+	}
+
+	return 0;
+}
+
+/*
+ * Initialize SAF flash protection regions.
+ * SAF HW implements 17 protection regions.
+ * At least one protection region must be configured to allow
+ * EC access to the local flash through the EC Portal.
+ * Each protection region is composed of 4 32-bit registers
+ * Start bits[19:0] = bits[31:12] region start address (4KB boundaries)
+ * Limit bits[19:0] = bits[31:12] region limit address (4KB boundaries)
+ * Write protect b[7:0] = masters[7:0] allow write/erase. 1=allowed
+ * Read protetc b[7:0] = masters[7:0] allow read. 1=allowed
+ *
+ * This routine configures protection region 0 for full flash array
+ * address range and read-write-erase for all masters.
+ * This routine must be called AFTER the flash configuration size/limit and
+ * threshold registers have been programmed.
+ *
+ * POR default values:
+ * Start = 0x7ffff
+ * Limit = 0
+ * Write Prot = 0x01 Master 0 always granted write/erase
+ * Read Prot = 0x01 Master 0 always granted read
+ *
+ * Sample code configures PR[0]
+ * Start = 0
+ * Limit = 0x7ffff
+ * WR = 0xFF
+ * RD = 0xFF
+ */
+static void saf_protection_regions_init(MCHP_SAF_HW_REGS *regs)
+{
+	LOG_DBG("%s", __func__);
+
+	for (size_t n = 0; n < MCHP_ESPI_SAF_PR_MAX; n++) {
+		if (n == 0) {
+			regs->SAF_PROT_RG[0].START = 0U;
+			regs->SAF_PROT_RG[0].LIMIT =
+				regs->SAF_FL_CFG_SIZE_LIM >> 12;
+			regs->SAF_PROT_RG[0].WEBM = MCHP_SAF_MSTR_ALL;
+			regs->SAF_PROT_RG[0].RDBM = MCHP_SAF_MSTR_ALL;
+		} else {
+			regs->SAF_PROT_RG[n].START =
+				MCHP_SAF_PROT_RG_START_DFLT;
+			regs->SAF_PROT_RG[n].LIMIT =
+				MCHP_SAF_PROT_RG_LIMIT_DFLT;
+			regs->SAF_PROT_RG[n].WEBM = 0U;
+			regs->SAF_PROT_RG[n].RDBM = 0U;
+		}
+
+		LOG_DBG("PROT[%d] START %x", n, regs->SAF_PROT_RG[n].START);
+		LOG_DBG("PROT[%d] LIMIT %x", n, regs->SAF_PROT_RG[n].LIMIT);
+		LOG_DBG("PROT[%d] WEBM %x", n, regs->SAF_PROT_RG[n].WEBM);
+		LOG_DBG("PROT[%d] RDBM %x", n, regs->SAF_PROT_RG[n].RDBM);
+	}
+}
+
+static uint32_t qmspi_freq_div(uint32_t freqhz)
+{
+	uint32_t fdiv;
+
+	if (freqhz < (MCHP_QMSPI_MIN_FREQ_KHZ * 1000U)) {
+		fdiv = 0U; /* freq divider field -> 256 */
+	} else if (freqhz >= (MCHP_QMSPI_MAX_FREQ_KHZ * 1000U)) {
+		fdiv = 1U;
+	} else {
+		/* truncation produces next higher integer frequency */
+		fdiv = MCHP_QMSPI_INPUT_CLOCK_FREQ_HZ / freqhz;
+	}
+
+	fdiv &= MCHP_QMSPI_M_FDIV_MASK0;
+	fdiv <<= MCHP_QMSPI_M_FDIV_POS;
+
+	return fdiv;
+}
+
+/*
+ * Take over and re-initialize QMSPI for use by SAF HW engine.
+ * When SAF is activated, QMSPI registers are controlled by SAF
+ * HW engine. CPU no longer has access to QMSPI registers.
+ * 1. Save QMSPI driver frequency divider, SPI signalling mode, and
+ *    chip select timing.
+ * 2. Put QMSPI controller in a known state by performing a soft reset.
+ * 3. Clear QMSPI GIRQ status
+ * 4. Configure QMSPI interface control for SAF.
+ * 5. Load flash device independent (generic) descriptors.
+ * 6. Enable transfer done interrupt in QMSPI
+ * 7. Enable QMSPI SAF mode
+ * 8. If user configuration overrides frequency, signalling mode,
+ *    or chip select timing derive user values.
+ * 9. Program QMSPI MODE and CSTIM registers with activate set.
+ */
+static int saf_qmspi_init(const struct espi_saf_xec_config *xcfg,
+			  const struct espi_saf_cfg *cfg)
+{
+	uint32_t qmode, cstim, n;
+	QMSPI_Type *regs = (QMSPI_Type *)xcfg->qmspi_base_addr;
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	qmode = regs->MODE;
+	if (!(qmode & MCHP_QMSPI_M_ACTIVATE)) {
+		return -EAGAIN;
+	}
+
+	qmode = regs->MODE & (MCHP_QMSPI_M_FDIV_MASK | MCHP_QMSPI_M_SIG_MASK);
+	cstim = regs->CSTM;
+	regs->MODE = MCHP_QMSPI_M_SRST;
+	regs->STS = MCHP_QMSPI_STS_RW1C_MASK;
+
+	MCHP_GIRQ_ENCLR(MCHP_QMSPI_GIRQ_NUM) = MCHP_QMSPI_GIRQ_VAL;
+	MCHP_GIRQ_SRC(MCHP_QMSPI_GIRQ_NUM) = MCHP_QMSPI_GIRQ_VAL;
+
+	regs->IFCTRL =
+		(MCHP_QMSPI_IFC_WP_OUT_HI | MCHP_QMSPI_IFC_WP_OUT_EN |
+		 MCHP_QMSPI_IFC_HOLD_OUT_HI | MCHP_QMSPI_IFC_HOLD_OUT_EN);
+
+	for (n = 0; n < MCHP_SAF_NUM_GENERIC_DESCR; n++) {
+		regs->DESCR[MCHP_SAF_CM_EXIT_START_DESCR + n] =
+			hwcfg->generic_descr[n];
+	}
+
+	regs->IEN = MCHP_QMSPI_IEN_XFR_DONE;
+
+	qmode |= (MCHP_QMSPI_M_SAF_DMA_MODE_EN | MCHP_QMSPI_M_CS0 |
+		  MCHP_QMSPI_M_ACTIVATE);
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_CPHA) {
+		qmode = (qmode & ~(MCHP_QMSPI_M_SIG_MASK)) |
+			((hwcfg->qmspi_cpha << MCHP_QMSPI_M_SIG_POS) &
+			 MCHP_QMSPI_M_SIG_MASK);
+	}
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_FREQ) {
+		qmode = (qmode & ~(MCHP_QMSPI_M_FDIV_MASK)) |
+			qmspi_freq_div(hwcfg->qmspi_freq_hz);
+	}
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_CSTM) {
+		cstim = hwcfg->qmspi_cs_timing;
+	}
+
+	regs->MODE = qmode;
+	regs->CSTM = cstim;
+
+	return 0;
+}
+
+/*
+ * Registers at offsets:
+ * SAF Poll timeout @ 0x194.  Hard coded to 0x28000. Default value = 0.
+ *	recommended value = 0x28000 32KHz clocks (5 seconds). b[17:0]
+ * SAF Poll interval @ 0x198.  Hard coded to 0
+ *	Default value = 0. Recommended = 0. b[15:0]
+ * SAF Suspend/Resume Interval @ 0x19c.  Hard coded to 0x8
+ *	Default value = 0x01. Min time erase/prog in 32KHz units.
+ * SAF Consecutive Read Timeout @ 0x1a0. Hard coded to 0x2. b[15:0]
+ *	Units of MCLK. Recommend < 20us. b[19:0]
+ * SAF Suspend Check Delay @ 0x1ac. Not touched.
+ *	Default = 0. Recommend = 20us. Units = MCLK. b[19:0]
+ */
+static void saf_flash_timing_init(MCHP_SAF_HW_REGS *regs,
+				  const struct espi_saf_xec_config *cfg)
+{
+	LOG_DBG("%s\n", __func__);
+	regs->SAF_POLL_TMOUT = cfg->poll_timeout;
+	regs->SAF_POLL_INTRVL = cfg->poll_interval;
+	regs->SAF_SUS_RSM_INTRVL = cfg->sus_rsm_interval;
+	regs->SAF_CONSEC_RD_TMOUT = cfg->consec_rd_timeout;
+	regs->SAF_SUS_CHK_DLY = cfg->sus_chk_delay;
+	LOG_DBG("SAF_POLL_TMOUT %x\n", regs->SAF_POLL_TMOUT);
+	LOG_DBG("SAF_POLL_INTRVL %x\n", regs->SAF_POLL_INTRVL);
+	LOG_DBG("SAF_SUS_RSM_INTRVL %x\n", regs->SAF_SUS_RSM_INTRVL);
+	LOG_DBG("SAF_CONSEC_RD_TMOUT %x\n", regs->SAF_CONSEC_RD_TMOUT);
+	LOG_DBG("SAF_SUS_CHK_DLY %x\n", regs->SAF_SUS_CHK_DLY);
+}
+
+/*
+ * Disable DnX bypass feature.
+ */
+static void saf_dnx_bypass_init(MCHP_SAF_HW_REGS *regs)
+{
+	regs->SAF_DNX_PROT_BYP = 0;
+	regs->SAF_DNX_PROT_BYP = 0xffffffff;
+}
+
+/*
+ * Bitmap of flash erase size from 1KB up to 128KB.
+ * eSPI SAF specification requires 4KB erase support.
+ * MCHP SAF supports 4KB, 32KB, and 64KB.
+ * Only report 32KB and 64KB to Host if supported by both
+ * flash devices.
+ */
+static int saf_init_erase_block_size(const struct espi_saf_cfg *cfg)
+{
+	struct espi_saf_flash_cfg *fcfg = cfg->flash_cfgs;
+	uint32_t opb = fcfg->opb;
+	uint8_t erase_bitmap = MCHP_ESPI_SERASE_SZ_4K;
+
+	LOG_DBG("%s\n", __func__);
+
+	if (cfg->nflash_devices > 1) {
+		fcfg++;
+		opb &= fcfg->opb;
+	}
+
+	if ((opb & MCHP_SAF_CS_OPB_ER0_MASK) == 0) {
+		/* One or both do not support 4KB erase! */
+		return -EINVAL;
+	}
+
+	if (opb & MCHP_SAF_CS_OPB_ER1_MASK) {
+		erase_bitmap |= MCHP_ESPI_SERASE_SZ_32K;
+	}
+
+	if (opb & MCHP_SAF_CS_OPB_ER2_MASK) {
+		erase_bitmap |= MCHP_ESPI_SERASE_SZ_64K;
+	}
+
+	ESPI_CAP_REGS->FC_SERBZ = erase_bitmap;
+
+	return 0;
+}
+
+/*
+ * Set the continuous mode prefix and 4-byte address mode bits
+ * based upon the flash configuration information.
+ * Updates:
+ * SAF Flash Config Poll2 Mask @ 0x1A4
+ * SAF Flash Config Special Mode @ 0x1B0
+ * SAF Flash Misc Config @ 0x38
+ */
+static void saf_flash_misc_cfg(MCHP_SAF_HW_REGS *regs, uint8_t cs,
+			       const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t d, v;
+
+	d = regs->SAF_FL_CFG_MISC;
+
+	v = MCHP_SAF_FL_CFG_MISC_CS0_CPE;
+	if (cs) {
+		v = MCHP_SAF_FL_CFG_MISC_CS1_CPE;
+	}
+
+	/* Does this flash device require a prefix for continuous mode? */
+	if (fcfg->cont_prefix != 0) {
+		d |= v;
+	} else {
+		d &= ~v;
+	}
+
+	v = MCHP_SAF_FL_CFG_MISC_CS0_4BM;
+	if (cs) {
+		v = MCHP_SAF_FL_CFG_MISC_CS1_4BM;
+	}
+
+	/* Use 32-bit addressing for this flash device? */
+	if (fcfg->flags & MCHP_FLASH_FLAG_ADDR32) {
+		d |= v;
+	} else {
+		d &= ~v;
+	}
+
+	regs->SAF_FL_CFG_MISC = d;
+	LOG_DBG("%s SAF_FL_CFG_MISC: %x", __func__, d);
+}
+
+/*
+ * Program flash device specific SAF and QMSPI registers.
+ *
+ * CS0 OpA @ 0x4c or CS1 OpA @ 0x5C
+ * CS0 OpB @ 0x50 or CS1 OpB @ 0x60
+ * CS0 OpC @ 0x54 or CS1 OpC @ 0x64
+ * Poll 2 Mask @ 0x1a4
+ * Continuous Prefix @ 0x1b0
+ * CS0: QMSPI descriptors 0-5 or CS1 QMSPI descriptors 6-11
+ * CS0 Descrs @ 0x58 or CS1 Descrs @ 0x68
+ */
+static void saf_flash_cfg(const struct device *dev,
+			  const struct espi_saf_flash_cfg *fcfg, uint8_t cs)
+{
+	uint32_t d, did;
+	const struct espi_saf_xec_config *xcfg = DEV_CFG(dev);
+	MCHP_SAF_HW_REGS *regs = (MCHP_SAF_HW_REGS *)xcfg->saf_base_addr;
+	QMSPI_Type *qregs = (QMSPI_Type *)xcfg->qmspi_base_addr;
+
+	LOG_DBG("%s cs=%u", __func__, cs);
+
+	regs->SAF_CS_OP[cs].OPA = fcfg->opa;
+	regs->SAF_CS_OP[cs].OPB = fcfg->opb;
+	regs->SAF_CS_OP[cs].OPC = fcfg->opc;
+	regs->SAF_CS_OP[cs].OP_DESCR = (uint32_t)fcfg->cs_cfg_descr_ids;
+
+	did = MCHP_SAF_QMSPI_CS0_START_DESCR;
+	if (cs != 0) {
+		did = MCHP_SAF_QMSPI_CS1_START_DESCR;
+	}
+
+	for (size_t i = 0; i < MCHP_SAF_QMSPI_NUM_FLASH_DESCR; i++) {
+		d = fcfg->descr[i] & ~(MCHP_QMSPI_C_NEXT_DESCR_MASK);
+		d |= (((did + 1) << MCHP_QMSPI_C_NEXT_DESCR_POS) &
+		      MCHP_QMSPI_C_NEXT_DESCR_MASK);
+		qregs->DESCR[did++] = d;
+	}
+
+	mchp_saf_poll2_mask_wr(regs, cs, fcfg->poll2_mask);
+	mchp_saf_cm_prefix_wr(regs, cs, fcfg->cont_prefix);
+	saf_flash_misc_cfg(regs, cs, fcfg);
+}
+
+static const uint32_t tag_map_dflt[MCHP_ESPI_SAF_TAGMAP_MAX] = {
+	MCHP_SAF_TAG_MAP0_DFLT, MCHP_SAF_TAG_MAP1_DFLT, MCHP_SAF_TAG_MAP2_DFLT
+};
+
+static void saf_tagmap_init(MCHP_SAF_HW_REGS *regs,
+			    const struct espi_saf_cfg *cfg)
+{
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	for (int i = 0; i < MCHP_ESPI_SAF_TAGMAP_MAX; i++) {
+		if (hwcfg->tag_map[i] & MCHP_SAF_HW_CFG_TAGMAP_USE) {
+			regs->SAF_TAG_MAP[i] = hwcfg->tag_map[i];
+		} else {
+			regs->SAF_TAG_MAP[i] = tag_map_dflt[i];
+		}
+	}
+
+	LOG_DBG("SAF TAG0 %x", regs->SAF_TAG_MAP[0]);
+	LOG_DBG("SAF TAG1 %x", regs->SAF_TAG_MAP[1]);
+	LOG_DBG("SAF TAG2 %x", regs->SAF_TAG_MAP[2]);
+}
+
+/*
+ * Configure SAF and QMSPI for SAF operation based upon the
+ * number and characteristics of local SPI flash devices.
+ * NOTE: SAF is configured but not activated. SAF should be
+ * activated only when eSPI master sends Flash Channel enable
+ * message with MAF/SAF select flag.
+ */
+static int espi_saf_xec_configuration(const struct device *dev,
+				      const struct espi_saf_cfg *cfg)
+{
+	int ret = 0;
+	uint32_t totalsz = 0;
+	uint32_t u = 0;
+
+	LOG_DBG("%s", __func__);
+
+	if ((dev == NULL) || (cfg == NULL)) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config *xcfg = DEV_CFG(dev);
+	MCHP_SAF_HW_REGS *regs = (MCHP_SAF_HW_REGS *)xcfg->saf_base_addr;
+	const struct espi_saf_flash_cfg *fcfg = cfg->flash_cfgs;
+
+	if ((fcfg == NULL) || (cfg->nflash_devices == 0U) ||
+	    (cfg->nflash_devices > MCHP_SAF_MAX_FLASH_DEVICES)) {
+		return -EINVAL;
+	}
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return -EAGAIN;
+	}
+
+	saf_qmspi_init(xcfg, cfg);
+
+	regs->SAF_CS0_CFG_P2M = 0;
+	regs->SAF_CS1_CFG_P2M = 0;
+
+	regs->SAF_FL_CFG_GEN_DESCR = MCHP_SAF_FL_CFG_GEN_DESCR_STD;
+
+	/* flash device connected to CS0 required */
+	totalsz = fcfg->flashsz;
+	regs->SAF_FL_CFG_THRH = totalsz;
+	saf_flash_cfg(dev, fcfg, 0);
+
+	/* optional second flash device connected to CS1 */
+	if (cfg->nflash_devices > 1) {
+		fcfg++;
+		totalsz += fcfg->flashsz;
+	}
+	/* Program CS1 configuration (same as CS0 if only one device) */
+	saf_flash_cfg(dev, fcfg, 1);
+
+	if (totalsz == 0) {
+		return -EAGAIN;
+	}
+
+	regs->SAF_FL_CFG_SIZE_LIM = totalsz - 1;
+
+	LOG_DBG("SAF_FL_CFG_THRH = %x SAF_FL_CFG_SIZE_LIM = %x",
+		regs->SAF_FL_CFG_THRH, regs->SAF_FL_CFG_SIZE_LIM);
+
+	saf_tagmap_init(regs, cfg);
+
+	saf_protection_regions_init(regs);
+
+	saf_dnx_bypass_init(regs);
+
+	saf_flash_timing_init(regs, xcfg);
+
+	ret = saf_init_erase_block_size(cfg);
+	if (ret != 0) {
+		LOG_ERR("SAF Config bad flash erase config");
+		return ret;
+	}
+
+	/* Default or expedited prefetch? */
+	u = MCHP_SAF_FL_CFG_MISC_PFOE_DFLT;
+	if (cfg->hwcfg.flags & MCHP_SAF_HW_CFG_FLAG_PFEXP) {
+		u = MCHP_SAF_FL_CFG_MISC_PFOE_EXP;
+	}
+
+	regs->SAF_FL_CFG_MISC =
+		(regs->SAF_FL_CFG_MISC & ~(MCHP_SAF_FL_CFG_MISC_PFOE_MASK)) | u;
+
+	/* enable prefetch ? */
+	if (cfg->hwcfg.flags & MCHP_SAF_HW_CFG_FLAG_PFEN) {
+		MCHP_SAF_COMM_MODE_REG |= MCHP_SAF_COMM_MODE_PF_EN;
+	} else {
+		MCHP_SAF_COMM_MODE_REG &= ~(MCHP_SAF_COMM_MODE_PF_EN);
+	}
+
+	LOG_DBG("%s SAF_FL_CFG_MISC: %x", __func__, regs->SAF_FL_CFG_MISC);
+	LOG_DBG("%s Aft MCHP_SAF_COMM_MODE_REG: %x", __func__,
+		MCHP_SAF_COMM_MODE_REG);
+
+	return 0;
+}
+
+static int espi_saf_xec_set_pr(const struct device *dev,
+			       const struct espi_saf_protection *pr)
+{
+	if ((dev == NULL) || (pr == NULL)) {
+		return -EINVAL;
+	}
+
+	if (pr->nregions >= MCHP_ESPI_SAF_PR_MAX) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config *xcfg = DEV_CFG(dev);
+	MCHP_SAF_HW_REGS *regs = (MCHP_SAF_HW_REGS *)xcfg->saf_base_addr;
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return -EAGAIN;
+	}
+
+	const struct espi_saf_pr *preg = pr->pregions;
+	size_t n = pr->nregions;
+
+	while (n--) {
+		uint8_t regnum = preg->pr_num;
+
+		if (regnum >= MCHP_ESPI_SAF_PR_MAX) {
+			return -EINVAL;
+		}
+
+		/* NOTE: If previously locked writes have no effect */
+		if (preg->flags & MCHP_SAF_PR_FLAG_ENABLE) {
+			regs->SAF_PROT_RG[regnum].START = preg->start >> 12U;
+			regs->SAF_PROT_RG[regnum].LIMIT =
+				(preg->start + preg->size - 1U) >> 12U;
+			regs->SAF_PROT_RG[regnum].WEBM = preg->master_bm_we;
+			regs->SAF_PROT_RG[regnum].RDBM = preg->master_bm_rd;
+		} else {
+			regs->SAF_PROT_RG[regnum].START = 0x7FFFFU;
+			regs->SAF_PROT_RG[regnum].LIMIT = 0U;
+			regs->SAF_PROT_RG[regnum].WEBM = 0U;
+			regs->SAF_PROT_RG[regnum].RDBM = 0U;
+		}
+
+		if (preg->flags & MCHP_SAF_PR_FLAG_LOCK) {
+			regs->SAF_PROT_LOCK |= (1UL << regnum);
+		}
+
+		preg++;
+	}
+
+	return 0;
+}
+
+static bool espi_saf_xec_channel_ready(const struct device *dev)
+{
+	const struct espi_saf_xec_config *cfg = DEV_CFG(dev);
+	MCHP_SAF_HW_REGS *regs = (MCHP_SAF_HW_REGS *)cfg->saf_base_addr;
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return true;
+	}
+
+	return false;
+}
+
+/*
+ * MCHP SAF hardware supports a range of flash block erase
+ * sizes from 1KB to 128KB. The eSPI Host specification requires
+ * 4KB must be supported. The MCHP SAF QMSPI HW interface only
+ * supported three erase sizes. Most SPI flash devices chosen for
+ * SAF support 4KB, 32KB, and 64KB.
+ * Get flash erase sizes driver has configured from eSPI capabilities
+ * registers. We assume driver flash tables have opcodes to match
+ * capabilities configuration.
+ * Check requested erase size is supported.
+ */
+struct erase_size_encoding {
+	uint8_t hwbitpos;
+	uint8_t encoding;
+};
+
+static const struct erase_size_encoding ersz_enc[] = {
+	{ MCHP_ESPI_SERASE_SZ_4K_BITPOS, 0 },
+	{ MCHP_ESPI_SERASE_SZ_32K_BITPOS, 1 },
+	{ MCHP_ESPI_SERASE_SZ_64K_BITPOS, 2 }
+};
+
+#define SAF_ERASE_ENCODING_MAX_ENTRY                                           \
+	(sizeof(ersz_enc) / sizeof(struct erase_size_encoding))
+
+static uint32_t get_erase_size_encoding(uint32_t erase_size)
+{
+	uint8_t supsz = ESPI_CAP_REGS->FC_SERBZ;
+
+	LOG_DBG("%s\n", __func__);
+	for (int i = 0; i < SAF_ERASE_ENCODING_MAX_ENTRY; i++) {
+		uint32_t sz = MCHP_ESPI_SERASE_SZ(ersz_enc[i].hwbitpos);
+
+		if ((sz == erase_size) &&
+		    (supsz & (1 << ersz_enc[i].hwbitpos))) {
+			return ersz_enc[i].encoding;
+		}
+	}
+
+	return 0xffffffffU;
+}
+
+static int check_ecp_access_size(uint32_t reqlen)
+{
+	if ((reqlen < MCHP_SAF_ECP_CMD_RW_LEN_MIN) ||
+	    (reqlen > MCHP_SAF_ECP_CMD_RW_LEN_MAX)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+/*
+ * EC access (read/erase/write) to SAF atttached flash array
+ * cmd  0 = read
+ *	1 = write
+ *	2 = erase
+ */
+static int saf_ecp_access(const struct device *dev,
+			  struct espi_saf_packet *pckt, uint8_t cmd)
+{
+	uint32_t err_mask, n;
+	int rc, counter;
+	struct espi_saf_xec_data *xdat = DEV_DATA(dev);
+	const struct espi_saf_xec_config *cfg = DEV_CFG(dev);
+	MCHP_SAF_HW_REGS *regs = (MCHP_SAF_HW_REGS *)cfg->saf_base_addr;
+
+	counter = 0;
+	err_mask = MCHP_SAF_ECP_STS_ERR_MASK;
+
+	LOG_DBG("%s", __func__);
+
+	if (!(regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN)) {
+		LOG_ERR("SAF is disabled");
+		return -EIO;
+	}
+
+	if (regs->SAF_ECP_BUSY & MCHP_SAF_ECP_BUSY) {
+		LOG_ERR("SAF EC Portal is busy");
+		return -EBUSY;
+	}
+
+	if ((cmd == MCHP_SAF_ECP_CMD_CTYPE_READ0) ||
+	    (cmd == MCHP_SAF_ECP_CMD_CTYPE_WRITE0)) {
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal size out of bounds");
+			return rc;
+		}
+
+		if (cmd == MCHP_SAF_ECP_CMD_CTYPE_WRITE0) {
+			memcpy(slave_mem, pckt->buf, pckt->len);
+		}
+
+		n = pckt->len;
+	} else if (cmd == MCHP_SAF_ECP_CMD_CTYPE_ERASE0) {
+		n = get_erase_size_encoding(pckt->len);
+		if (n == 0xffffffff) {
+			LOG_ERR("SAF EC Portal unsupported erase size");
+			return -EAGAIN;
+		}
+	} else {
+		LOG_ERR("SAF EC Portal bad cmd");
+		return -EAGAIN;
+	}
+
+	LOG_DBG("%s params val done", __func__);
+
+	k_sem_take(&xdat->ecp_lock, K_FOREVER);
+
+	regs->SAF_ECP_INTEN = 0;
+	regs->SAF_ECP_STATUS = 0xffffffff;
+
+	/*
+	 * TODO - Force SAF Done interrupt disabled until we have support
+	 * from eSPI driver.
+	 */
+	MCHP_GIRQ_ENCLR(MCHP_SAF_GIRQ) = MCHP_SAF_GIRQ_ECP_DONE_BIT;
+	MCHP_GIRQ_SRC(MCHP_SAF_GIRQ) = MCHP_SAF_GIRQ_ECP_DONE_BIT;
+
+	regs->SAF_ECP_FLAR = pckt->flash_addr;
+	regs->SAF_ECP_BFAR = (uint32_t)&slave_mem[0];
+
+	regs->SAF_ECP_CMD =
+		MCHP_SAF_ECP_CMD_PUT_FLASH_NP |
+		((uint32_t)cmd << MCHP_SAF_ECP_CMD_CTYPE_POS) |
+		((n << MCHP_SAF_ECP_CMD_LEN_POS) & MCHP_SAF_ECP_CMD_LEN_MASK);
+
+	/* TODO when interrupts are available enable here */
+	regs->SAF_ECP_START = MCHP_SAF_ECP_START;
+
+	/* TODO
+	 * ISR is in eSPI driver. Use polling until eSPI driver has been
+	 * modified to provide callback for GIRQ19 SAF ECP Done.
+	 */
+	rc = 0;
+	xdat->hwstatus = regs->SAF_ECP_STATUS;
+	while (!(xdat->hwstatus & MCHP_SAF_ECP_STS_DONE)) {
+		rc = xec_saf_spin_yield(&counter);
+		if (rc < 0) {
+			goto ecp_exit;
+		}
+		xdat->hwstatus = regs->SAF_ECP_STATUS;
+	}
+
+	/* clear hardware status and check for errors */
+	regs->SAF_ECP_STATUS = xdat->hwstatus;
+	if (xdat->hwstatus & MCHP_SAF_ECP_STS_ERR_MASK) {
+		rc = -EIO;
+		goto ecp_exit;
+	}
+
+	if (cmd == MCHP_SAF_ECP_CMD_CTYPE_READ0) {
+		memcpy(pckt->buf, slave_mem, pckt->len);
+	}
+
+ecp_exit:
+	k_sem_give(&xdat->ecp_lock);
+
+	return rc;
+}
+
+/* Flash read using SAF EC Portal */
+static int saf_xec_flash_read(const struct device *dev,
+			      struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_CTYPE_READ0);
+}
+
+/* Flash write using SAF EC Portal */
+static int saf_xec_flash_write(const struct device *dev,
+			       struct espi_saf_packet *pckt)
+{
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_CTYPE_WRITE0);
+}
+
+/* Flash erase using SAF EC Portal */
+static int saf_xec_flash_erase(const struct device *dev,
+			       struct espi_saf_packet *pckt)
+{
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_CTYPE_ERASE0);
+}
+
+static int espi_saf_xec_manage_callback(const struct device *dev,
+					struct espi_callback *callback,
+					bool set)
+{
+	struct espi_saf_xec_data *data = DEV_DATA(dev);
+
+	return espi_manage_callback(&data->callbacks, callback, set);
+}
+
+static int espi_saf_xec_activate(const struct device *dev)
+{
+	const struct espi_saf_xec_config *cfg;
+	MCHP_SAF_HW_REGS *regs;
+
+	if (dev == NULL) {
+		return -EINVAL;
+	}
+
+	cfg = DEV_CFG(dev);
+	regs = (MCHP_SAF_HW_REGS *)cfg->saf_base_addr;
+
+	regs->SAF_FL_CFG_MISC |= MCHP_SAF_FL_CFG_MISC_SAF_EN;
+
+	return 0;
+}
+
+static int espi_saf_xec_init(const struct device *dev);
+
+static const struct espi_saf_driver_api espi_saf_xec_driver_api = {
+	.config = espi_saf_xec_configuration,
+	.set_protection_regions = espi_saf_xec_set_pr,
+	.activate = espi_saf_xec_activate,
+	.get_channel_status = espi_saf_xec_channel_ready,
+	.flash_read = saf_xec_flash_read,
+	.flash_write = saf_xec_flash_write,
+	.flash_erase = saf_xec_flash_erase,
+	.manage_callback = espi_saf_xec_manage_callback,
+};
+
+static struct espi_saf_xec_data espi_saf_xec_data;
+
+static const struct espi_saf_xec_config espi_saf_xec_config = {
+	.saf_base_addr = DT_INST_REG_ADDR_BY_IDX(0, 0),
+	.qmspi_base_addr = DT_INST_REG_ADDR_BY_IDX(0, 1),
+	.saf_comm_base_addr = DT_INST_REG_ADDR_BY_IDX(0, 2),
+	.poll_timeout = DT_INST_PROP_OR(inst, poll_timeout,
+					MCHP_SAF_FLASH_POLL_TIMEOUT),
+	.consec_rd_timeout = DT_INST_PROP_OR(
+		inst, consec_rd_timeout, MCHP_SAF_FLASH_CONSEC_READ_TIMEOUT),
+	.sus_chk_delay = DT_INST_PROP_OR(inst, sus_chk_delay,
+					 MCHP_SAF_FLASH_SUS_CHK_DELAY),
+	.sus_rsm_interval = DT_INST_PROP_OR(inst, sus_rsm_interval,
+					    MCHP_SAF_FLASH_SUS_RSM_INTERVAL),
+	.poll_interval = DT_INST_PROP_OR(inst, poll_interval,
+					 MCHP_SAF_FLASH_POLL_INTERVAL),
+};
+
+DEVICE_AND_API_INIT(espi_saf_xec_0, DT_INST_LABEL(0),
+		    &espi_saf_xec_init, &espi_saf_xec_data,
+		    &espi_saf_xec_config,
+		    POST_KERNEL, CONFIG_ESPI_SAF_INIT_PRIORITY,
+		    &espi_saf_xec_driver_api);
+
+static int espi_saf_xec_init(const struct device *dev)
+{
+	struct espi_saf_xec_data *data = DEV_DATA(dev);
+
+	/* ungate SAF clocks by disabling PCR sleep enable */
+	mchp_pcr_periph_slp_ctrl(PCR_ESPI_SAF, MCHP_PCR_SLEEP_DIS);
+
+	/* reset the SAF block */
+	mchp_pcr_periph_reset(PCR_ESPI_SAF);
+
+	/* Configure the channels and its capabilities based on build config */
+	ESPI_CAP_REGS->GLB_CAP0 |= MCHP_ESPI_GBL_CAP0_FC_SUPP;
+	ESPI_CAP_REGS->FC_CAP &= ~(MCHP_ESPI_FC_CAP_SHARE_MASK);
+	ESPI_CAP_REGS->FC_CAP |= MCHP_ESPI_FC_CAP_SHARE_MAF_SAF;
+
+	k_sem_init(&data->ecp_lock, 1, 1);
+
+	return 0;
+}
diff --git a/dts/arm/microchip/mec1501hsz.dtsi b/dts/arm/microchip/mec1501hsz.dtsi
index 2b7f646a6d..0630f594bb 100644
--- a/dts/arm/microchip/mec1501hsz.dtsi
+++ b/dts/arm/microchip/mec1501hsz.dtsi
@@ -234,6 +234,17 @@
 			#size-cells = <0>;
 			status = "disabled";
 		};
+		espi_saf0: espi@40008000 {
+			compatible = "microchip,xec-espi-saf";
+			reg = < 0x40008000 0x400
+				0x40070000 0x400
+				0x40071000 0x400>;
+			label = "ESPI_SAF_0";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
 		timer0: timer@40000c00 {
 			compatible = "microchip,xec-timer";
 			clock-frequency = <48000000>;
diff --git a/dts/bindings/espi/microchip,xec-espi-saf.yaml b/dts/bindings/espi/microchip,xec-espi-saf.yaml
new file mode 100644
index 0000000000..392413bd61
--- /dev/null
+++ b/dts/bindings/espi/microchip,xec-espi-saf.yaml
@@ -0,0 +1,44 @@
+# Copyright (c) 2019 Intel Corporation
+# Copyright (c) 2020 Microchip Technology Inc.
+# SPDX-License-Identifier: Apache-2.0
+
+description: Microchip ESPI SAF controller
+
+compatible: "microchip,xec-espi-saf"
+
+include: espi-controller.yaml
+
+properties:
+    reg:
+      description: mmio register space
+      required: true
+
+    io_girq:
+      type: int
+      description: soc group irq index for eSPI I/O
+      required: false
+
+    poll_timeout:
+      type: int
+      description: poll flash busy timeout in 32KHz periods
+      required: false
+
+    poll_interval:
+      type: int
+      description: interval between flash busy poll in 20 ns units
+      required: false
+
+    consec_rd_timeout:
+      type: int
+      description: timeout after last read to resume supended operations in 20 ns units
+      required: false
+
+    sus_chk_delay:
+      type: int
+      description: hold off poll after suspend in 20 ns units
+      required: false
+
+    sus_rsm_interval:
+      type: int
+      description: force suspended erase or program to resume in 32KHz periods
+      required: false
diff --git a/include/drivers/espi_saf.h b/include/drivers/espi_saf.h
new file mode 100644
index 0000000000..508d8ffc56
--- /dev/null
+++ b/include/drivers/espi_saf.h
@@ -0,0 +1,523 @@
+/*
+ * Copyright (c) 2019 Intel Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file
+ * @brief Public APIs for eSPI driver
+ */
+
+#ifndef ZEPHYR_INCLUDE_ESPI_SAF_H_
+#define ZEPHYR_INCLUDE_ESPI_SAF_H_
+
+#include <sys/__assert.h>
+#include <zephyr/types.h>
+#include <device.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief eSPI SAF Driver APIs
+ * @defgroup espi_interface ESPI Driver APIs
+ * @ingroup io_interfaces
+ * @{
+ */
+
+
+/**
+ *+----------------------------------------------------------------------+
+ *|                                                                      |
+ *|  eSPI host                           +-------------+                 |
+ *|                      +-----------+   |    Power    |   +----------+  |
+ *|                      |Out of band|   |  management |   |   GPIO   |  |
+ *|   ------------       |processor  |   |  controller |   |  sources |  |
+ *|                      +-----------+   +-------------+   +----------+  |
+ *|                            |                |               |        |
+ *|   ------------             |                |               |        |
+ *|                            +--------+       +---------------+        |
+ *|                                     |               |                |
+ *|            -----+   +--------+   +----------+  +----v-----+          |
+ *|                 |   |  LPC   |   | Tunneled |  | Tunneled |          |
+ *|                 |   | bridge |   |  SMBus   |  |   GPIO   |          |
+ *|                 |   +--------+   +----------+  +----------+          |
+ *|                 |        |             |             |               |
+ *|                 |        ------+       |             |               |
+ *|                 |              |       |             |               |
+ *|          +------v-----+    +---v-------v-------------v----+          |
+ *|          | eSPI Flash |    |    eSPI protocol block       |          |
+ *|          |   access   +--->+                              |          |
+ *|          +------------+    +------------------------------+          |
+ *|                                    |                                 |
+ *|       -----------                  |                                 |
+ *|                                    v                                 |
+ *|               XXXXXXXXXXXXXXXXXXXXXXX                                |
+ *|                XXXXXXXXXXXXXXXXXXXXX                                 |
+ *|                 XXXXXXXXXXXXXXXXXXX                                  |
+ *+----------------------------------------------------------------------+
+ *                          |
+ *                 +-----------------+
+ *  ---------      |  |   |   |   |  |
+ *                 |  |   |   |   |  |
+ *  ---------      |  +   +   +   +  |    eSPI bus
+ *                 | CH0 CH1 CH2 CH3 |    (logical channels)
+ *                 |  +   +   +   +  |
+ *                 |  |   |   |   |  |
+ *                 +-----------------+
+ *                          |
+ *+-----------------------------------------------------------------------+
+ *|  eSPI slave                                                           |
+ *|                                                                       |
+ *|       CH0         |     CH1      |      CH2      |    CH3             |
+ *|   eSPI endpoint   |    VWIRE     |      OOB      |   Flash            |
+ *+-----------------------------------------------------------------------+
+ *   |                                 |
+ *   v                                 |
+ * +---------+                         |
+ * |  Flash  |  Slave Attached Flash   |
+ * +---------+                         |
+ *                                     |
+ */
+
+
+/**
+ * @cond INTERNAL_HIDDEN
+ *
+ */
+
+
+/** @endcond */
+
+struct espi_saf_hw_cfg;
+struct espi_saf_flash_cfg;
+struct espi_saf_pr;
+
+/**
+ * @brief eSPI SAF configuration parameters
+ */
+struct espi_saf_cfg {
+	uint8_t nflash_devices;
+	struct espi_saf_hw_cfg hwcfg;
+	struct espi_saf_flash_cfg *flash_cfgs;
+};
+
+/**
+ * @brief eSPI SAF transaction packet format
+ */
+struct espi_saf_packet {
+	uint32_t flash_addr;
+	uint8_t *buf;
+	uint32_t len;
+};
+
+/*
+ *defined in espi.h
+ * struct espi_callback
+ * typedef void (*espi_callback_handler_t)()
+ */
+
+/**
+ * @cond INTERNAL_HIDDEN
+ *
+ * eSPI driver API definition and system call entry points
+ *
+ * (Internal use only.)
+ */
+typedef int (*espi_saf_api_config)(const struct device *dev,
+				   const struct espi_saf_cfg *cfg);
+
+typedef int (*espi_saf_api_set_protection_regions)(
+				const struct device *dev,
+				const struct espi_saf_protection *pr);
+
+typedef int (*espi_saf_api_activate)(const struct device *dev);
+
+typedef bool (*espi_saf_api_get_channel_status)(const struct device *dev);
+
+typedef int (*espi_saf_api_flash_read)(const struct device *dev,
+				       struct espi_saf_packet *pckt);
+typedef int (*espi_saf_api_flash_write)(const struct device *dev,
+					struct espi_saf_packet *pckt);
+typedef int (*espi_saf_api_flash_erase)(const struct device *dev,
+					struct espi_saf_packet *pckt);
+/* Callbacks and traffic intercept */
+typedef int (*espi_saf_api_manage_callback)(const struct device *dev,
+					    struct espi_callback *callback,
+					    bool set);
+
+__subsystem struct espi_saf_driver_api {
+	espi_saf_api_config config;
+	espi_saf_api_set_protection_regions set_protection_regions;
+	espi_saf_api_activate activate;
+	espi_saf_api_get_channel_status get_channel_status;
+	espi_saf_api_flash_read flash_read;
+	espi_saf_api_flash_write flash_write;
+	espi_saf_api_flash_erase flash_erase;
+	espi_saf_api_manage_callback manage_callback;
+};
+
+/**
+ * @endcond
+ */
+
+/**
+ * @brief Configure operation of a eSPI controller.
+ *
+ * This routine provides a generic interface to override eSPI controller
+ * capabilities.
+ *
+ * If this eSPI controller is acting as slave, the values set here
+ * will be discovered as part through the GET_CONFIGURATION command
+ * issued by the eSPI master during initialization.
+ *
+ * If this eSPI controller is acting as master, the values set here
+ * will be used by eSPI master to determine minimum common capabilities with
+ * eSPI slave then send via SET_CONFIGURATION command.
+ *
+ * +--------+   +---------+     +------+          +---------+   +---------+
+ * |  eSPI  |   |  eSPI   |     | eSPI |          |  eSPI   |   |  eSPI   |
+ * |  slave |   | driver  |     |  bus |          |  driver |   |  host   |
+ * +--------+   +---------+     +------+          +---------+   +---------+
+ *     |              |            |                   |             |
+ *     | espi_config  | Set eSPI   |       Set eSPI    | espi_config |
+ *     +--------------+ ctrl regs  |       cap ctrl reg| +-----------+
+ *     |              +-------+    |          +--------+             |
+ *     |              |<------+    |          +------->|             |
+ *     |              |            |                   |             |
+ *     |              |            |                   |             |
+ *     |              |            | GET_CONFIGURATION |             |
+ *     |              |            +<------------------+             |
+ *     |              |<-----------|                   |             |
+ *     |              | eSPI caps  |                   |             |
+ *     |              |----------->+    response       |             |
+ *     |              |            |------------------>+             |
+ *     |              |            |                   |             |
+ *     |              |            | SET_CONFIGURATION |             |
+ *     |              |            +<------------------+             |
+ *     |              |            |  accept           |             |
+ *     |              |            +------------------>+             |
+ *     +              +            +                   +             +
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param cfg the device runtime configuration for the eSPI controller.
+ *
+ * @retval 0 If successful.
+ * @retval -EIO General input / output error, failed to configure device.
+ * @retval -EINVAL invalid capabilities, failed to configure device.
+ * @retval -ENOTSUP capability not supported by eSPI slave.
+ */
+__syscall int espi_saf_config(const struct device *dev,
+			      const struct espi_saf_cfg *cfg);
+
+static inline int z_impl_espi_saf_config(const struct device *dev,
+					 const struct espi_saf_cfg *cfg)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	return api->config(dev, cfg);
+}
+
+/**
+ * @brief Set one or more SAF protection regions
+ *
+ * This routine provides an interface to override the default flash
+ * protection regions of the SAF controller.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param pr Pointer to the SAF protection region structure.
+ *
+ * @retval 0 If successful.
+ * @retval -EIO General input / output error, failed to configure device.
+ * @retval -EINVAL invalid capabilities, failed to configure device.
+ * @retval -ENOTSUP capability not supported by eSPI slave.
+ */
+__syscall int espi_saf_set_protection_regions(
+				const struct device *dev,
+				const struct espi_saf_protection *pr);
+
+static inline int z_impl_espi_saf_set_protection_regions(
+					const struct device *dev,
+					const struct espi_saf_protection *pr)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	return api->set_protection_regions(dev, pr);
+}
+
+/**
+ * @brief Activate SAF block
+ *
+ * This routine activates the SAF block and should only be
+ * called after SAF has been configured and the eSPI Master
+ * has enabled the Flash Channel.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ *
+ * @retval 0 If successful
+ * @retval -EINVAL if failed to activate SAF.
+ */
+__syscall int espi_saf_activate(const struct device *dev);
+
+static inline int z_impl_espi_saf_activate(const struct device *dev)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	return api->activate(dev);
+}
+
+/**
+ * @brief Query to see if SAF is ready
+ *
+ * This routine allows to check if SAF is ready before use.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ *
+ * @retval true If eSPI SAF is ready.
+ * @retval false otherwise.
+ */
+__syscall bool espi_saf_get_channel_status(const struct device *dev);
+
+static inline bool z_impl_espi_saf_get_channel_status(
+					const struct device *dev)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	return api->get_channel_status(dev);
+}
+
+/**
+ * @brief Sends a read request packet for slave attached flash.
+ *
+ * This routines provides an interface to send a request to read the flash
+ * component shared between the eSPI master and eSPI slaves.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param pckt Adddress of the representation of read flash transaction.
+ *
+ * @retval -ENOTSUP eSPI flash logical channel transactions not supported.
+ * @retval -EBUSY eSPI flash channel is not ready or disabled by master.
+ * @retval -EIO General input / output error, failed request to master.
+ */
+__syscall int espi_saf_flash_read(const struct device *dev,
+				  struct espi_saf_packet *pckt);
+
+static inline int z_impl_espi_saf_flash_read(const struct device *dev,
+					     struct espi_saf_packet *pckt)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	if (!api->flash_read) {
+		return -ENOTSUP;
+	}
+
+	return api->flash_read(dev, pckt);
+}
+
+/**
+ * @brief Sends a write request packet for slave attached flash.
+ *
+ * This routines provides an interface to send a request to write to the flash
+ * components shared between the eSPI master and eSPI slaves.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param pckt Address of the representation of write flash transaction.
+ *
+ * @retval -ENOTSUP eSPI flash logical channel transactions not supported.
+ * @retval -EBUSY eSPI flash channel is not ready or disabled by master.
+ * @retval -EIO General input / output error, failed request to master.
+ */
+__syscall int espi_saf_flash_write(const struct device *dev,
+				   struct espi_saf_packet *pckt);
+
+static inline int z_impl_espi_saf_flash_write(const struct device *dev,
+					      struct espi_saf_packet *pckt)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	if (!api->flash_write) {
+		return -ENOTSUP;
+	}
+
+	return api->flash_write(dev, pckt);
+}
+
+/**
+ * @brief Sends a write request packet for slave attached flash.
+ *
+ * This routines provides an interface to send a request to write to the flash
+ * components shared between the eSPI master and eSPI slaves.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param pckt Address of the representation of erase flash transaction.
+ *
+ * @retval -ENOTSUP eSPI flash logical channel transactions not supported.
+ * @retval -EBUSY eSPI flash channel is not ready or disabled by master.
+ * @retval -EIO General input / output error, failed request to master.
+ */
+__syscall int espi_saf_flash_erase(const struct device *dev,
+				   struct espi_saf_packet *pckt);
+
+static inline int z_impl_espi_saf_flash_erase(const struct device *dev,
+					      struct espi_saf_packet *pckt)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	if (!api->flash_erase) {
+		return -ENOTSUP;
+	}
+
+	return api->flash_erase(dev, pckt);
+}
+
+/**
+ * Callback model
+ *
+ *+-------+                  +-------------+   +------+     +---------+
+ *|  App  |                  | eSPI driver |   |  HW  |     |eSPI Host|
+ *+---+---+                  +-------+-----+   +---+--+     +----+----+
+ *    |                              |             |             |
+ *    |   espi_init_callback         |             |             |
+ *    +----------------------------> |             |             |
+ *    |   espi_add_callback          |             |
+ *    +----------------------------->+             |
+ *    |                              |             |  eSPI reset |  eSPI host
+ *    |                              |    IRQ      +<------------+  resets the
+ *    |                              | <-----------+             |  bus
+ *    |                              |             |             |
+ *    |                              | Processed   |             |
+ *    |                              | within the  |             |
+ *    |                              | driver      |             |
+ *    |                              |             |             |
+
+ *    |                              |             |  VW CH ready|  eSPI host
+ *    |                              |    IRQ      +<------------+  enables VW
+ *    |                              | <-----------+             |  channel
+ *    |                              |             |             |
+ *    |                              | Processed   |             |
+ *    |                              | within the  |             |
+ *    |                              | driver      |             |
+ *    |                              |             |             |
+ *    |                              |             | Memory I/O  |  Peripheral
+ *    |                              |             <-------------+  event
+ *    |                              +<------------+             |
+ *    +<-----------------------------+ callback    |             |
+ *    | Report peripheral event      |             |             |
+ *    | and data for the event       |             |             |
+ *    |                              |             |             |
+ *    |                              |             | SLP_S5      |  eSPI host
+ *    |                              |             <-------------+  send VWire
+ *    |                              +<------------+             |
+ *    +<-----------------------------+ callback    |             |
+ *    | App enables/configures       |             |             |
+ *    | discrete regulator           |             |             |
+ *    |                              |             |             |
+ *    |   espi_send_vwire_signal     |             |             |
+ *    +------------------------------>------------>|------------>|
+ *    |                              |             |             |
+ *    |                              |             | HOST_RST    |  eSPI host
+ *    |                              |             <-------------+  send VWire
+ *    |                              +<------------+             |
+ *    +<-----------------------------+ callback    |             |
+ *    | App reset host-related       |             |             |
+ *    | data structures              |             |             |
+ *    |                              |             |             |
+ *    |                              |             |   C10       |  eSPI host
+ *    |                              |             +<------------+  send VWire
+ *    |                              <-------------+             |
+ *    <------------------------------+             |             |
+ *    | App executes                 |             |             |
+ *    + power mgmt policy            |             |             |
+ */
+
+/**
+ * @brief Helper to initialize a struct espi_callback properly.
+ *
+ * @param callback A valid Application's callback structure pointer.
+ * @param handler A valid handler function pointer.
+ * @param evt_type indicates the eSPI event relevant for the handler.
+ * for VWIRE_RECEIVED event the data will indicate the new level asserted
+ */
+static inline void espi_saf_init_callback(struct espi_callback *callback,
+					  espi_callback_handler_t handler,
+					  enum espi_bus_event evt_type)
+{
+	__ASSERT(callback, "Callback pointer should not be NULL");
+	__ASSERT(handler, "Callback handler pointer should not be NULL");
+
+	callback->handler = handler;
+	callback->evt_type = evt_type;
+}
+
+/**
+ * @brief Add an application callback.
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param callback A valid Application's callback structure pointer.
+ * @return 0 if successful, negative errno code on failure.
+ *
+ * @note Callbacks may be added to the device from within a callback
+ * handler invocation, but whether they are invoked for the current
+ * eSPI event is not specified.
+ *
+ * Note: enables to add as many callback as needed on the same device.
+ */
+static inline int espi_saf_add_callback(const struct device *dev,
+					struct espi_callback *callback)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	if (!api->manage_callback) {
+		return -ENOTSUP;
+	}
+
+	return api->manage_callback(dev, callback, true);
+}
+
+/**
+ * @brief Remove an application callback.
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param callback A valid application's callback structure pointer.
+ * @return 0 if successful, negative errno code on failure.
+ *
+ * @warning It is explicitly permitted, within a callback handler, to
+ * remove the registration for the callback that is running, i.e. @p
+ * callback.  Attempts to remove other registrations on the same
+ * device may result in undefined behavior, including failure to
+ * invoke callbacks that remain registered and unintended invocation
+ * of removed callbacks.
+ *
+ * Note: enables to remove as many callbacks as added through
+ *       espi_add_callback().
+ */
+static inline int espi_saf_remove_callback(const struct device *dev,
+					   struct espi_callback *callback)
+{
+	const struct espi_saf_driver_api *api =
+		(const struct espi_saf_driver_api *)dev->api;
+
+	if (!api->manage_callback) {
+		return -ENOTSUP;
+	}
+
+	return api->manage_callback(dev, callback, false);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+#include <syscalls/espi_saf.h>
+#endif /* ZEPHYR_INCLUDE_ESPI_SAF_H_ */
diff --git a/soc/arm/microchip_mec/common/soc_espi_saf.h b/soc/arm/microchip_mec/common/soc_espi_saf.h
new file mode 100644
index 0000000000..7695904cc4
--- /dev/null
+++ b/soc/arm/microchip_mec/common/soc_espi_saf.h
@@ -0,0 +1,407 @@
+/*
+ * Copyright (c) 2020 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file Header containing definitions for MCHP eSPI SAF
+ */
+
+#ifndef _SOC_ESPI_SAF_H_
+#define _SOC_ESPI_SAF_H_
+
+#include <stdint.h>
+#include <sys/util.h>
+#include <soc.h>
+
+#define MCHP_SAF_MAX_FLASH_DEVICES 2U
+
+/*
+ * SAF hardware state machine timings
+ * poll timeout is in 32KHz clock periods
+ * poll interval is in AHB clock(48MHz) units.
+ * suspend resume interval is in 32KHz clock periods.
+ * consecutive read timeout is in AHB clock periods.
+ * suspend check delay is in AHB clock(48MHz) periods.
+ */
+#define MCHP_SAF_FLASH_POLL_TIMEOUT 0x28000U
+#define MCHP_SAF_FLASH_POLL_INTERVAL 0U
+#define MCHP_SAF_FLASH_SUS_RSM_INTERVAL 8U
+#define MCHP_SAF_FLASH_CONSEC_READ_TIMEOUT 2U
+#define MCHP_SAF_FLASH_SUS_CHK_DELAY 0U
+
+/* Default SAF Map of eSPI TAG numbers to master numbers */
+#define MCHP_SAF_TAG_MAP0_DFLT 0x23221100
+#define MCHP_SAF_TAG_MAP1_DFLT 0x77677767
+#define MCHP_SAF_TAG_MAP2_DFLT 0x00000005
+
+/*
+ * Default QMSPI clock divider and chip select timing.
+ * QMSPI master clock is 48MHz AHB clock.
+ */
+#define MCHP_SAF_QMSPI_CLK_DIV 2U
+#define MCHP_SAF_QMSPI_CS_TIMING 0x03000101U
+
+/* SAF QMSPI programming */
+
+#define MCHP_SAF_QMSPI_NUM_FLASH_DESCR 6U
+#define MCHP_SAF_QMSPI_CS0_START_DESCR 0U
+#define MCHP_SAF_QMSPI_CS1_START_DESCR \
+	(MCHP_SAF_QMSPI_CS0_START_DESCR + MCHP_SAF_QMSPI_NUM_FLASH_DESCR)
+
+/* SAF engine requires start indices of descriptor chains */
+#define MCHP_SAF_CM_EXIT_START_DESCR  12U
+#define MCHP_SAF_CM_EXIT_LAST_DESCR   13U
+#define MCHP_SAF_POLL_STS_START_DESCR 14U
+#define MCHP_SAF_POLL_STS_END_DESCR   15U
+#define MCHP_SAF_NUM_GENERIC_DESCR    4U
+
+/* QMSPI descriptors 12-15 for all SPI flash devices */
+/* #define SAF_QMSPI_DESCR12 0x0002D40E */
+
+/*
+ * QMSPI descriptors 12-13 are exit continuous mode
+ */
+#define MCHP_SAF_EXIT_CM_DESCR12 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_ONES | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | \
+		 MCHP_QMSPI_C_NEXT_DESCR(13) | \
+		 MCHP_QMSPI_C_XFR_NUNITS(1))
+
+#define MCHP_SAF_EXIT_CM_DESCR13 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_EN | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | \
+		 MCHP_QMSPI_C_NEXT_DESCR(0) | \
+		 MCHP_QMSPI_C_XFR_NUNITS(9) | \
+		 MCHP_QMSPI_C_DESCR_LAST)
+
+/*
+ * QMSPI descriptors 14-15 are poll 16-bit flash status
+ * Transmit one byte opcode at 1X (no DMA).
+ * Receive two bytes at 1X (no DMA).
+ */
+#define MCHP_SAF_POLL_DESCR14 \
+		(MCHP_QMSPI_C_IFM_1X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | \
+		 MCHP_QMSPI_C_NEXT_DESCR(15) | \
+		 MCHP_QMSPI_C_XFR_NUNITS(1))
+
+#define MCHP_SAF_POLL_DESCR15 \
+		(MCHP_QMSPI_C_IFM_1X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_EN | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | \
+		 MCHP_QMSPI_C_NEXT_DESCR(0) | \
+		 MCHP_QMSPI_C_XFR_NUNITS(2) | \
+		 MCHP_QMSPI_C_DESCR_LAST)
+
+
+/* SAF Pre-fetch optimization mode */
+#define MCHP_SAF_PREFETCH_MODE MCHP_SAF_FL_CFG_MISC_PFOE_DFLT
+
+#define MCHP_SAF_CFG_MISC_PREFETCH_EXPEDITED 0x03U
+
+/*
+ * SAF Opcode 32-bit register value.
+ * Each byte contain a SPI flash 8-bit opcode.
+ * NOTE1: opcode value of 0 = flash does not support this operation
+ * NOTE2:
+ * SAF Opcode A
+ *	op0 = SPI flash write-enable opcode
+ *	op1 = SPI flash program/erase suspend opcode
+ *	op2 = SPI flash program/erase resume opcode
+ *	op3 = SPI flash read STATUS1 opcode
+ * SAF Opcode B
+ *	op0 = SPI flash erase 4KB sector opcode
+ *	op1 = SPI flash erase 32KB sector opcode
+ *	op2 = SPI flash erase 64KB sector opcode
+ *	op3 = SPI flash page program opcode
+ * SAF Opcode C
+ *	op0 = SPI flash read 1-4-4 continuous mode opcode
+ *	op1 = SPI flash op0 mode byte value for non-continuous mode
+ *	op2 = SPI flash op0 mode byte value for continuous mode
+ *	op3 = SPI flash read STATUS2 opcode
+ */
+#define MCHP_SAF_OPCODE_REG_VAL(op0, op1, op2, op3) \
+	(((uint32_t)(op0)&0xffU) | (((uint32_t)(op1)&0xffU) << 8) | \
+	 (((uint32_t)(op2)&0xffU) << 16) | (((uint32_t)(op3)&0xffU) << 24))
+
+/*
+ * SAF Flash Config CS0/CS1 QMSPI descriptor indices register value
+ * e = First QMSPI descriptor index for enter continuous mode chain
+ * r = First QMSPI descriptor index for continuous mode read chain
+ * s = Index of QMSPI descriptor in continuous mode read chain that
+ *     contains the data length field.
+ */
+#define MCHP_SAF_CS_CFG_DESCR_IDX_REG_VAL(e, r, s) (((uint32_t)(e)&0xfU) | \
+	(((uint32_t)(r)&0xfU) << 8) | (((uint32_t)(s)&0xfU) << 12))
+
+/* W25Q128 SPI flash device connected size in bytes */
+#define MCHP_W25Q128_SIZE (16U * 1024U * 1024U)
+
+/*
+ * Six QMSPI descriptors describe SPI flash opcode protocols.
+ * Example: W25Q128
+ */
+/* Continuous mode read: transmit-quad 24-bit address and mode byte */
+#define MCHP_W25Q128_CM_RD_D0 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(4))
+
+/* Continuous mode read: transmit-quad 4 dummy clocks with I/O tri-stated */
+#define MCHP_W25Q128_CM_RD_D1 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(2))
+
+/* Continuous mode read: read N bytes */
+#define MCHP_W25Q128_CM_RD_D2 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_EN | \
+		 MCHP_QMSPI_C_RX_DMA_4B | MCHP_QMSPI_C_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(0) | \
+		 MCHP_QMSPI_C_DESCR_LAST)
+
+/* Enter Continuous mode: transmit-single CM quad read opcode */
+#define MCHP_W25Q128_ENTER_CM_D0 \
+		(MCHP_QMSPI_C_IFM_1X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(1))
+
+/* Enter Continuous mode: transmit-quad 24-bit address and mode byte  */
+#define MCHP_W25Q128_ENTER_CM_D1 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(4))
+
+/* Enter Continuous mode: read-quad 3 bytes */
+#define MCHP_W25Q128_ENTER_CM_D2 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(3) | \
+		 MCHP_QMSPI_C_DESCR_LAST)
+
+#define MCHP_W25Q128_OPA MCHP_SAF_OPCODE_REG_VAL(0x06U, 0x75U, 0x7aU, 0x05U)
+#define MCHP_W25Q128_OPB MCHP_SAF_OPCODE_REG_VAL(0x20U, 0x52U, 0xd8U, 0x02U)
+#define MCHP_W25Q128_OPC MCHP_SAF_OPCODE_REG_VAL(0xebU, 0xffU, 0xa5U, 0x35U)
+
+/* W25Q128 STATUS2 bit[7] == 0 part is NOT in suspend state */
+#define MCHP_W25Q128_POLL2_MASK 0xff7fU
+
+/*
+ * SAF Flash Continuous Mode Prefix register value
+ * b[7:0] = continuous mode prefix opcode
+ * b[15:8] = continuous mode prefix opcode data
+ * Some SPI flash devices require a prefix command before
+ * they will enter continuous mode.
+ * A zero value means the SPI flash does not require a prefix
+ * command.
+ */
+#define MCHP_W25Q128_CONT_MODE_PREFIX_VAL 0U
+
+#define MCHP_W25Q128_FLAGS 0U
+
+
+/* W25Q256 SPI flash device connected size in bytes */
+#define MCHP_W25Q256_SIZE (32U * 1024U * 1024U)
+
+/*
+ * Six QMSPI descriptors describe SPI flash opcode protocols.
+ * W25Q256 device.
+ */
+
+/* Continuous Mode Read: Transmit-quad opcode plus 32-bit address */
+#define MCHP_W25Q256_CM_RD_D0 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(5))
+
+#define MCHP_W25Q256_CM_RD_D1 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(2))
+
+#define MCHP_W25Q256_CM_RD_D2 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_EN | \
+		 MCHP_QMSPI_C_RX_DMA_4B | MCHP_QMSPI_C_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(0) | \
+		 MCHP_QMSPI_C_DESCR_LAST)
+
+/* Enter Continuous mode: transmit-single CM quad read opcode */
+#define MCHP_W25Q256_ENTER_CM_D0 \
+		(MCHP_QMSPI_C_IFM_1X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(1))
+
+/* Enter Continuous mode: transmit-quad 32-bit address and mode byte  */
+#define MCHP_W25Q256_ENTER_CM_D1 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DATA | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_NO_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(5))
+
+/* Enter Continuous mode: read-quad 3 bytes */
+#define MCHP_W25Q256_ENTER_CM_D2 \
+		(MCHP_QMSPI_C_IFM_4X | MCHP_QMSPI_C_TX_DIS | \
+		 MCHP_QMSPI_C_TX_DMA_DIS | MCHP_QMSPI_C_RX_DIS | \
+		 MCHP_QMSPI_C_RX_DMA_DIS | MCHP_QMSPI_C_CLOSE | \
+		 MCHP_QMSPI_C_XFR_UNITS_1 | MCHP_QMSPI_C_XFR_NUNITS(3) | \
+		 MCHP_QMSPI_C_DESCR_LAST)
+
+#define MCHP_W25Q256_OPA SAF_OPCODE_REG_VAL(0x06U, 0x75U, 0x7aU, 0x05U)
+#define MCHP_W25Q256_OPB SAF_OPCODE_REG_VAL(0x20U, 0x52U, 0xd8U, 0x02U)
+#define MCHP_W25Q256_OPC SAF_OPCODE_REG_VAL(0xebU, 0xffU, 0xa5U, 0x35U)
+
+#define MCHP_W25Q256_POLL2_MASK 0xff7fU
+
+#define MCHP_W25Q256_CONT_MODE_PREFIX_VAL 0U
+
+#define MCHP_W25Q256_FLAGS 0U
+
+/* SAF Flash Config CS0 QMSPI descriptor indices */
+#define MCHP_CS0_CFG_DESCR_IDX_REG_VAL \
+		MCHP_SAF_CS_CFG_DESCR_IDX_REG_VAL(3U, 0U, 2U)
+
+/* SAF Flash Config CS1 QMSPI descriptor indices */
+#define MCHP_CS1_CFG_DESCR_IDX_REG_VAL \
+		MCHP_SAF_CS_CFG_DESCR_IDX_REG_VAL(9U, 6U, 8U)
+
+#define MCHP_SAF_HW_CFG_FLAG_FREQ 0x01U
+#define MCHP_SAF_HW_CFG_FLAG_CSTM 0x02U
+#define MCHP_SAF_HW_CFG_FLAG_CPHA 0x04U
+
+/* enable SAF prefetch */
+#define MCHP_SAF_HW_CFG_FLAG_PFEN 0x10U
+/* Use expedited prefetch instead of default */
+#define MCHP_SAF_HW_CFG_FLAG_PFEXP 0x20U
+
+/*
+ * Override the default tag map value when this bit is set
+ * in a tag_map[].
+ */
+#define MCHP_SAF_HW_CFG_TAGMAP_USE BIT(31)
+
+struct espi_saf_hw_cfg {
+	uint32_t qmspi_freq_hz;
+	uint32_t qmspi_cs_timing;
+	uint8_t  qmspi_cpha;
+	uint8_t  flags;
+	uint32_t generic_descr[MCHP_SAF_NUM_GENERIC_DESCR];
+	uint32_t tag_map[MCHP_ESPI_SAF_TAGMAP_MAX];
+};
+
+/*
+ * SAF local flash configuration.
+ * SPI flash device size in bytes
+ * SPI opcodes for SAF Opcode A register
+ * SPI opcodes for SAF Opcode B register
+ * SPI opcodes for SAF Opcode C register
+ * QMSPI descriptors describing SPI opcode transmit and
+ * data read.
+ * SAF controller Poll2 Mast value specific for this flash device
+ * SAF continuous mode prefix register value for those flashes requireing
+ * a prefix byte transmitted before the enter continuous mode command.
+ * Start QMSPI descriptor numbers.
+ * miscellaneous flags.
+ */
+
+/* Flags */
+#define MCHP_FLASH_FLAG_ADDR32 BIT(0)
+
+struct espi_saf_flash_cfg {
+	uint32_t flashsz;
+	uint32_t opa;
+	uint32_t opb;
+	uint32_t opc;
+	uint16_t poll2_mask;
+	uint16_t cont_prefix;
+	uint16_t cs_cfg_descr_ids;
+	uint16_t flags;
+	uint32_t descr[MCHP_SAF_QMSPI_NUM_FLASH_DESCR];
+};
+
+
+/*
+ * 17 flash protection regions
+ * Each region is described by:
+ * SPI start address. 20-bits = bits[31:12] of SPI address
+ * SPI limit address. 20-bits = bits[31:12] of last SPI address
+ * 8-bit bit map of eSPI master write-erase permission
+ * 8-bit bit map of eSPI maste read permission
+ * eSPI master numbers 0 - 7 correspond to bits 0 - 7.
+ *
+ * Protection region lock:
+ *   One 32-bit register with bits[16:0] -> protection regions 16:0
+ *
+ * eSPI Host maps threads by a tag number to master numbers.
+ * Thread numbers are 4-bit
+ * Master numbers are 3-bit
+ * Master number    Thread numbers    Description
+ *     0                0h, 1h        Host PCH HW init
+ *     1                2h, 3h        Host CPU access(HW/BIOS/SMM/SW)
+ *     2                4h, 5h        Host PCH ME
+ *     3                6h            Host PCH LAN
+ *     4                N/A           Not defined/used
+ *     5                N/A           EC Firmware portal access
+ *     6                9h, Dh        Host PCH IE
+ *     7                N/A           Not defined/used
+ *
+ * NOTE: eSPI SAF specification allows master 0 (Host PCH HW) full
+ * access to all protection regions.
+ *
+ * SAF TAG Map registers 0 - 2 map eSPI TAG values 0h - Fh to
+ * the three bit master number. Each 32-bit register contains 3-bit
+ * fields aligned on nibble boundaries holding the master number
+ * associated with the eSPI tag (thread) number.
+ * A master value of 7h in a field indicates a non-existent map entry.
+ *
+ * bit map of registers to program
+ * b[2:0] = TAG Map[2:0]
+ * b[20:4] = ProtectionRegions[16:0]
+ * bit map of PR's to lock
+ * b[20:4] = ProtectionRegions[16:0]
+ *
+ */
+#define MCHP_SAF_PR_FLAG_ENABLE 0x01U
+#define MCHP_SAF_PR_FLAG_LOCK 0x02U
+
+#define MCHP_SAF_MSTR_HOST_PCH		0U
+#define MCHP_SAF_MSTR_HOST_CPU		1U
+#define MCHP_SAF_MSTR_HOST_PCH_ME	2U
+#define MCHP_SAF_MSTR_HOST_PCH_LAN	3U
+#define MCHP_SAF_MSTR_RSVD4		4U
+#define MCHP_SAF_MSTR_EC		5U
+#define MCHP_SAF_MSTR_HOST_PCH_IE	6U
+
+struct espi_saf_pr {
+	uint32_t start;
+	uint32_t size;
+	uint8_t  master_bm_we;
+	uint8_t  master_bm_rd;
+	uint8_t  pr_num;
+	uint8_t  flags; /* bit[0]==1 is lock the region */
+};
+
+struct espi_saf_protection {
+	size_t nregions;
+	const struct espi_saf_pr *pregions;
+};
+
+#endif /* _SOC_ESPI_SAF_H_ */
diff --git a/soc/arm/microchip_mec/mec1501/soc.h b/soc/arm/microchip_mec/mec1501/soc.h
index 24c984b6b1..dd48cc15ca 100644
--- a/soc/arm/microchip_mec/mec1501/soc.h
+++ b/soc/arm/microchip_mec/mec1501/soc.h
@@ -17,6 +17,7 @@
 #include "../common/soc_gpio.h"
 #include "../common/soc_pins.h"
 #include "../common/soc_espi_channels.h"
+#include "../common/soc_espi_saf.h"
 
 #endif
 
-- 
2.17.1


From 88bf513f0e91f56f676447f66374b458febbcdcc Mon Sep 17 00:00:00 2001
From: Scott Worley <scott.worley@microchip.com>
Date: Mon, 9 Nov 2020 12:13:59 -0500
Subject: [PATCH 16/36] samples: drivers: espi: Add simple SAF tests

Update sample espi driver test to exercise some SAF functionality
based on the limited hardware available. Note the SAF test will
erase a section of the flash. SAF tests are enabled for the EVB only.

Signed-off-by: Scott Worley <scott.worley@microchip.com>
---
 .../boards/mec1501modular_assy6885.overlay    |   7 +
 .../espi/boards/mec15xxevb_assy6853.overlay   |   7 +
 samples/drivers/espi/prj.conf                 |   1 -
 .../drivers/espi/prj_mec15xxevb_assy6853.conf |  13 +
 samples/drivers/espi/src/main.c               | 757 ++++++++++++++++++
 5 files changed, 784 insertions(+), 1 deletion(-)
 create mode 100644 samples/drivers/espi/prj_mec15xxevb_assy6853.conf

diff --git a/samples/drivers/espi/boards/mec1501modular_assy6885.overlay b/samples/drivers/espi/boards/mec1501modular_assy6885.overlay
index f23e4cd4f6..f64c9f80bb 100644
--- a/samples/drivers/espi/boards/mec1501modular_assy6885.overlay
+++ b/samples/drivers/espi/boards/mec1501modular_assy6885.overlay
@@ -13,3 +13,10 @@
 		rsm-gpios = <&gpio_040_076 12 GPIO_ACTIVE_HIGH>;
 	};
 };
+
+&spi0 {
+	status = "okay";
+	port_sel = <0>;
+	chip_select = <0>;
+	lines = <4>;
+};
diff --git a/samples/drivers/espi/boards/mec15xxevb_assy6853.overlay b/samples/drivers/espi/boards/mec15xxevb_assy6853.overlay
index f23e4cd4f6..f64c9f80bb 100644
--- a/samples/drivers/espi/boards/mec15xxevb_assy6853.overlay
+++ b/samples/drivers/espi/boards/mec15xxevb_assy6853.overlay
@@ -13,3 +13,10 @@
 		rsm-gpios = <&gpio_040_076 12 GPIO_ACTIVE_HIGH>;
 	};
 };
+
+&spi0 {
+	status = "okay";
+	port_sel = <0>;
+	chip_select = <0>;
+	lines = <4>;
+};
diff --git a/samples/drivers/espi/prj.conf b/samples/drivers/espi/prj.conf
index 4246a3d141..bc547854fc 100644
--- a/samples/drivers/espi/prj.conf
+++ b/samples/drivers/espi/prj.conf
@@ -1,4 +1,3 @@
 CONFIG_ESPI=y
 CONFIG_STDOUT_CONSOLE=y
 CONFIG_PRINTK=y
-
diff --git a/samples/drivers/espi/prj_mec15xxevb_assy6853.conf b/samples/drivers/espi/prj_mec15xxevb_assy6853.conf
new file mode 100644
index 0000000000..8ed09e105a
--- /dev/null
+++ b/samples/drivers/espi/prj_mec15xxevb_assy6853.conf
@@ -0,0 +1,13 @@
+# eSPI + mec15xxevb_assy6853
+CONFIG_ESPI=y
+CONFIG_LOG=y
+CONFIG_LOG_BUFFER_SIZE=4096
+CONFIG_LOG_PROCESS_THREAD_SLEEP_MS=100
+# Disable only for this board to check notifications
+CONFIG_ESPI_AUTOMATIC_WARNING_ACKNOWLEDGE=n
+# Sample code doesn't handle ACPI host communication
+CONFIG_ESPI_PERIPHERAL_HOST_IO=n
+# Test SAF flash portal read/erase/write on EVB
+CONFIG_ESPI_SAF=y
+CONFIG_SPI=y
+CONFIG_SPI_XEC_QMSPI=y
diff --git a/samples/drivers/espi/src/main.c b/samples/drivers/espi/src/main.c
index 8907ff6503..61bcfda988 100644
--- a/samples/drivers/espi/src/main.c
+++ b/samples/drivers/espi/src/main.c
@@ -10,6 +10,8 @@
 #include <soc.h>
 #include <drivers/gpio.h>
 #include <drivers/espi.h>
+#include <drivers/espi_saf.h>
+#include <drivers/spi.h>
 #include <logging/log_ctrl.h>
 #include <logging/log.h>
 #ifdef CONFIG_ESPI_OOB_CHANNEL
@@ -67,6 +69,717 @@ static uint8_t flash_write_buf[MAX_TEST_BUF_SIZE];
 static uint8_t flash_read_buf[MAX_TEST_BUF_SIZE];
 #endif
 
+#ifdef CONFIG_ESPI_SAF
+#define ESPI_SAF_DEV      DT_LABEL(DT_NODELABEL(espi_saf0))
+#define SPI_DEV           DT_LABEL(DT_NODELABEL(spi0))
+
+#define SAF_BASE_ADDR     DT_REG_ADDR(DT_INST(0, microchip_xec_espi_saf))
+
+#define SAF_TEST_FREQ_HZ 24000000U
+#define SAF_TEST_BUF_SIZE 4096U
+
+/* SPI address of 4KB sector modified by test */
+#define SAF_SPI_TEST_ADDRESS 0x1000U
+
+#define SPI_WRITE_STATUS1 0x01U
+#define SPI_WRITE_STATUS2 0x31U
+#define SPI_WRITE_DISABLE 0x04U
+#define SPI_READ_STATUS1 0x05U
+#define SPI_WRITE_ENABLE 0x06U
+#define SPI_READ_STATUS2 0x35U
+#define SPI_WRITE_ENABLE_VS 0x50U
+#define SPI_READ_JEDEC_ID 0x9FU
+
+#define SPI_STATUS1_BUSY 0x80U
+#define SPI_STATUS2_QE 0x02U
+
+#define W25Q128_JEDEC_ID 0x001840efU
+
+enum saf_erase_size {
+	SAF_ERASE_4K = 0,
+	SAF_ERASE_32K = 1,
+	SAF_ERASE_64K = 2,
+	SAF_ERASE_MAX
+};
+
+struct saf_addr_info {
+	uintptr_t saf_struct_addr;
+	uintptr_t saf_exp_addr;
+};
+static const struct device *qspi_dev;
+static const struct device *espi_saf_dev;
+static uint8_t safbuf[SAF_TEST_BUF_SIZE] __aligned(4);
+static uint8_t safbuf2[SAF_TEST_BUF_SIZE] __aligned(4);
+
+/*
+ * W25Q128 SPI flash SAF configuration.
+ * Size is 16Mbytes, it requires no continuous mode prefix, or
+ * other special SAF configuration.
+ */
+static const struct espi_saf_flash_cfg flash_w25q128 = {
+	.flashsz = 0x1000000U,
+	.opa = MCHP_SAF_OPCODE_REG_VAL(0x06U, 0x75U, 0x7aU, 0x05U),
+	.opb = MCHP_SAF_OPCODE_REG_VAL(0x20U, 0x52U, 0xd8U, 0x02U),
+	.opc = MCHP_SAF_OPCODE_REG_VAL(0xebU, 0xffU, 0xa5U, 0x35U),
+	.poll2_mask = MCHP_W25Q128_POLL2_MASK,
+	.cont_prefix = 0U,
+	.cs_cfg_descr_ids = MCHP_CS0_CFG_DESCR_IDX_REG_VAL,
+	.flags = 0,
+	.descr = {
+		MCHP_W25Q128_CM_RD_D0,
+		MCHP_W25Q128_CM_RD_D1,
+		MCHP_W25Q128_CM_RD_D2,
+		MCHP_W25Q128_ENTER_CM_D0,
+		MCHP_W25Q128_ENTER_CM_D1,
+		MCHP_W25Q128_ENTER_CM_D2
+	}
+};
+
+/*
+ * SAF driver configuration.
+ * One SPI flash device.
+ * Use QMSPI frequency, chip select timing, and signal sampling configured
+ * by QMSPI driver.
+ * Use SAF hardware default TAG map.
+ */
+static const struct espi_saf_cfg saf_cfg1 = {
+	.nflash_devices = 1U,
+	.hwcfg = {
+		.qmspi_freq_hz = 0U,
+		.qmspi_cs_timing = 0U,
+		.qmspi_cpha = 0U,
+		.flags = 0U,
+		.generic_descr = {
+			MCHP_SAF_EXIT_CM_DESCR12, MCHP_SAF_EXIT_CM_DESCR13,
+			MCHP_SAF_POLL_DESCR14, MCHP_SAF_POLL_DESCR15
+		},
+		.tag_map = { 0U, 0U, 0U }
+	},
+	.flash_cfgs = (struct espi_saf_flash_cfg *)&flash_w25q128
+};
+
+/*
+ * Example for SAF driver set protection regions API.
+ */
+static const struct espi_saf_pr w25q128_protect_regions[2] = {
+	{
+		.start = 0xe00000U,
+		.size =  0x100000U,
+		.master_bm_we = (1U << MCHP_SAF_MSTR_HOST_PCH_ME),
+		.master_bm_rd = (1U << MCHP_SAF_MSTR_HOST_PCH_ME),
+		.pr_num = 1U,
+		.flags = MCHP_SAF_PR_FLAG_ENABLE
+			 | MCHP_SAF_PR_FLAG_LOCK,
+	},
+	{
+		.start = 0xf00000U,
+		.size =  0x100000U,
+		.master_bm_we = (1U << MCHP_SAF_MSTR_HOST_PCH_LAN),
+		.master_bm_rd = (1U << MCHP_SAF_MSTR_HOST_PCH_LAN),
+		.pr_num = 2U,
+		.flags = MCHP_SAF_PR_FLAG_ENABLE
+			 | MCHP_SAF_PR_FLAG_LOCK,
+	},
+};
+
+static const struct espi_saf_protection saf_pr_w25q128 = {
+	.nregions = 2U,
+	.pregions = w25q128_protect_regions
+};
+
+/*
+ * Initialize the local attached SPI flash.
+ * 1. Get SPI driver binding
+ * 2. Read JEDEC ID and verify its a W25Q128
+ * 3. Read STATUS2 and check QE bit
+ * 4. If QE bit is not set
+ *      Send volatile status write enable
+ *      Set volatile QE bit
+ *      Check STATUS1 BUSY, not expected to be set for volatile status write.
+ *      Read STATUS2 and check QE
+ * Returns 0 if QE was already set or this routine successfully set volatile
+ * QE. Returns < 0 on SPI driver error or unexpected BUSY or STATUS values.
+ * NOTE: SPI driver transceive API will configure the SPI controller to the
+ * settings passed in the struct spi_config. We set the frequency to the
+ * frequency we will be using for SAF.
+ */
+int spi_saf_init(void)
+{
+	struct spi_config spi_cfg;
+	struct spi_buf_set tx_bufs;
+	struct spi_buf_set rx_bufs;
+	struct spi_buf txb;
+	struct spi_buf rxb;
+	uint8_t spi_status1, spi_status2;
+	uint32_t jedec_id;
+	int ret;
+
+	/* Read JEDEC ID command and fill read buffer */
+	safbuf[0] = SPI_READ_JEDEC_ID;
+	memset(safbuf2, 0x55, 4U);
+
+	spi_cfg.frequency = SAF_TEST_FREQ_HZ;
+	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB
+			    | SPI_WORD_SET(8) | SPI_LINES_SINGLE;
+
+	/*
+	 * Use SPI master mode and inform driver the SPI controller hardware
+	 * controls chip select.
+	 */
+	jedec_id = 0U;
+	spi_cfg.slave = 0;
+	spi_cfg.cs = NULL;
+
+	txb.buf = &safbuf;
+	txb.len = 1U;
+
+	tx_bufs.buffers = (const struct spi_buf *)&txb;
+	tx_bufs.count = 1U;
+
+	rxb.buf = &jedec_id;
+	rxb.len = 3U;
+
+	rx_bufs.buffers = (const struct spi_buf *)&rxb;
+	rx_bufs.count = 1U;
+
+	ret = spi_transceive(qspi_dev, (const struct spi_config *)&spi_cfg,
+			     (const struct spi_buf_set *)&tx_bufs,
+			     (const struct spi_buf_set *)&rx_bufs);
+	if (ret) {
+		LOG_ERR("Read JEDEC ID spi_transceive failure: error %d", ret);
+		return ret;
+	}
+
+	if (jedec_id != W25Q128_JEDEC_ID) {
+		LOG_ERR("JEDIC ID does not match W25Q128 %0x", safbuf2[0]);
+		return -1;
+	}
+
+	/* Read STATUS2 to get quad enable bit */
+	safbuf[0] = SPI_READ_STATUS2;
+	memset(safbuf2, 0, 4U);
+
+	txb.buf = &safbuf;
+	txb.len = 1U;
+
+	tx_bufs.buffers = (const struct spi_buf *)&txb;
+	tx_bufs.count = 1U;
+
+	rxb.buf = &safbuf2;
+	rxb.len = 1U;
+
+	rx_bufs.buffers = (const struct spi_buf *)&rxb;
+	rx_bufs.count = 1U;
+
+	ret = spi_transceive(qspi_dev, (const struct spi_config *)&spi_cfg,
+			     (const struct spi_buf_set *)&tx_bufs,
+			     (const struct spi_buf_set *)&rx_bufs);
+	if (ret) {
+		LOG_ERR("Read STATUS2 spi_transceive failure: error %d", ret);
+		return ret;
+	}
+
+	spi_status2 = safbuf2[0];
+
+	/*
+	 * If QE not set then write the volatile QE bit.
+	 * SAF test requires SPI flash quad enabled so the WP#/HOLD# signals
+	 * will act as IO2/IO3. We will write the volatile QE bit for less
+	 * wear of the STATUS2 register
+	 */
+	if ((spi_status2 & SPI_STATUS2_QE) == 0U) {
+		safbuf[0] = SPI_WRITE_ENABLE_VS;
+
+		txb.buf = &safbuf;
+		txb.len = 1U;
+
+		tx_bufs.buffers = (const struct spi_buf *)&txb;
+		tx_bufs.count = 1U;
+
+		rx_bufs.buffers = NULL;
+		rx_bufs.count = 0U;
+
+		ret = spi_transceive(qspi_dev,
+				     (const struct spi_config *)&spi_cfg,
+				     (const struct spi_buf_set *)&tx_bufs,
+				     (const struct spi_buf_set *)&rx_bufs);
+		if (ret) {
+			LOG_ERR("Send write enable volatile spi_transceive"
+				" failure: error %d", ret);
+			return ret;
+		}
+
+		safbuf[0] = SPI_WRITE_STATUS2;
+		safbuf[1] = spi_status2 | SPI_STATUS2_QE;
+
+		txb.buf = &safbuf;
+		txb.len = 2U;
+
+		tx_bufs.buffers = (const struct spi_buf *)&txb;
+		tx_bufs.count = 1U;
+
+		rx_bufs.buffers = NULL;
+		rx_bufs.count = 0U;
+
+		ret = spi_transceive(qspi_dev,
+				     (const struct spi_config *)&spi_cfg,
+				     (const struct spi_buf_set *)&tx_bufs,
+				     (const struct spi_buf_set *)&rx_bufs);
+		if (ret) {
+			LOG_ERR("Write SPI STATUS2 QE=1 spi_transceive"
+				" failure: error %d", ret);
+			return ret;
+		}
+
+		/* Write to volatile status is fast, expect BUSY to be clear */
+		safbuf[0] = SPI_READ_STATUS1;
+		memset(safbuf2, 0, 4U);
+
+		txb.buf = &safbuf;
+		txb.len = 1U;
+
+		tx_bufs.buffers = (const struct spi_buf *)&txb;
+		tx_bufs.count = 1U;
+
+		rxb.buf = &safbuf2;
+		/* read 2 bytes both will be STATUS1 */
+		rxb.len = 2U;
+
+		rx_bufs.buffers = (const struct spi_buf *)&rxb;
+		rx_bufs.count = 1U;
+
+		ret = spi_transceive(qspi_dev,
+				     (const struct spi_config *)&spi_cfg,
+				     (const struct spi_buf_set *)&tx_bufs,
+				     (const struct spi_buf_set *)&rx_bufs);
+		if (ret) {
+			LOG_ERR("Read SPI STATUS1 spi_transceive"
+				" failure: error %d", ret);
+			return ret;
+		}
+
+		spi_status1 = safbuf2[0];
+		if (spi_status1 & SPI_STATUS1_BUSY) {
+			LOG_ERR("SPI BUSY set after write to volatile STATUS2:"
+				" STATUS1=0x%02X", spi_status1);
+			return ret;
+		}
+
+		/* Read STATUS2 to make sure QE is set */
+		safbuf[0] = SPI_READ_STATUS2;
+		memset(safbuf2, 0, 4U);
+
+		txb.buf = &safbuf;
+		txb.len = 1U;
+
+		tx_bufs.buffers = (const struct spi_buf *)&txb;
+		tx_bufs.count = 1U;
+
+		rxb.buf = &safbuf2;
+		/* read 2 bytes both will be STATUS2 */
+		rxb.len = 2U;
+
+		rx_bufs.buffers = (const struct spi_buf *)&rxb;
+		rx_bufs.count = 1U;
+
+		ret = spi_transceive(qspi_dev,
+				     (const struct spi_config *)&spi_cfg,
+				     (const struct spi_buf_set *)&tx_bufs,
+				     (const struct spi_buf_set *)&rx_bufs);
+		if (ret) {
+			LOG_ERR("Read 2 of SPI STATUS2  spi_transceive"
+				" failure: error %d", ret);
+			return ret;
+		}
+
+		spi_status2 = safbuf2[0];
+		if (!(spi_status2 & SPI_STATUS2_QE)) {
+			LOG_ERR("Read back of SPI STATUS2 after setting "
+				"volatile QE bit shows QE not set: 0x%02X",
+				spi_status2);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int espi_saf_init(void)
+{
+	int ret;
+
+	ret = espi_saf_config(espi_saf_dev, (struct espi_saf_cfg *)&saf_cfg1);
+	if (ret) {
+		LOG_ERR("Failed to configure eSPI SAF error %d", ret);
+	} else {
+		LOG_INF("eSPI SAF configured successfully!");
+	}
+
+	ret = espi_saf_set_protection_regions(espi_saf_dev,
+					      &saf_pr_w25q128);
+	if (ret) {
+		LOG_ERR("Failed to set SAF protection region(s) %d", ret);
+	} else {
+		LOG_INF("eSPI SAF protection regions(s) configured!");
+	}
+
+	return ret;
+}
+
+static int pr_check_range(struct mchp_espi_saf *regs,
+			  const struct espi_saf_pr *pr)
+{
+	uint32_t limit;
+
+	limit = pr->start + pr->size - 1U;
+
+	/* registers b[19:0] = bits[31:12] (align on 4KB) */
+	if (regs->SAF_PROT_RG[pr->pr_num].START != (pr->start >> 12)) {
+		return -1;
+	}
+
+	if (regs->SAF_PROT_RG[pr->pr_num].LIMIT != (limit >> 12)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int pr_check_enable(struct mchp_espi_saf *regs,
+			   const struct espi_saf_pr *pr)
+{
+	if (pr->flags & MCHP_SAF_PR_FLAG_ENABLE) {
+		if (regs->SAF_PROT_RG[pr->pr_num].LIMIT >
+		    regs->SAF_PROT_RG[pr->pr_num].START) {
+			return 0;
+		}
+	} else {
+		if (regs->SAF_PROT_RG[pr->pr_num].START >
+		    regs->SAF_PROT_RG[pr->pr_num].LIMIT) {
+			return 0;
+		}
+	}
+
+	return -2;
+}
+
+static int pr_check_lock(struct mchp_espi_saf *regs,
+			 const struct espi_saf_pr *pr)
+{
+	if (pr->flags & MCHP_SAF_PR_FLAG_LOCK) {
+		if (regs->SAF_PROT_LOCK & BIT(pr->pr_num)) {
+			return 0;
+		}
+	} else {
+		if (!(regs->SAF_PROT_LOCK & BIT(pr->pr_num))) {
+			return 0;
+		}
+	}
+
+	return -3;
+}
+
+/*
+ * NOTE: bit[0] of bit map registers is read-only = 1
+ */
+static int pr_check_master_bm(struct mchp_espi_saf *regs,
+			      const struct espi_saf_pr *pr)
+{
+	if (regs->SAF_PROT_RG[pr->pr_num].WEBM !=
+	    (pr->master_bm_we | BIT(0))) {
+		return -4;
+	}
+
+	if (regs->SAF_PROT_RG[pr->pr_num].RDBM !=
+	    (pr->master_bm_rd | BIT(0))) {
+		return -4;
+	}
+
+	return 0;
+}
+
+static int espi_saf_test_pr1(const struct espi_saf_protection *spr)
+{
+	struct mchp_espi_saf *saf_regs;
+	const struct espi_saf_pr *pr;
+	int rc;
+
+	LOG_INF("espi_saf_test_pr1");
+
+	if (spr == NULL) {
+		return 0;
+	}
+
+	saf_regs = (struct mchp_espi_saf *)(SAF_BASE_ADDR);
+	pr = spr->pregions;
+
+	for (size_t n = 0U; n < spr->nregions; n++) {
+		rc = pr_check_range(saf_regs, pr);
+		if (rc) {
+			LOG_INF("SAF Protection region %u range fail",
+				pr->pr_num);
+			return rc;
+		}
+
+		rc = pr_check_enable(saf_regs, pr);
+		if (rc) {
+			LOG_INF("SAF Protection region %u enable fail",
+				pr->pr_num);
+			return rc;
+		}
+
+		rc = pr_check_lock(saf_regs, pr);
+		if (rc) {
+			LOG_INF("SAF Protection region %u lock check fail",
+				pr->pr_num);
+			return rc;
+		}
+
+		rc = pr_check_master_bm(saf_regs, pr);
+		if (rc) {
+			LOG_INF("SAF Protection region %u Master select fail",
+				pr->pr_num);
+			return rc;
+		}
+
+		pr++;
+	}
+
+	return 0;
+}
+
+/*
+ * SAF hardware limited to 1 to 64 byte read requests.
+ */
+static int saf_read(uint32_t spi_addr, uint8_t *dest, int len)
+{
+	int rc, chunk_len, n;
+	struct espi_saf_packet saf_pkt = { 0 };
+
+	if ((dest == NULL) || (len < 0)) {
+		return -EINVAL;
+	}
+
+	saf_pkt.flash_addr = spi_addr;
+	saf_pkt.buf = dest;
+
+	n = len;
+	while (n) {
+		chunk_len = 64;
+		if (n < 64) {
+			chunk_len = n;
+		}
+
+		saf_pkt.len = chunk_len;
+
+		rc = espi_saf_flash_read(espi_saf_dev, &saf_pkt);
+		if (rc != 0) {
+			LOG_INF("%s: error = %d: chunk_len = %d "
+				"spi_addr = %x", __func__, rc, chunk_len,
+				spi_addr);
+			return rc;
+		}
+
+		saf_pkt.flash_addr += chunk_len;
+		saf_pkt.buf += chunk_len;
+		n -= chunk_len;
+	}
+
+	return len;
+}
+
+/*
+ * SAF hardware limited to 4KB(mandatory), 32KB, and 64KB erase sizes.
+ * eSPI configuration has flags the Host can read specifying supported
+ * erase sizes.
+ */
+static int saf_erase_block(uint32_t spi_addr, enum saf_erase_size ersz)
+{
+	int rc;
+	struct espi_saf_packet saf_pkt = { 0 };
+
+	switch (ersz) {
+	case SAF_ERASE_4K:
+		saf_pkt.len = 4096U;
+		spi_addr &= ~(4096U - 1U);
+		break;
+	case SAF_ERASE_32K:
+		saf_pkt.len = (32U * 1024U);
+		spi_addr &= ~((32U * 1024U) - 1U);
+		break;
+	case SAF_ERASE_64K:
+		saf_pkt.len = (64U * 1024U);
+		spi_addr &= ~((64U * 1024U) - 1U);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	saf_pkt.flash_addr = spi_addr;
+
+	rc = espi_saf_flash_erase(espi_saf_dev, &saf_pkt);
+	if (rc != 0) {
+		LOG_INF("espi_saf_test1: erase fail = %d", rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+/*
+ * SAF hardware limited to 1 to 64 byte programming within a 256 byte page.
+ */
+static int saf_page_prog(uint32_t spi_addr, const uint8_t *src, int progsz)
+{
+	int rc, chunk_len, n;
+	struct espi_saf_packet saf_pkt = { 0 };
+
+	if ((src == NULL) || (progsz < 0) || (progsz > 256)) {
+		return -EINVAL;
+	}
+
+	if (progsz == 0) {
+		return 0;
+	}
+
+	saf_pkt.flash_addr = spi_addr;
+	saf_pkt.buf = (uint8_t *)src;
+
+	n = progsz;
+	while (n) {
+		chunk_len = 64;
+		if (n < 64) {
+			chunk_len = n;
+		}
+
+		saf_pkt.len = (uint32_t)chunk_len;
+
+		rc = espi_saf_flash_write(espi_saf_dev, &saf_pkt);
+		if (rc != 0) {
+			LOG_INF("%s: error = %d: erase fail spi_addr = 0x%X",
+				__func__, rc, spi_addr);
+			return rc;
+		}
+
+		saf_pkt.flash_addr += chunk_len;
+		saf_pkt.buf += chunk_len;
+		n -= chunk_len;
+	}
+
+	return progsz;
+}
+
+
+int espi_saf_test1(uint32_t spi_addr)
+{
+	int rc, retries;
+	bool erased;
+	uint32_t n, saddr, progsz, chunksz;
+
+	rc = espi_saf_activate(espi_saf_dev);
+	LOG_INF("%s: activate = %d", __func__, rc);
+
+	if (spi_addr & 0xfffU) {
+		LOG_INF("%s: SPI address 0x%08x not 4KB aligned", __func__,
+			spi_addr);
+		spi_addr &= ~(4096U-1U);
+		LOG_INF("%s: Aligned SPI address to 0x%08x", __func__,
+			spi_addr);
+	}
+
+	memset(safbuf, 0x55, sizeof(safbuf));
+	memset(safbuf2, 0, sizeof(safbuf2));
+
+	erased = false;
+	retries = 3;
+	while (!erased && (retries-- > 0)) {
+		/* read 4KB sector at 0 */
+		rc = saf_read(spi_addr, safbuf, 4096);
+		if (rc != 4096) {
+			LOG_INF("%s: error=%d Read 4K sector at 0x%X failed",
+				__func__, rc, spi_addr);
+			return rc;
+		}
+
+		rc = 0;
+		for (n = 0; n < 4096U; n++) {
+			if (safbuf[n] != 0xffUL) {
+				rc = -1;
+				break;
+			}
+		}
+
+		if (rc == 0) {
+			LOG_INF("4KB sector at 0x%x is in erased state. "
+				"Continue tests", spi_addr);
+			erased = true;
+		} else {
+			LOG_INF("4KB sector at 0x%x not in erased state. "
+				"Send 4K erase.", spi_addr);
+			rc = saf_erase_block(spi_addr, SAF_ERASE_4K);
+			if (rc != 0) {
+				LOG_INF("SAF erase block at 0x%x returned "
+					"error %d", spi_addr, rc);
+				return rc;
+			}
+		}
+	}
+
+	if (!erased) {
+		LOG_INF("%s: Could not erase 4KB sector at 0x%08x",
+			__func__, spi_addr);
+		return -1;
+	}
+
+	/*
+	 * Page program test pattern every 256 bytes = 0,1,...,255
+	 */
+	for (n = 0; n < 4096U; n++) {
+		safbuf[n] = n % 256U;
+	}
+
+	/* SPI flash sector erase size is 4KB, page program is 256 bytes */
+	progsz = 4096U;
+	chunksz = 256U;
+	saddr = spi_addr;
+	n = 0;
+	const uint8_t *src = (const uint8_t *)safbuf;
+
+	LOG_INF("%s: Program 4KB sector at 0x%X", __func__, saddr);
+
+	while (n < progsz) {
+		rc = saf_page_prog(saddr, (const uint8_t *)src,
+				   (int)chunksz);
+		if (rc != chunksz) {
+			LOG_INF("saf_page_prog error=%d at 0x%X", rc,
+				saddr);
+			break;
+		}
+		saddr += chunksz;
+		n += chunksz;
+		src += chunksz;
+	}
+
+	/* read back and check */
+	LOG_INF("%s: Read back 4K sector at 0x%X", __func__, spi_addr);
+
+	rc = saf_read(spi_addr, safbuf2, progsz);
+	if (rc == progsz) {
+		rc = memcmp(safbuf, safbuf2, progsz);
+		if (rc == 0) {
+			LOG_INF("%s: Read back match: PASS", __func__);
+		} else {
+			LOG_INF("%s: Read back mismatch: FAIL", __func__);
+		}
+	} else {
+		LOG_INF("%s: Read back 4K error=%d", __func__, rc);
+		return rc;
+	}
+
+	return rc;
+}
+#endif /* #ifdef CONFIG_ESPI_SAF */
+
 static void host_warn_handler(uint32_t signal, uint32_t status)
 {
 	switch (signal) {
@@ -519,6 +1232,20 @@ int espi_test(void)
 		return -1;
 	}
 
+#ifdef CONFIG_ESPI_SAF
+	qspi_dev = device_get_binding(SPI_DEV);
+	if (!qspi_dev) {
+		LOG_WRN("Fail to find %s", SPI_DEV);
+		return -1;
+	}
+
+	espi_saf_dev = device_get_binding(ESPI_SAF_DEV);
+	if (!espi_saf_dev) {
+		LOG_WRN("Fail to find %s", ESPI_SAF_DEV);
+		return -1;
+	}
+#endif
+
 	LOG_INF("Hello eSPI test %s", CONFIG_BOARD);
 
 #if DT_NODE_HAS_STATUS(BRD_PWR_NODE, okay)
@@ -548,6 +1275,36 @@ int espi_test(void)
 
 	espi_init();
 
+#ifdef CONFIG_ESPI_SAF
+	/*
+	 * eSPI SAF configuration must be after eSPI configuration.
+	 * eSPI SAF EC portal flash tests before EC releases RSMRST# and
+	 * Host de-asserts ESPI_RESET#.
+	 */
+	ret = spi_saf_init();
+	if (ret) {
+		LOG_ERR("Unable to configure %d:%s", ret, SPI_DEV);
+		return ret;
+	}
+
+	ret = espi_saf_init();
+	if (ret) {
+		LOG_ERR("Unable to configure %d:%s", ret, ESPI_SAF_DEV);
+		return ret;
+	}
+
+
+	ret = espi_saf_test_pr1(&saf_pr_w25q128);
+	if (ret) {
+		LOG_INF("eSPI SAF test pr1 returned error %d", ret);
+	}
+
+	ret = espi_saf_test1(SAF_SPI_TEST_ADDRESS);
+	if (ret) {
+		LOG_INF("eSPI SAF test1 returned error %d", ret);
+	}
+#endif
+
 #if DT_NODE_HAS_STATUS(BRD_PWR_NODE, okay)
 	ret = wait_for_pin(pwrgd_dev, BRD_PWR_PWRGD_PIN,
 			   PWR_SEQ_TIMEOUT, 1);
-- 
2.17.1


From fb3e2989eab0ce3082dd1c2ed3f3e86e2337191c Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Wed, 12 Aug 2020 11:10:51 -0700
Subject: [PATCH 17/36] drivers: espi_saf: xec: Instrument eSPI SAF driver for
 debug

Add traces for common error cases.
Add verbose debugging traces.
Clarify timeout timing values.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_saf_mchp_xec.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/drivers/espi/espi_saf_mchp_xec.c b/drivers/espi/espi_saf_mchp_xec.c
index d5545a4382..043c7b6985 100644
--- a/drivers/espi/espi_saf_mchp_xec.c
+++ b/drivers/espi/espi_saf_mchp_xec.c
@@ -20,8 +20,8 @@ LOG_MODULE_REGISTER(espi_saf, CONFIG_ESPI_LOG_LEVEL);
 /* SAF EC Portal read/write flash access limited to 1-64 bytes */
 #define MAX_SAF_ECP_BUFFER_SIZE 64ul
 
-/* 1 second maximum for flash operations */
-#define MAX_SAF_FLASH_TIMEOUT 125000ul /* 1000ul */
+/* 1 s maximum for flash operations. Each iteration is 8 us */
+#define MAX_SAF_FLASH_TIMEOUT 125000ul
 
 /* 64 bytes @ 24MHz quad is approx. 6 us */
 #define SAF_WAIT_INTERVAL 8
@@ -217,6 +217,7 @@ static int saf_qmspi_init(const struct espi_saf_xec_config *xcfg,
 
 	qmode = regs->MODE;
 	if (!(qmode & MCHP_QMSPI_M_ACTIVATE)) {
+		LOG_ERR("%s QMSPI mode re-activated: %x", __func__, regs->MODE);
 		return -EAGAIN;
 	}
 
@@ -231,10 +232,13 @@ static int saf_qmspi_init(const struct espi_saf_xec_config *xcfg,
 	regs->IFCTRL =
 		(MCHP_QMSPI_IFC_WP_OUT_HI | MCHP_QMSPI_IFC_WP_OUT_EN |
 		 MCHP_QMSPI_IFC_HOLD_OUT_HI | MCHP_QMSPI_IFC_HOLD_OUT_EN);
+	LOG_DBG("QMSPI IFCTRL %x", regs->IFCTRL);
 
 	for (n = 0; n < MCHP_SAF_NUM_GENERIC_DESCR; n++) {
 		regs->DESCR[MCHP_SAF_CM_EXIT_START_DESCR + n] =
 			hwcfg->generic_descr[n];
+		LOG_DBG("QMSPI DESC %d %x", MCHP_SAF_CM_EXIT_START_DESCR+n,
+			regs->DESCR[MCHP_SAF_CM_EXIT_START_DESCR+n]);
 	}
 
 	regs->IEN = MCHP_QMSPI_IEN_XFR_DONE;
@@ -259,6 +263,7 @@ static int saf_qmspi_init(const struct espi_saf_xec_config *xcfg,
 
 	regs->MODE = qmode;
 	regs->CSTM = cstim;
+	LOG_DBG("CSTM: %x qmode:%x", regs->CSTM, qmode);
 
 	return 0;
 }
@@ -352,6 +357,8 @@ static void saf_flash_misc_cfg(MCHP_SAF_HW_REGS *regs, uint8_t cs,
 {
 	uint32_t d, v;
 
+	LOG_DBG("%s cs: %d prefix: %x flags: %x", __func__, cs,
+		fcfg->cont_prefix, fcfg->flags);
 	d = regs->SAF_FL_CFG_MISC;
 
 	v = MCHP_SAF_FL_CFG_MISC_CS0_CPE;
@@ -408,6 +415,12 @@ static void saf_flash_cfg(const struct device *dev,
 	regs->SAF_CS_OP[cs].OPC = fcfg->opc;
 	regs->SAF_CS_OP[cs].OP_DESCR = (uint32_t)fcfg->cs_cfg_descr_ids;
 
+	LOG_DBG("OPA WRITE %p %x", &regs->SAF_CS_OP[cs].OPA,
+		regs->SAF_CS_OP[cs].OPA);
+	LOG_DBG("OPB ERASE %p %x", &regs->SAF_CS_OP[cs].OPB,
+		regs->SAF_CS_OP[cs].OPB);
+	LOG_DBG("OPC READ  %p %x", &regs->SAF_CS_OP[cs].OPC,
+		regs->SAF_CS_OP[cs].OPC);
 	did = MCHP_SAF_QMSPI_CS0_START_DESCR;
 	if (cs != 0) {
 		did = MCHP_SAF_QMSPI_CS1_START_DESCR;
@@ -418,6 +431,7 @@ static void saf_flash_cfg(const struct device *dev,
 		d |= (((did + 1) << MCHP_QMSPI_C_NEXT_DESCR_POS) &
 		      MCHP_QMSPI_C_NEXT_DESCR_MASK);
 		qregs->DESCR[did++] = d;
+		LOG_DBG("DESCR[%d]=0x%08x", did, d);
 	}
 
 	mchp_saf_poll2_mask_wr(regs, cs, fcfg->poll2_mask);
@@ -473,10 +487,13 @@ static int espi_saf_xec_configuration(const struct device *dev,
 
 	if ((fcfg == NULL) || (cfg->nflash_devices == 0U) ||
 	    (cfg->nflash_devices > MCHP_SAF_MAX_FLASH_DEVICES)) {
+		LOG_ERR("Invalid SAF cfg: flash devices");
 		return -EINVAL;
 	}
 
 	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		LOG_ERR("%s %x configure after activation\n", __func__,
+		       regs->SAF_FL_CFG_MISC);
 		return -EAGAIN;
 	}
 
@@ -491,6 +508,8 @@ static int espi_saf_xec_configuration(const struct device *dev,
 	totalsz = fcfg->flashsz;
 	regs->SAF_FL_CFG_THRH = totalsz;
 	saf_flash_cfg(dev, fcfg, 0);
+	LOG_DBG("SAF_CS0_CFG_P2M %x", regs->SAF_CS0_CFG_P2M);
+	LOG_DBG("SAF_CS1_CFG_P2M %x", regs->SAF_CS1_CFG_P2M);
 
 	/* optional second flash device connected to CS1 */
 	if (cfg->nflash_devices > 1) {
-- 
2.17.1


From a43f8b32efdcc69e44effc295a360587f9a4d775 Mon Sep 17 00:00:00 2001
From: Kunal Shah <kunal.a.shah@intel.com>
Date: Wed, 3 Mar 2021 17:06:31 +0530
Subject: [PATCH 18/36] espi:driver: espi ltr support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

LTR stands for “Latency Tolerance Report”.
This feature allows the EC slave to declare an upper bound on
latency through the chipset. The effect of setting a Latency Tolerance
is to restrict the low-power states that the chipset may enter.

LTR needs to be programmed only after Bus Mastering is enabled by eSPI master
using peripheral configuration message.

This patch will send LTR message to the eSPI Master and also provides callback
on reception of bus master enabling from espi master.

Signed-off-by: Kunal Shah <kunal.a.shah@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 38 ++++++++++++++++++--
 include/drivers/espi.h       | 70 ++++++++++++++++++++++++++++++++++++
 2 files changed, 106 insertions(+), 2 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 22adbf7b93..6b96f01df5 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -415,7 +415,26 @@ static int espi_xec_write_lpc_request(const struct device *dev,
 
 	return 0;
 }
+static int espi_xec_send_ltr(const struct device *dev, struct ltr_cfg_pkt *req)
+{
+	if (!(ESPI_PC_REGS->PC_STATUS & MCHP_ESPI_PC_STS_BM_EN)) {
+		return -ENOTSUP;
+	}
+
+	if (req->ltr_req) {
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_VAL |
+				(req->latency << MCHP_ESPI_LTR_MSG_VAL_POS) |
+				(req->ltr_scale << MCHP_ESPI_LTR_MSG_SC_POS);
+	} else {
+		/* set infinite latency tolrated */
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_INF;
+	}
 
+	/* Send LTR Packet */
+	ESPI_LTR_REGS->LTR_CTRL = MCHP_ESPI_LTR_CTRL_START;
+
+	return 0;
+}
 static int espi_xec_send_vwire(const struct device *dev,
 			       enum espi_vwire_signal signal, uint8_t level)
 {
@@ -919,6 +938,10 @@ static void setup_espi_io_config(const struct device *dev,
 static void espi_pc_isr(const struct device *dev)
 {
 	uint32_t status = ESPI_PC_REGS->PC_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_CHANNEL_READY,
+				  .evt_details = ESPI_CHANNEL_PERIPHERAL,
+				  .evt_data = 0 };
+	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
 
 	if (status & MCHP_ESPI_PC_STS_EN_CHG) {
 		if (status & MCHP_ESPI_PC_STS_EN) {
@@ -926,6 +949,13 @@ static void espi_pc_isr(const struct device *dev)
 		}
 
 		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
+	} else if (status & MCHP_ESPI_PC_STS_BM_EN_CHG) {
+		if (status & MCHP_ESPI_PC_STS_BM_EN) {
+			evt.evt_data = ESPI_PC_EVT_BUS_MASTER_ENABLE;
+			espi_send_callbacks(&data->callbacks, dev, evt);
+		}
+
+		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_BM_EN_CHG;
 	}
 }
 
@@ -1352,6 +1382,7 @@ static const struct espi_driver_api espi_xec_driver_api = {
 	.manage_callback = espi_xec_manage_callback,
 	.read_lpc_request = espi_xec_read_lpc_request,
 	.write_lpc_request = espi_xec_write_lpc_request,
+	.send_ltr = espi_xec_send_ltr,
 };
 
 static struct espi_xec_data espi_xec_data;
@@ -1413,8 +1444,11 @@ static int espi_xec_init(const struct device *dev)
 	/* Clear reset interrupt status and enable interrupts */
 	ESPI_CAP_REGS->ERST_STS = MCHP_ESPI_RST_ISTS;
 	ESPI_CAP_REGS->ERST_IEN |= MCHP_ESPI_RST_IEN;
-	ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
-	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG;
+	ESPI_PC_REGS->PC_STATUS |= MCHP_ESPI_PC_STS_EN_CHG |
+				 MCHP_ESPI_PC_STS_BM_EN_CHG;
+	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG |
+				MCHP_ESPI_PC_IEN_BM_EN_CHG;
+
 
 	/* Enable VWires interrupts */
 	for (int i = 0; i < sizeof(vw_wires_int_en); i++) {
diff --git a/include/drivers/espi.h b/include/drivers/espi.h
index e9a9aa111d..20a2216b94 100644
--- a/include/drivers/espi.h
+++ b/include/drivers/espi.h
@@ -115,6 +115,30 @@ enum espi_bus_event {
 	ESPI_BUS_PERIPHERAL_NOTIFICATION    = BIT(4),
 };
 
+/**
+ * @brief eSPI LTR Scale
+ *
+ * eSPI LTR scale value used for LTR register programming
+ */
+enum espi_ltr_scale {
+	ESPI_LTR_SCALE_1NSEC = 0,
+	ESPI_LTR_SCALE_32NSEC = BIT(0),
+	ESPI_LTR_SCALE_1024NSEC = BIT(1),
+	ESPI_LTR_SCALE_32USEC = BIT(0) | BIT(1),
+	ESPI_LTR_SCALE_1MSEC = BIT(2),
+	ESPI_LTR_SCALE_33MSEC = BIT(0) | BIT(2),
+};
+
+/**
+ * @brief eSPI peripheral channel events.
+ *
+ * eSPI peripheral channel event types to indicate users.
+ */
+enum espi_pc_event {
+	ESPI_PC_EVT_BUS_CHANNEL_READY = BIT(0),
+	ESPI_PC_EVT_BUS_MASTER_ENABLE = BIT(1),
+};
+
 /**
  * @cond INTERNAL_HIDDEN
  *
@@ -305,6 +329,18 @@ struct espi_flash_packet {
 	uint16_t len;
 };
 
+/**
+ * @brief eSPI LTR configuration parameters
+ */
+struct ltr_cfg_pkt {
+	/** Latency scale */
+	enum espi_ltr_scale ltr_scale;
+	/** Latency value in unit of scale */
+	uint16_t latency;
+	/** LTR Required bit 1-ltr as per scale, 0 -Infinite latency */
+	uint8_t ltr_req;
+};
+
 struct espi_callback;
 
 /**
@@ -367,6 +403,8 @@ typedef int (*espi_api_lpc_read_request)(const struct device *dev,
 typedef int (*espi_api_lpc_write_request)(const struct device *dev,
 					  enum lpc_peripheral_opcode op,
 					  uint32_t *data);
+typedef int (*espi_api_ltr_write_request)(const struct device *dev,
+					  struct ltr_cfg_pkt *req);
 /* Logical Channel 1 APIs */
 typedef int (*espi_api_send_vwire)(const struct device *dev,
 				   enum espi_vwire_signal vw,
@@ -398,6 +436,7 @@ __subsystem struct espi_driver_api {
 	espi_api_write_request write_request;
 	espi_api_lpc_read_request read_lpc_request;
 	espi_api_lpc_write_request write_lpc_request;
+	espi_api_ltr_write_request send_ltr;
 	espi_api_send_vwire send_vwire;
 	espi_api_receive_vwire receive_vwire;
 	espi_api_send_oob send_oob;
@@ -620,6 +659,37 @@ static inline int z_impl_espi_write_lpc_request(const struct device *dev,
 	return api->write_lpc_request(dev, op, data);
 }
 
+
+/**
+ * @brief Send LTR request to eSPI host which generates an eSPI transaction.
+ *
+ * This routine provides a generic interface to send ltr value to eSPI host
+ * which triggers an eSPI transaction. The eSPI packet is assembled by the
+ * hardware block.
+ *
+ * @param dev Pointer to the device structure for the driver instance.
+ * @param req Address of a structure representing LTR configuration request.
+ *
+ * @retval 0 If successful.
+ * @retval -ENOTSUP espi master has not enabled LTR.
+ */
+__syscall int espi_send_ltr(const struct device *dev,
+			    struct ltr_cfg_pkt *req);
+
+static inline int z_impl_espi_send_ltr(const struct device *dev,
+				       struct ltr_cfg_pkt *req)
+{
+	const struct espi_driver_api *api =
+		(const struct espi_driver_api *)dev->api;
+
+	if (!api->send_ltr) {
+		return -ENOTSUP;
+	}
+
+	return api->send_ltr(dev, req);
+}
+
+
 /**
  * @brief Sends system/platform signal as a virtual wire packet.
  *
-- 
2.17.1


From 8c58c9251b363990519e3dacd81134b02defa64b Mon Sep 17 00:00:00 2001
From: Diwakar C <diwakar.c@intel.com>
Date: Wed, 17 Feb 2021 20:21:11 +0530
Subject: [PATCH 19/36] espi: driver: Config spare espi vw register to OCP
 index

USBC port (port 0/1/2/3) OCP (Over Current Protection) status should
be sent to PCH over eSPI VW index 0x50h. But there is no dedicated
VW register mapped to VW index 0x50h.

In this patch, configuring spare VW register SMVW06 to OCP VW index
50h.

Signed-off-by: Diwakar C <diwakar.c@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 42 ++++++++++++++++++++++++++++++++++++
 include/drivers/espi.h       |  5 +++++
 2 files changed, 47 insertions(+)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 6b96f01df5..34a6eb5ff7 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -56,6 +56,9 @@
 #define MAX_OOB_BUFFER_SIZE         128ul
 #define MAX_SLAVE_BUFFER_SIZE       128ul
 
+/* VM index 0x50 for OCB */
+#define ESPI_OCB_VW_INDEX		0x50u
+
 LOG_MODULE_REGISTER(espi, CONFIG_ESPI_LOG_LEVEL);
 
 struct espi_isr {
@@ -134,6 +137,7 @@ enum mchp_smvw_regs {
  *  46h   | SMVW05 | generic      | generic      | generic   | generic     |
  *  47h   | MSVW07 | res          | res          | res       | HOST_C10    |
  *  4Ah   | MSVW08 | res          | res          | DNX_WARN  | res         |
+ *  50h   | SMVW06 | ESPI_OCB_3   | ESPI_OCB_2   | ESPI_OCB_1| ESPI_OCB_0  |
  */
 
 static const struct xec_signal vw_tbl[] = {
@@ -202,6 +206,15 @@ static const struct xec_signal vw_tbl[] = {
 	/* MSVW08 */
 	[ESPI_VWIRE_SIGNAL_DNX_WARN]      = {MCHP_MSVW08, ESPI_VWIRE_SRC_ID1,
 					     ESPI_MASTER_TO_SLAVE},
+	/* SMVW06 */
+	[ESPI_VWIRE_SIGNAL_OCB_0]       = {MCHP_SMVW06, ESPI_VWIRE_SRC_ID0,
+					     ESPI_SLAVE_TO_MASTER},
+	[ESPI_VWIRE_SIGNAL_OCB_1]       = {MCHP_SMVW06, ESPI_VWIRE_SRC_ID1,
+					     ESPI_SLAVE_TO_MASTER},
+	[ESPI_VWIRE_SIGNAL_OCB_2]       = {MCHP_SMVW06, ESPI_VWIRE_SRC_ID2,
+					     ESPI_SLAVE_TO_MASTER},
+	[ESPI_VWIRE_SIGNAL_OCB_3]       = {MCHP_SMVW06, ESPI_VWIRE_SRC_ID3,
+					     ESPI_SLAVE_TO_MASTER},
 };
 
 static uint32_t slave_rx_mem[MAX_OOB_BUFFER_SIZE];
@@ -812,6 +825,29 @@ static void espi_bus_init(const struct device *dev)
 		MCHP_ESPI_VW_EN_GIRQ_VAL | MCHP_ESPI_PC_GIRQ_VAL;
 }
 
+void espi_config_vw_ocb(void)
+{
+	ESPI_SMVW_REG *reg = &(ESPI_S2M_VW_REGS->SMVW06);
+
+	/* Keep index bits [7:0] in initial 0h value (disabled state) */
+	mec_espi_smvw_index_set(reg, 0);
+	/* Set 01b (eSPI_RESET# domain) into bits [9:8] which frees the
+	 * register from all except chip level resets and set initial state
+	 * of VW wires as 1111b in bits [15:12].
+	 */
+	mec_espi_msvw_stom_set(reg, VW_RST_SRC_ESPI_RESET, 0x1);
+	/* Set 4 SMVW SRC bits in bit positions [0], [8], [16] and [24] to
+	 * initial value '1'.
+	 */
+	mec_espi_smvw_set_all_bitmap(reg, 0xF);
+	/* Set 00b (eSPI_RESET# domain) into bits [9:8] while preserving
+	 * the values in bits [15:12].
+	 */
+	mec_espi_msvw_stom_set(reg, VW_RST_SRC_ESPI_RESET, 0x0);
+	/* Set INDEX field with OCB VW index */
+	mec_espi_smvw_index_set(reg, ESPI_OCB_VW_INDEX);
+}
+
 static void espi_rst_isr(const struct device *dev)
 {
 	uint8_t rst_sts;
@@ -1177,6 +1213,12 @@ static void vw_host_rst_warn_isr(const struct device *dev)
 static void vw_sus_warn_isr(const struct device *dev)
 {
 	notify_host_warning(dev, ESPI_VWIRE_SIGNAL_SUS_WARN);
+	/* Configure spare VW register SMVW06 to VW index 50h. As per
+	 * per microchip recommendation, spare VW register should be
+	 * configured between SLAVE_BOOT_LOAD_DONE = 1 VW event and
+	 * point where SUS_ACK=1 VW is sent to SOC.
+	 */
+	espi_config_vw_ocb();
 }
 
 static void vw_oob_rst_isr(const struct device *dev)
diff --git a/include/drivers/espi.h b/include/drivers/espi.h
index 20a2216b94..57473e6baf 100644
--- a/include/drivers/espi.h
+++ b/include/drivers/espi.h
@@ -239,6 +239,11 @@ enum espi_vwire_signal {
 	ESPI_VWIRE_SIGNAL_SCI,
 	ESPI_VWIRE_SIGNAL_DNX_ACK,
 	ESPI_VWIRE_SIGNAL_SUS_ACK,
+	/* USB-C port over current */
+	ESPI_VWIRE_SIGNAL_OCB_0,
+	ESPI_VWIRE_SIGNAL_OCB_1,
+	ESPI_VWIRE_SIGNAL_OCB_2,
+	ESPI_VWIRE_SIGNAL_OCB_3,
 };
 
 /* eSPI LPC peripherals. */
-- 
2.17.1


From a518249d38a8f0539f7eb3090ae33311607b882f Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Fri, 12 Feb 2021 16:11:13 -0800
Subject: [PATCH 20/36] boards: arm: mec1501_modular: Use internal pull-up for
 keyboard matrix inputs

Even though possible to use external pull-up and open drain buffer,
prefer internal pull-up to reduce power consumption.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 boards/arm/mec1501modular_assy6885/pinmux.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/boards/arm/mec1501modular_assy6885/pinmux.c b/boards/arm/mec1501modular_assy6885/pinmux.c
index cedc844884..1362b58e45 100644
--- a/boards/arm/mec1501modular_assy6885/pinmux.c
+++ b/boards/arm/mec1501modular_assy6885/pinmux.c
@@ -383,28 +383,28 @@ static int board_pinmux_init(const struct device *dev)
 
 	/* KSCAN KSI00 */
 	pinmux_pin_set(porta, MCHP_GPIO_017,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI01 */
 	pinmux_pin_set(porta, MCHP_GPIO_020,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI02 */
 	pinmux_pin_set(porta, MCHP_GPIO_021,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI03 */
 	pinmux_pin_set(porta, MCHP_GPIO_026,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI04 */
 	pinmux_pin_set(porta, MCHP_GPIO_027,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI05 */
 	pinmux_pin_set(porta, MCHP_GPIO_030,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI06 */
 	pinmux_pin_set(porta, MCHP_GPIO_031,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 	/* KSCAN KSI07 */
 	pinmux_pin_set(porta, MCHP_GPIO_032,
-		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_BUFT_OPENDRAIN);
+		       MCHP_GPIO_CTRL_MUX_F1 | MCHP_GPIO_CTRL_PUD_PU);
 #endif /* CONFIG_KSCAN_XEC */
 
 #ifdef CONFIG_PECI_XEC
-- 
2.17.1


From 506cb8d5a91dcffc72be5bd76275ac00f051e4e1 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 4 Mar 2021 10:34:49 -0800
Subject: [PATCH 21/36] drivers: gpio: mchp: Add support for GPIO disconnected
 flag

Currently, if GPIO_DISCONNECTED flag is used pin remains as input,
this causes some additional power to be drain which is
undesired.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/gpio/gpio_mchp_xec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/gpio/gpio_mchp_xec.c b/drivers/gpio/gpio_mchp_xec.c
index 40a1091b2f..acf6b85915 100644
--- a/drivers/gpio/gpio_mchp_xec.c
+++ b/drivers/gpio/gpio_mchp_xec.c
@@ -133,6 +133,13 @@ static int gpio_xec_configure(const struct device *dev,
 		mask = MCHP_GPIO_CTRL_DIR_MASK;
 		pcr1 = MCHP_GPIO_CTRL_DIR_OUTPUT;
 		*current_pcr1 = (*current_pcr1 & ~mask) | pcr1;
+	} else if ((flags & GPIO_INPUT) != 0U) {
+		/* Already configured */
+	} else {
+		/*  GPIO disconnected */
+		mask |= MCHP_GPIO_CTRL_PWRG_MASK;
+		pcr1 |= MCHP_GPIO_CTRL_PWRG_OFF;
+		*current_pcr1 = (*current_pcr1 & ~mask) | pcr1;
 	}
 
 	return 0;
-- 
2.17.1


From 92c6804496b36b17c014c145028e266b80e38e0c Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Fri, 5 Mar 2021 15:03:11 -0800
Subject: [PATCH 22/36] drivers: espi: xec: Reduce buffer allocation to minimum
 required

Update eSPI buffer to values required per eSPI specification.
Allow applications to override as needed.
Guarantee buffers are not allocated at all if channels are
disabled.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/Kconfig.xec     | 17 ++++++++++++++
 drivers/espi/espi_mchp_xec.c | 43 ++++++++++++++++++++++--------------
 2 files changed, 43 insertions(+), 17 deletions(-)

diff --git a/drivers/espi/Kconfig.xec b/drivers/espi/Kconfig.xec
index debbc921bd..6614a54a82 100644
--- a/drivers/espi/Kconfig.xec
+++ b/drivers/espi/Kconfig.xec
@@ -37,6 +37,23 @@ config ESPI_PERIPHERAL_UART_SOC_MAPPING
 	  This tells the driver to which SoC UART to direct the UART traffic
 	  send over eSPI from host.
 
+config ESPI_OOB_BUFFER_SIZE
+	int "eSPI OOB channel buffer size in bytes"
+	default 128
+	depends on ESPI_OOB_CHANNEL
+	help
+	  Use minimum RAM buffer size by default but allow applications to
+	  override the value.
+	  Maximum OOB payload is 73 bytes.
+
+config ESPI_FLASH_BUFFER_SIZE
+	int "eSPI Flash channel buffer size in bytes"
+	default 256
+	depends on ESPI_FLASH_CHANNEL
+	help
+	  Use maximum RAM buffer size defined by spec but allow applications
+	  to override if eSPI host doesn't support it.
+
 config ESPI_SAF
 	bool "XEC Microchip ESPI SAF driver"
 	depends on ESPI_FLASH_CHANNEL
diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 34a6eb5ff7..4aa8edb07d 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -53,9 +53,6 @@
 #define UART_DEFAULT_IRQ_POS	    2u
 #define UART_DEFAULT_IRQ	    BIT(UART_DEFAULT_IRQ_POS)
 
-#define MAX_OOB_BUFFER_SIZE         128ul
-#define MAX_SLAVE_BUFFER_SIZE       128ul
-
 /* VM index 0x50 for OCB */
 #define ESPI_OCB_VW_INDEX		0x50u
 
@@ -217,9 +214,13 @@ static const struct xec_signal vw_tbl[] = {
 					     ESPI_SLAVE_TO_MASTER},
 };
 
-static uint32_t slave_rx_mem[MAX_OOB_BUFFER_SIZE];
-static uint32_t slave_tx_mem[MAX_OOB_BUFFER_SIZE];
-static uint32_t slave_mem[MAX_SLAVE_BUFFER_SIZE];
+#ifdef CONFIG_ESPI_OOB_CHANNEL
+static uint32_t target_rx_mem[CONFIG_ESPI_OOB_BUFFER_SIZE >> 2];
+static uint32_t target_tx_mem[CONFIG_ESPI_OOB_BUFFER_SIZE >> 2];
+#endif
+#ifdef CONFIG_ESPI_FLASH_CHANNEL
+static uint32_t target_mem[CONFIG_ESPI_FLASH_BUFFER_SIZE >> 2];
+#endif
 
 static int espi_xec_configure(const struct device *dev, struct espi_cfg *cfg)
 {
@@ -511,6 +512,7 @@ static int espi_xec_receive_vwire(const struct device *dev,
 	return 0;
 }
 
+#ifdef CONFIG_ESPI_OOB_CHANNEL
 static int espi_xec_send_oob(const struct device *dev,
 			     struct espi_oob_packet *pckt)
 {
@@ -532,12 +534,12 @@ static int espi_xec_send_oob(const struct device *dev,
 		return -EBUSY;
 	}
 
-	if (pckt->len > MAX_OOB_BUFFER_SIZE) {
+	if (pckt->len > CONFIG_ESPI_OOB_BUFFER_SIZE) {
 		LOG_ERR("insufficient space");
 		return -EINVAL;
 	}
 
-	memcpy(slave_tx_mem, pckt->buf, pckt->len);
+	memcpy(target_tx_mem, pckt->buf, pckt->len);
 
 	ESPI_OOB_REGS->TX_LEN = pckt->len;
 	ESPI_OOB_REGS->TX_CTRL = MCHP_ESPI_OOB_TX_CTRL_START;
@@ -587,8 +589,8 @@ static int espi_xec_receive_oob(const struct device *dev,
 	}
 
 	pckt->len = rcvd_len;
-	memcpy(pckt->buf, slave_rx_mem, pckt->len);
-	memset(slave_rx_mem, 0, pckt->len);
+	memcpy(pckt->buf, target_rx_mem, pckt->len);
+	memset(target_rx_mem, 0, pckt->len);
 
 	/* Only after data has been copied from SRAM, indicate channel
 	 * is available for next packet
@@ -597,7 +599,9 @@ static int espi_xec_receive_oob(const struct device *dev,
 
 	return 0;
 }
+#endif /* CONFIG_ESPI_OOB_CHANNEL */
 
+#ifdef CONFIG_ESPI_FLASH_CHANNEL
 static int espi_xec_flash_read(const struct device *dev,
 			       struct espi_flash_packet *pckt)
 {
@@ -615,7 +619,7 @@ static int espi_xec_flash_read(const struct device *dev,
 		return -EIO;
 	}
 
-	if (pckt->len > MAX_SLAVE_BUFFER_SIZE) {
+	if (pckt->len > CONFIG_ESPI_FLASH_BUFFER_SIZE) {
 		LOG_ERR("Invalid size request");
 		return -EINVAL;
 	}
@@ -623,7 +627,7 @@ static int espi_xec_flash_read(const struct device *dev,
 	ESPI_FC_REGS->FL_ADDR_MSW = 0;
 	ESPI_FC_REGS->FL_ADDR_LSW = pckt->flash_addr;
 	ESPI_FC_REGS->MEM_ADDR_MSW = 0;
-	ESPI_FC_REGS->MEM_ADDR_LSW = (uint32_t)&slave_mem[0];
+	ESPI_FC_REGS->MEM_ADDR_LSW = (uint32_t)&target_mem[0];
 	ESPI_FC_REGS->XFR_LEN = pckt->len;
 	ESPI_FC_REGS->CTRL = MCHP_ESPI_FC_CTRL_FUNC(MCHP_ESPI_FC_CTRL_RD0);
 	ESPI_FC_REGS->CTRL |= MCHP_ESPI_FC_CTRL_START;
@@ -641,7 +645,7 @@ static int espi_xec_flash_read(const struct device *dev,
 		return -EIO;
 	}
 
-	memcpy(pckt->buf, slave_mem, pckt->len);
+	memcpy(pckt->buf, target_mem, pckt->len);
 
 	return 0;
 }
@@ -669,12 +673,12 @@ static int espi_xec_flash_write(const struct device *dev,
 		return -EBUSY;
 	}
 
-	memcpy(slave_mem, pckt->buf, pckt->len);
+	memcpy(target_mem, pckt->buf, pckt->len);
 
 	ESPI_FC_REGS->FL_ADDR_MSW = 0;
 	ESPI_FC_REGS->FL_ADDR_LSW = pckt->flash_addr;
 	ESPI_FC_REGS->MEM_ADDR_MSW = 0;
-	ESPI_FC_REGS->MEM_ADDR_LSW = (uint32_t)&slave_mem[0];
+	ESPI_FC_REGS->MEM_ADDR_LSW = (uint32_t)&target_mem[0];
 	ESPI_FC_REGS->XFR_LEN = pckt->len;
 	ESPI_FC_REGS->CTRL = MCHP_ESPI_FC_CTRL_FUNC(MCHP_ESPI_FC_CTRL_WR0);
 	ESPI_FC_REGS->CTRL |= MCHP_ESPI_FC_CTRL_START;
@@ -744,6 +748,7 @@ static int espi_xec_flash_erase(const struct device *dev,
 
 	return 0;
 }
+#endif /* CONFIG_ESPI_FLASH_CHANNEL */
 
 static int espi_xec_manage_callback(const struct device *dev,
 				    struct espi_callback *callback, bool set)
@@ -781,8 +786,8 @@ static void espi_init_oob(const struct device *dev)
 
 	ESPI_OOB_REGS->TX_ADDR_MSW = 0;
 	ESPI_OOB_REGS->RX_ADDR_MSW = 0;
-	ESPI_OOB_REGS->TX_ADDR_LSW = (uint32_t)&slave_tx_mem[0];
-	ESPI_OOB_REGS->RX_ADDR_LSW = (uint32_t)&slave_rx_mem[0];
+	ESPI_OOB_REGS->TX_ADDR_LSW = (uint32_t)&target_tx_mem[0];
+	ESPI_OOB_REGS->RX_ADDR_LSW = (uint32_t)&target_rx_mem[0];
 	ESPI_OOB_REGS->RX_LEN = 0x00FF0000;
 
 	/* Enable OOB Tx channel enable change status interrupt */
@@ -1416,11 +1421,15 @@ static const struct espi_driver_api espi_xec_driver_api = {
 	.get_channel_status = espi_xec_channel_ready,
 	.send_vwire = espi_xec_send_vwire,
 	.receive_vwire = espi_xec_receive_vwire,
+#ifdef CONFIG_ESPI_OOB_CHANNEL
 	.send_oob = espi_xec_send_oob,
 	.receive_oob = espi_xec_receive_oob,
+#endif
+#ifdef CONFIG_ESPI_FLASH_CHANNEL
 	.flash_read = espi_xec_flash_read,
 	.flash_write = espi_xec_flash_write,
 	.flash_erase = espi_xec_flash_erase,
+#endif
 	.manage_callback = espi_xec_manage_callback,
 	.read_lpc_request = espi_xec_read_lpc_request,
 	.write_lpc_request = espi_xec_write_lpc_request,
-- 
2.17.1


From 16c722411941587be99a69b99efafdf44d350a1e Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Tue, 13 Apr 2021 12:40:20 -0700
Subject: [PATCH 23/36] samples: drivers: espi: Ensure sample code thread exits

Fix #32457 by decreasing iterations on failure too.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 samples/drivers/espi/src/espi_oob_handler.c | 11 +++++++----
 samples/drivers/espi/src/main.c             |  3 +--
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/samples/drivers/espi/src/espi_oob_handler.c b/samples/drivers/espi/src/espi_oob_handler.c
index dc95d8d89e..44e0dd8a56 100644
--- a/samples/drivers/espi/src/espi_oob_handler.c
+++ b/samples/drivers/espi/src/espi_oob_handler.c
@@ -45,6 +45,7 @@ struct thread_context {
 };
 
 static struct thread_context context;
+static bool need_temp;
 #endif
 
 static struct espi_oob_packet resp_pckt;
@@ -164,8 +165,6 @@ void oob_rx_handler(const struct device *dev, struct espi_callback *cb,
 }
 
 
-bool need_temp;
-
 void temperature_timer(struct k_timer *timer_id)
 {
 	LOG_WRN("%s", __func__);
@@ -196,19 +195,23 @@ void espihub_thread(void *p1, void *p2, void *p3)
 					LOG_ERR("Incorrect size response");
 				}
 
-				context.cycles--;
 				break;
 			default:
 				LOG_INF("Other host sender %x", sender);
 			}
-
+		} else {
+			LOG_ERR("Failure to retrieve temp %d", ret);
 		}
 
+		/* Decrease cycles in both cases failure/success */
+		context.cycles--;
+
 		if (need_temp) {
 			request_temp(context.espi_dev);
 			need_temp = false;
 		}
 	}
+
 	k_timer_stop(&temp_timer);
 }
 #endif /* CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC */
diff --git a/samples/drivers/espi/src/main.c b/samples/drivers/espi/src/main.c
index 61bcfda988..9c51b10497 100644
--- a/samples/drivers/espi/src/main.c
+++ b/samples/drivers/espi/src/main.c
@@ -14,9 +14,8 @@
 #include <drivers/spi.h>
 #include <logging/log_ctrl.h>
 #include <logging/log.h>
-#ifdef CONFIG_ESPI_OOB_CHANNEL
+/* OOB operations will be attempted regardless of channel enabled or not */
 #include "espi_oob_handler.h"
-#endif
 LOG_MODULE_DECLARE(espi, CONFIG_ESPI_LOG_LEVEL);
 
 /* eSPI flash parameters */
-- 
2.17.1


From 17c9da69635b9b14327a6ead6a814f631fe89a88 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 7 Jun 2021 11:14:04 -0700
Subject: [PATCH 24/36] dts: arm: mchp: Add missing eSPI interrupt

eSPI controller can generate another IRQ for extended/custom
virtual wires.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/arm/microchip/mec1501hsz.dtsi | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dts/arm/microchip/mec1501hsz.dtsi b/dts/arm/microchip/mec1501hsz.dtsi
index 0630f594bb..08576d005b 100644
--- a/dts/arm/microchip/mec1501hsz.dtsi
+++ b/dts/arm/microchip/mec1501hsz.dtsi
@@ -228,7 +228,7 @@
 		espi0: espi@400f3400 {
 			compatible = "microchip,xec-espi";
 			reg = <0x400f3400 0x400>;
-			interrupts = <11 3>, <15 3>, <7 3>;
+			interrupts = <11 3>, <15 3>, <7 3>, <16 3>;
 			label = "ESPI_0";
 			#address-cells = <1>;
 			#size-cells = <0>;
-- 
2.17.1


From 4b080de11a9b97aedc3460895b41ff71030f99c7 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 7 Jun 2021 11:15:40 -0700
Subject: [PATCH 25/36] dts: bindings: mchp: Convert vw_irq to array

Micropchip eSPI controller can generate 2 different IRQ for
virtual wires.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 dts/bindings/espi/microchip,xec-espi.yaml | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dts/bindings/espi/microchip,xec-espi.yaml b/dts/bindings/espi/microchip,xec-espi.yaml
index e3ea49a33b..0c0700975e 100644
--- a/dts/bindings/espi/microchip,xec-espi.yaml
+++ b/dts/bindings/espi/microchip,xec-espi.yaml
@@ -17,9 +17,9 @@ properties:
       description: soc group irq index for eSPI I/O
       required: true
 
-    vw_girq:
-      type: int
-      description: soc group irq index for eSPI virtual wires channel
+    vw_girqs:
+      type: array
+      description: soc group irq indexes for eSPI virtual wires channel
       required: true
 
     pc_girq:
-- 
2.17.1


From c1a72302f2359adc49d116adc7ec5fc7c5bbae51 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Mon, 7 Jun 2021 11:17:38 -0700
Subject: [PATCH 26/36] boards: arm: mec15xx: Add missing virtual wire GIRQ

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts | 2 +-
 boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts         | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts b/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts
index 5b6cb317cc..4457bf018b 100644
--- a/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts
+++ b/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts
@@ -71,7 +71,7 @@
 &espi0 {
 	status = "okay";
 	io_girq = <19>;
-	vw_girq = <24>;
+	vw_girqs = <24 25>;
 	pc_girq = <15>;
 };
 
diff --git a/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts b/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts
index 8db6cdfd17..a69c026e8c 100644
--- a/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts
+++ b/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts
@@ -121,7 +121,7 @@
 &espi0 {
 	status = "okay";
 	io_girq = <19>;
-	vw_girq = <24>;
+	vw_girqs = <24 25>;
 	pc_girq = <15>;
 };
 
-- 
2.17.1


From 2457fdf4681cd96eeb2ee813a9cab960635250e1 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Thu, 3 Jun 2021 11:35:19 -0700
Subject: [PATCH 27/36] drivers: espi: Propagate eSPI host DnX warning to
 driver's client

Propagate Download and Execute (DnX) entry warning.
Add missing handler for SUS warning power down ack.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 64 ++++++++++++++++++++++++++++++++----
 1 file changed, 58 insertions(+), 6 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index 4aa8edb07d..d7ca5c06d5 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -21,6 +21,10 @@
  */
 #define ESPI_XEC_VWIRE_SEND_TIMEOUT 100ul
 
+#define VW_MAX_GIRQS                2ul
+/* Missing HAL value */
+#define MEC_ESPI_MSVW08_SRC1_VAL    5ul
+
 /* 200ms */
 #define MAX_OOB_TIMEOUT             200ul
 /* 1s */
@@ -66,7 +70,7 @@ struct espi_isr {
 struct espi_xec_config {
 	uint32_t base_addr;
 	uint8_t bus_girq_id;
-	uint8_t vw_girq_id;
+	uint8_t vw_girq_ids[VW_MAX_GIRQS];
 	uint8_t pc_girq_id;
 };
 
@@ -1231,6 +1235,11 @@ static void vw_oob_rst_isr(const struct device *dev)
 	notify_host_warning(dev, ESPI_VWIRE_SIGNAL_OOB_RST_WARN);
 }
 
+static void vw_sus_pwrdn_ack_isr(const struct device *dev)
+{
+	notify_system_state(dev, ESPI_VWIRE_SIGNAL_SUS_PWRDN_ACK);
+}
+
 static void vw_sus_slp_a_isr(const struct device *dev)
 {
 	notify_system_state(dev, ESPI_VWIRE_SIGNAL_SLP_A);
@@ -1327,6 +1336,7 @@ uint8_t vw_wires_int_en[] = {
 	ESPI_VWIRE_SIGNAL_HOST_RST_WARN,
 	ESPI_VWIRE_SIGNAL_SUS_WARN,
 	ESPI_VWIRE_SIGNAL_SUS_PWRDN_ACK,
+	ESPI_VWIRE_SIGNAL_DNX_WARN,
 };
 
 const struct espi_isr m2s_vwires_isr[] = {
@@ -1337,6 +1347,7 @@ const struct espi_isr m2s_vwires_isr[] = {
 	{MEC_ESPI_MSVW01_SRC2_VAL, vw_oob_rst_isr},
 	{MEC_ESPI_MSVW02_SRC0_VAL, vw_host_rst_warn_isr},
 	{MEC_ESPI_MSVW03_SRC0_VAL, vw_sus_warn_isr},
+	{MEC_ESPI_MSVW03_SRC1_VAL, vw_sus_pwrdn_ack_isr},
 	{MEC_ESPI_MSVW03_SRC3_VAL, vw_sus_slp_a_isr},
 };
 
@@ -1380,8 +1391,8 @@ static void espi_xec_vw_isr(const struct device *dev)
 	const struct espi_xec_config *config = dev->config;
 	uint32_t girq_result;
 
-	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_id);
-	MCHP_GIRQ_SRC(config->vw_girq_id) = girq_result;
+	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_ids[0]);
+	MCHP_GIRQ_SRC(config->vw_girq_ids[0]) = girq_result;
 
 	for (int i = 0; i < m2s_vwires_isr_cnt; i++) {
 		struct espi_isr entry = m2s_vwires_isr[i];
@@ -1394,6 +1405,36 @@ static void espi_xec_vw_isr(const struct device *dev)
 	}
 }
 
+#if DT_INST_PROP_HAS_IDX(0, vw_girqs, 1)
+static void vw_sus_dnx_warn_isr(const struct device *dev)
+{
+	notify_system_state(dev, ESPI_VWIRE_SIGNAL_DNX_WARN);
+}
+
+const struct espi_isr m2s_vwires_ext_isr[] = {
+	{MEC_ESPI_MSVW08_SRC1_VAL, vw_sus_dnx_warn_isr}
+};
+
+static void espi_xec_vw_ext_isr(const struct device *dev)
+{
+	const struct espi_xec_config *config = dev->config;
+	uint32_t girq_result;
+
+	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_ids[1]);
+	MCHP_GIRQ_SRC(config->vw_girq_ids[1]) = girq_result;
+
+	for (int i = 0; i < ARRAY_SIZE(m2s_vwires_ext_isr); i++) {
+		struct espi_isr entry = m2s_vwires_isr[i];
+
+		if (girq_result & entry.girq_bit) {
+			if (entry.the_isr != NULL) {
+				entry.the_isr(dev);
+			}
+		}
+	}
+}
+#endif
+
 static void espi_xec_periph_isr(const struct device *dev)
 {
 	const struct espi_xec_config *config = dev->config;
@@ -1441,7 +1482,8 @@ static struct espi_xec_data espi_xec_data;
 static const struct espi_xec_config espi_xec_config = {
 	.base_addr = DT_INST_REG_ADDR(0),
 	.bus_girq_id = DT_INST_PROP(0, io_girq),
-	.vw_girq_id = DT_INST_PROP(0, vw_girq),
+	.vw_girq_ids[0] = DT_INST_PROP_BY_IDX(0, vw_girqs, 0),
+	.vw_girq_ids[1] = DT_INST_PROP_BY_IDX(0, vw_girqs, 1),
 	.pc_girq_id = DT_INST_PROP(0, pc_girq),
 };
 
@@ -1523,7 +1565,7 @@ static int espi_xec_init(const struct device *dev)
 	espi_init_flash(dev);
 #endif
 	/* Enable aggregated block interrupts for VWires */
-	MCHP_GIRQ_ENSET(config->vw_girq_id) = MEC_ESPI_MSVW00_SRC0_VAL |
+	MCHP_GIRQ_ENSET(config->vw_girq_ids[0]) = MEC_ESPI_MSVW00_SRC0_VAL |
 		MEC_ESPI_MSVW00_SRC1_VAL | MEC_ESPI_MSVW00_SRC2_VAL |
 		MEC_ESPI_MSVW01_SRC1_VAL | MEC_ESPI_MSVW01_SRC2_VAL |
 		MEC_ESPI_MSVW02_SRC0_VAL | MEC_ESPI_MSVW03_SRC0_VAL;
@@ -1552,7 +1594,7 @@ static int espi_xec_init(const struct device *dev)
 	irq_enable(DT_INST_IRQN(0));
 
 	/* Enable aggregated interrupt block for eSPI VWire events */
-	MCHP_GIRQ_BLK_SETEN(config->vw_girq_id);
+	MCHP_GIRQ_BLK_SETEN(config->vw_girq_ids[0]);
 	IRQ_CONNECT(DT_INST_IRQ_BY_IDX(0, 1, irq),
 		    DT_INST_IRQ_BY_IDX(0, 1, priority),
 		    espi_xec_vw_isr,
@@ -1567,5 +1609,15 @@ static int espi_xec_init(const struct device *dev)
 		    DEVICE_DT_INST_GET(0), 0);
 	irq_enable(DT_INST_IRQ_BY_IDX(0, 2, irq));
 
+#if DT_INST_PROP_HAS_IDX(0, vw_girqs, 1)
+	MCHP_GIRQ_ENSET(config->vw_girq_ids[1]) = MEC_ESPI_MSVW08_SRC1_VAL;
+	MCHP_GIRQ_BLK_SETEN(config->vw_girq_ids[1]);
+	IRQ_CONNECT(DT_INST_IRQ_BY_IDX(0, 3, irq),
+		    DT_INST_IRQ_BY_IDX(0, 3, priority),
+		    espi_xec_vw_ext_isr,
+		    DEVICE_DT_INST_GET(0), 0);
+	irq_enable(DT_INST_IRQ_BY_IDX(0, 3, irq));
+#endif
+
 	return 0;
 }
-- 
2.17.1


From ad84175a5d73907ec5d62e6a63db11a7453908e2 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Wed, 9 Jun 2021 12:27:18 -0700
Subject: [PATCH 28/36] drivers: espi: eSPI host DnX propagation fixes

Correct MEC15xx HAL value for DnX warn.
For consistency add automatic ack into the driver.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_mchp_xec.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index d7ca5c06d5..43fb1bfecc 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -23,7 +23,7 @@
 
 #define VW_MAX_GIRQS                2ul
 /* Missing HAL value */
-#define MEC_ESPI_MSVW08_SRC1_VAL    5ul
+#define MEC_ESPI_MSVW08_SRC1_VAL    BIT(5)
 
 /* 200ms */
 #define MAX_OOB_TIMEOUT             200ul
@@ -1179,6 +1179,10 @@ static void notify_host_warning(const struct device *dev,
 		espi_send_callbacks(&data->callbacks, dev, evt);
 	} else {
 		k_busy_wait(ESPI_XEC_VWIRE_ACK_DELAY);
+		/* Some flows are dependent on awareness of client's driver
+		 * about these warnings in such cases these automatic response
+		 * should not be enabled.
+		 */
 		switch (signal) {
 		case ESPI_VWIRE_SIGNAL_HOST_RST_WARN:
 			espi_xec_send_vwire(dev,
@@ -1193,6 +1197,10 @@ static void notify_host_warning(const struct device *dev,
 			espi_xec_send_vwire(dev, ESPI_VWIRE_SIGNAL_OOB_RST_ACK,
 					    status);
 			break;
+		case ESPI_VWIRE_SIGNAL_DNX_WARN:
+			espi_xec_send_vwire(dev, ESPI_VWIRE_SIGNAL_DNX_ACK,
+					    status);
+			break;
 		default:
 			break;
 		}
@@ -1408,7 +1416,7 @@ static void espi_xec_vw_isr(const struct device *dev)
 #if DT_INST_PROP_HAS_IDX(0, vw_girqs, 1)
 static void vw_sus_dnx_warn_isr(const struct device *dev)
 {
-	notify_system_state(dev, ESPI_VWIRE_SIGNAL_DNX_WARN);
+	notify_host_warning(dev, ESPI_VWIRE_SIGNAL_DNX_WARN);
 }
 
 const struct espi_isr m2s_vwires_ext_isr[] = {
@@ -1424,7 +1432,7 @@ static void espi_xec_vw_ext_isr(const struct device *dev)
 	MCHP_GIRQ_SRC(config->vw_girq_ids[1]) = girq_result;
 
 	for (int i = 0; i < ARRAY_SIZE(m2s_vwires_ext_isr); i++) {
-		struct espi_isr entry = m2s_vwires_isr[i];
+		struct espi_isr entry = m2s_vwires_ext_isr[i];
 
 		if (girq_result & entry.girq_bit) {
 			if (entry.the_isr != NULL) {
-- 
2.17.1


From a73a53c5377b1fca6af1e88fe0d5bbe7c133ae45 Mon Sep 17 00:00:00 2001
From: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
Date: Fri, 25 Jun 2021 12:27:24 -0700
Subject: [PATCH 29/36] drivers: espi: saf: Fix deprecated API warning

eSPI SAF driver backporting to v2.4 was using deprecated
macro.
This commit will be obsolote when SAF comes in latest Zephyr.

Signed-off-by: Jose Alberto Meza <jose.a.meza.arellano@intel.com>
---
 drivers/espi/espi_saf_mchp_xec.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/drivers/espi/espi_saf_mchp_xec.c b/drivers/espi/espi_saf_mchp_xec.c
index 043c7b6985..ac35877fd9 100644
--- a/drivers/espi/espi_saf_mchp_xec.c
+++ b/drivers/espi/espi_saf_mchp_xec.c
@@ -870,9 +870,8 @@ static const struct espi_saf_xec_config espi_saf_xec_config = {
 					 MCHP_SAF_FLASH_POLL_INTERVAL),
 };
 
-DEVICE_AND_API_INIT(espi_saf_xec_0, DT_INST_LABEL(0),
-		    &espi_saf_xec_init, &espi_saf_xec_data,
-		    &espi_saf_xec_config,
+DEVICE_DT_INST_DEFINE(0, &espi_saf_xec_init, device_pm_control_nop,
+		    &espi_saf_xec_data, &espi_saf_xec_config,
 		    POST_KERNEL, CONFIG_ESPI_SAF_INIT_PRIORITY,
 		    &espi_saf_xec_driver_api);
 
-- 
2.17.1


From b80d730eaebd78cf411e3ab1e55c266f3e1d81c5 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Mon, 9 Aug 2021 12:35:25 +0530
Subject: [PATCH 30/36] drivers: i2c: Mchp: Use GPIO driver to read SCL/SDA
 state

I2C bit-bang control register should not be used to read pin
states when a transaction is open. Hence the driver is
modified to get SCL and SDA pin states using the GPIO
driver. Device tree GPIO pinmux nodes added to I2C driver.

Signed-off-by: Scott Worley <scott.worley@microchip.com>
Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 .../mec1501modular_assy6885.dts               |  4 +
 .../mec1501modular_assy6885_defconfig         |  1 +
 .../mec15xxevb_assy6853.dts                   |  6 ++
 drivers/i2c/i2c_mchp_xec.c                    | 73 +++++++++++++++++--
 dts/bindings/i2c/microchip,xec-i2c.yaml       | 15 ++++
 5 files changed, 92 insertions(+), 7 deletions(-)

diff --git a/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts b/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts
index 4457bf018b..ad67ed0894 100644
--- a/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts
+++ b/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885.dts
@@ -60,12 +60,16 @@
 	status = "okay";
 	label = "I2C0";
 	port_sel = <0>;
+	sda-gpios = <&gpio_000_036 3 0>;
+	scl-gpios = <&gpio_000_036 4 0>;
 };
 
 &i2c_smb_1 {
 	status = "okay";
 	label = "I2C1";
 	port_sel = <1>;
+	sda-gpios = <&gpio_100_136 24 0>;
+	scl-gpios = <&gpio_100_136 25 0>;
 };
 
 &espi0 {
diff --git a/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885_defconfig b/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885_defconfig
index 9818b0c11f..49e269f91d 100644
--- a/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885_defconfig
+++ b/boards/arm/mec1501modular_assy6885/mec1501modular_assy6885_defconfig
@@ -23,6 +23,7 @@ CONFIG_PWM=y
 CONFIG_SENSOR=y
 CONFIG_I2C=y
 CONFIG_I2C_INIT_PRIORITY=60
+CONFIG_I2C_SLAVE_INIT_PRIORITY=61
 CONFIG_ESPI=y
 CONFIG_ESPI_PERIPHERAL_UART_SOC_MAPPING=1
 
diff --git a/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts b/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts
index a69c026e8c..7b8a492ef2 100644
--- a/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts
+++ b/boards/arm/mec15xxevb_assy6853/mec15xxevb_assy6853.dts
@@ -87,6 +87,8 @@
 	status = "okay";
 	label = "I2C0";
 	port_sel = <0>;
+	sda-gpios = <&gpio_000_036 3 0>;
+	scl-gpios = <&gpio_000_036 4 0>;
 
 	pca9555@26 {
 		compatible = "nxp,pca95xx";
@@ -110,12 +112,16 @@
 	status = "okay";
 	label = "I2C1";
 	port_sel = <1>;
+	sda-gpios = <&gpio_100_136 24 0>;
+	scl-gpios = <&gpio_100_136 25 0>;
 };
 
 &i2c_smb_2 {
 	status = "okay";
 	label = "I2C7";
 	port_sel = <7>;
+	sda-gpios = <&gpio_000_036 10 0>;
+	scl-gpios = <&gpio_000_036 11 0>;
 };
 
 &espi0 {
diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index c06b47d62e..400aabeeae 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -10,6 +10,7 @@
 #include <kernel.h>
 #include <soc.h>
 #include <errno.h>
+#include <drivers/gpio.h>
 #include <drivers/i2c.h>
 #include <logging/log.h>
 LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
@@ -28,6 +29,11 @@ LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
 /* I2C Read/Write bit pos */
 #define I2C_READ_WRITE_POS  0
 
+/* lines */
+#define I2C_LINES_SCL_HI	BIT(0)
+#define I2C_LINES_SDA_HI	BIT(1)
+#define I2C_LINES_BOTH_HI	(I2C_LINES_SCL_HI | I2C_LINES_SDA_HI)
+
 struct xec_speed_cfg {
 	uint32_t bus_clk;
 	uint32_t data_timing;
@@ -41,12 +47,18 @@ struct i2c_xec_config {
 	uint32_t base_addr;
 	uint8_t girq_id;
 	uint8_t girq_bit;
+	uint8_t sda_pos;
+	uint8_t scl_pos;
+	const char *sda_gpio_label;
+	const char *scl_gpio_label;
 	void (*irq_config_func)(void);
 };
 
 struct i2c_xec_data {
 	uint32_t pending_stop;
 	uint32_t speed_id;
+	const struct device *sda_gpio;
+	const struct device *scl_gpio;
 	struct i2c_slave_config *slave_cfg;
 	bool slave_attached;
 	bool slave_read;
@@ -243,10 +255,40 @@ static int wait_completion(const struct device *dev)
 	return 0;
 }
 
-static bool check_lines(uint32_t ba)
+/*
+ * Call GPIO driver to read state of pins.
+ * Return boolean true if both lines HIGH else return boolean false
+ */
+static bool check_lines_high(const struct device *dev)
 {
-	return ((!(MCHP_I2C_SMB_BB_CTRL(ba) & MCHP_I2C_SMB_BB_CLKI_RO)) ||
-		(!(MCHP_I2C_SMB_BB_CTRL(ba) & MCHP_I2C_SMB_BB_DATI_RO)));
+	const struct i2c_xec_config *config =
+		(const struct i2c_xec_config *const)(dev->config);
+	struct i2c_xec_data *data = (struct i2c_xec_data *const)(dev->data);
+	uint32_t i2c_lines = 0U;
+	gpio_port_value_t sda = 0, scl = 0;
+
+	if (gpio_port_get_raw(data->sda_gpio, &sda)) {
+		return false;
+	}
+
+	if (sda & BIT(config->sda_pos)) {
+		i2c_lines |= I2C_LINES_SDA_HI;
+	}
+
+	/* both pins on same GPIO port? */
+	if (data->sda_gpio == data->scl_gpio) {
+		scl = sda;
+	} else {
+		if (gpio_port_get_raw(data->scl_gpio, &scl)) {
+			return false;
+		}
+	}
+
+	if (scl & BIT(config->scl_pos)) {
+		i2c_lines |= I2C_LINES_SCL_HI;
+	}
+
+	return (i2c_lines == I2C_LINES_BOTH_HI) ? true : false;
 }
 
 static int i2c_xec_configure(const struct device *dev,
@@ -293,8 +335,8 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 	int ret;
 
 	if (data->pending_stop == 0) {
-		/* Check clock and data lines */
-		if (check_lines(ba)) {
+		/* Check clock and data lines for HIGH */
+		if (check_lines_high(dev) == false) {
 			return -EBUSY;
 		}
 
@@ -357,8 +399,8 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 	int ret;
 
 	if (!(msg.flags & I2C_MSG_RESTART)) {
-		/* Check clock and data lines */
-		if (check_lines(ba)) {
+		/* Check clock and data lines for HIGH */
+		if (check_lines_high(dev) == false) {
 			return -EBUSY;
 		}
 
@@ -617,6 +659,7 @@ static const struct i2c_driver_api i2c_xec_driver_api = {
 
 static int i2c_xec_init(const struct device *dev)
 {
+	const struct i2c_xec_config *cfg = dev->config;
 	struct i2c_xec_data *data =
 		(struct i2c_xec_data *const) (dev->data);
 	int ret;
@@ -624,6 +667,18 @@ static int i2c_xec_init(const struct device *dev)
 	data->pending_stop = 0;
 	data->slave_attached = false;
 
+	data->sda_gpio = device_get_binding(cfg->sda_gpio_label);
+	if (!data->sda_gpio) {
+		LOG_ERR("i2c configure failed to bind SDA GPIO");
+		return -ENXIO;
+	}
+
+	data->scl_gpio = device_get_binding(cfg->scl_gpio_label);
+	if (!data->scl_gpio) {
+		LOG_ERR("i2c configure failed to bind SCL GPIO");
+		return -ENXIO;
+	}
+
 	/* Default configuration */
 	ret = i2c_xec_configure(dev,
 				I2C_MODE_MASTER |
@@ -652,6 +707,10 @@ static int i2c_xec_init(const struct device *dev)
 		.port_sel = DT_INST_PROP(n, port_sel),			\
 		.girq_id = DT_INST_PROP(n, girq),			\
 		.girq_bit = DT_INST_PROP(n, girq_bit),			\
+		.sda_pos = DT_INST_GPIO_PIN(n, sda_gpios),		\
+		.scl_pos = DT_INST_GPIO_PIN(n, scl_gpios),		\
+		.sda_gpio_label = DT_INST_GPIO_LABEL(n, sda_gpios),	\
+		.scl_gpio_label = DT_INST_GPIO_LABEL(n, scl_gpios),	\
 		.irq_config_func = i2c_xec_irq_config_func_##n,		\
 	};								\
 	DEVICE_DT_INST_DEFINE(n, &i2c_xec_init, device_pm_control_nop,	\
diff --git a/dts/bindings/i2c/microchip,xec-i2c.yaml b/dts/bindings/i2c/microchip,xec-i2c.yaml
index dcd22bd468..f8a78abd59 100644
--- a/dts/bindings/i2c/microchip,xec-i2c.yaml
+++ b/dts/bindings/i2c/microchip,xec-i2c.yaml
@@ -25,3 +25,18 @@ properties:
       type: int
       required: true
       description: Bit position in GIRQ for this device
+
+    sda-gpios:
+      type: phandle-array
+      required: true
+      description: |
+        The SDA pin for the selected port. Pin choice for port is
+        determined by chip and package.
+
+    scl-gpios:
+      type: phandle-array
+      required: true
+      description: |
+        The SCL pin for the selected port. Pin choice for port is
+        determined by chip and package.
+
-- 
2.17.1


From e1b2ad0afec518eaabad7d98e05f26dcce1225fe Mon Sep 17 00:00:00 2001
From: Scott Worley <scott.worley@microchip.com>
Date: Thu, 3 Jun 2021 18:27:59 -0400
Subject: [PATCH 31/36] drivers: i2c: mchp: Fix driver NACK policy

If the I2C controller receives a NACK from the target
it should not reset the device. The I2C controller should
issue a STOP to properly terminate the transaction and
return an error code. Some I2C target peripherals have
slow internal processing and will NACK when they cannot
process an I2C request.

Signed-off-by: Scott Worley <scott.worley@microchip.com>
---
 drivers/i2c/i2c_mchp_xec.c | 71 ++++++++++++++++++++++++++++----------
 1 file changed, 53 insertions(+), 18 deletions(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 400aabeeae..5dd02bbe07 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -21,6 +21,7 @@ LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
 
 #define EC_OWN_I2C_ADDR		0x7F
 #define RESET_WAIT_US		20
+#define BUS_IDLE_US_DFLT	5
 
 /* I2C timeout is  10 ms (WAIT_INTERVAL * WAIT_COUNT) */
 #define WAIT_INTERVAL		50
@@ -220,6 +221,25 @@ static int wait_bus_free(const struct device *dev)
 	return 0;
 }
 
+/*
+ * Wait with timeout for I2C controller to finish transmit/receive of one
+ * byte(address or data).
+ * When transmit/receive operation is started the I2C PIN status is 1. Upon
+ * normal completion I2C PIN status asserts(0).
+ * We loop checking I2C status for the following events:
+ * Bus Error:
+ *      Reset controller and return -EBUSY
+ * Lost Arbitration:
+ *      Return -EPERM. We lost bus to another controller. No reset.
+ * PIN == 0: I2C Status LRB is valid and contains ACK/NACK data on 9th clock.
+ *      ACK return 0 (success)
+ *      NACK Issue STOP, wait for bus minimum idle time, return -EIO.
+ * Timeout:
+ *      Reset controller and return -ETIMEDOUT
+ *
+ * NOTE: After generating a STOP the controller will not generate a START until
+ * Bus Minimum Idle time has expired.
+ */
 static int wait_completion(const struct device *dev)
 {
 	const struct i2c_xec_config *config =
@@ -228,28 +248,43 @@ static int wait_completion(const struct device *dev)
 	int counter = 0;
 	uint32_t ba = config->base_addr;
 
-	/* Wait for transaction to be completed */
-	while (MCHP_I2C_SMB_STS_RO(ba) & MCHP_I2C_SMB_STS_PIN) {
-		ret = xec_spin_yield(&counter);
+	while (1) {
+		uint8_t status = MCHP_I2C_SMB_STS_RO(ba);
 
-		if (ret < 0) {
-			if (MCHP_I2C_SMB_STS_RO(ba) & MCHP_I2C_SMB_STS_PIN) {
-				recover_from_error(dev);
-				return ret;
-			}
+		/* Is bus error ? */
+		if (status & MCHP_I2C_SMB_STS_BER) {
+			recover_from_error(dev);
+			return -EBUSY;
 		}
-	}
 
-	/* Check if Slave send ACK/NACK */
-	if (MCHP_I2C_SMB_STS_RO(ba) & MCHP_I2C_SMB_STS_LRB_AD0) {
-		recover_from_error(dev);
-		return -EIO;
-	}
+		/* Is Lost arbitration ? */
+		status = MCHP_I2C_SMB_STS_RO(ba);
+		if (status & MCHP_I2C_SMB_STS_LAB) {
+			return -EPERM;
+		}
 
-	/* Check for bus error */
-	if (MCHP_I2C_SMB_STS_RO(ba) & MCHP_I2C_SMB_STS_BER) {
-		recover_from_error(dev);
-		return -EBUSY;
+		status = MCHP_I2C_SMB_STS_RO(ba);
+		/* PIN -> 0 indicates I2C is done */
+		if (!(status & MCHP_I2C_SMB_STS_PIN)) {
+			/* PIN == 0. LRB contains state of 9th bit */
+			if (status & MCHP_I2C_SMB_STS_LRB_AD0) { /* NACK? */
+				/* Send STOP */
+				MCHP_I2C_SMB_CTRL_WO(ba) =
+						MCHP_I2C_SMB_CTRL_PIN |
+						MCHP_I2C_SMB_CTRL_ESO |
+						MCHP_I2C_SMB_CTRL_STO |
+						MCHP_I2C_SMB_CTRL_ACK;
+				k_busy_wait(BUS_IDLE_US_DFLT);
+				return -EIO;
+			}
+			break; /* success: ACK */
+		}
+
+		ret = xec_spin_yield(&counter);
+		if (ret < 0) {
+			recover_from_error(dev);
+			return ret;
+		}
 	}
 
 	return 0;
-- 
2.17.1


From 792a54a2e2a47b312741cb8b1161f9486febe5ad Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Mon, 9 Aug 2021 13:56:47 +0530
Subject: [PATCH 32/36] drivers: i2c: mchp: Fix controller hang during recovery

Recovery should not be attempted when one of the CLK/DATA
lines are LOW. The failure status should be recorded and
the recovery should be attempted only when both the lines
are HIGH the next time around.

Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 drivers/i2c/i2c_mchp_xec.c | 88 ++++++++++++++++++++++++++++++--------
 1 file changed, 71 insertions(+), 17 deletions(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 5dd02bbe07..115a09a694 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -23,10 +23,14 @@ LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
 #define RESET_WAIT_US		20
 #define BUS_IDLE_US_DFLT	5
 
-/* I2C timeout is  10 ms (WAIT_INTERVAL * WAIT_COUNT) */
+/* I2C timeout is 10 ms (WAIT_INTERVAL * WAIT_COUNT) */
 #define WAIT_INTERVAL		50
 #define WAIT_COUNT		200
 
+/* Line High Timeout is 2.5 ms (WAIT_LINE_HIGH_USEC * WAIT_LINE_HIGH_COUNT) */
+#define WAIT_LINE_HIGH_USEC	25
+#define WAIT_LINE_HIGH_COUNT	100
+
 /* I2C Read/Write bit pos */
 #define I2C_READ_WRITE_POS  0
 
@@ -57,6 +61,7 @@ struct i2c_xec_config {
 
 struct i2c_xec_data {
 	uint32_t pending_stop;
+	uint32_t error_seen;
 	uint32_t speed_id;
 	const struct device *sda_gpio;
 	const struct device *scl_gpio;
@@ -282,7 +287,6 @@ static int wait_completion(const struct device *dev)
 
 		ret = xec_spin_yield(&counter);
 		if (ret < 0) {
-			recover_from_error(dev);
 			return ret;
 		}
 	}
@@ -303,6 +307,7 @@ static bool check_lines_high(const struct device *dev)
 	gpio_port_value_t sda = 0, scl = 0;
 
 	if (gpio_port_get_raw(data->sda_gpio, &sda)) {
+		LOG_DBG("gpio_port_get_raw for %s SDA failed", dev->name);
 		return false;
 	}
 
@@ -315,6 +320,8 @@ static bool check_lines_high(const struct device *dev)
 		scl = sda;
 	} else {
 		if (gpio_port_get_raw(data->scl_gpio, &scl)) {
+			LOG_DBG("gpio_port_get_raw for %s SCL failed",
+				dev->name);
 			return false;
 		}
 	}
@@ -367,17 +374,35 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 	struct i2c_xec_data *data =
 		(struct i2c_xec_data *const) (dev->data);
 	uint32_t ba = config->base_addr;
+	uint8_t i2c_timer = 0;
 	int ret;
 
-	if (data->pending_stop == 0) {
-		/* Check clock and data lines for HIGH */
-		if (check_lines_high(dev) == false) {
-			return -EBUSY;
+	if ((data->pending_stop == 0) || (data->error_seen == 1)) {
+		/* Wait till clock and data lines are HIGH */
+		while (check_lines_high(dev) == false) {
+			if (i2c_timer >= WAIT_LINE_HIGH_COUNT) {
+				LOG_DBG("%s: %s not high",
+					__func__, dev->name);
+				data->error_seen = 1;
+				return -EBUSY;
+			}
+			k_busy_wait(WAIT_LINE_HIGH_USEC);
+			i2c_timer++;
+		}
+
+		if (data->error_seen) {
+			LOG_DBG("%s: Recovering %s previously in error",
+				__func__, dev->name);
+			data->error_seen = 0;
+			recover_from_error(dev);
 		}
 
 		/* Wait until bus is free */
 		ret = wait_bus_free(dev);
 		if (ret) {
+			data->error_seen = 1;
+			LOG_DBG("%s: %s wait_bus_free failure",
+				__func__, dev->name);
 			return ret;
 		}
 
@@ -391,6 +416,9 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 
 		ret = wait_completion(dev);
 		if (ret) {
+			data->error_seen = 1;
+			LOG_DBG("%s: %s wait_completion error for address send",
+				__func__, dev->name);
 			return ret;
 		}
 	}
@@ -400,6 +428,9 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 		MCHP_I2C_SMB_DATA(ba) = msg.buf[i];
 		ret = wait_completion(dev);
 		if (ret) {
+			data->error_seen = 1;
+			LOG_DBG("%s: %s wait_completion error for data send",
+				__func__, dev->name);
 			return ret;
 		}
 
@@ -430,18 +461,35 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 	struct i2c_xec_data *data =
 		(struct i2c_xec_data *const) (dev->data);
 	uint32_t ba = config->base_addr;
-	uint8_t byte, ctrl;
+	uint8_t byte, ctrl, i2c_timer = 0;
 	int ret;
 
-	if (!(msg.flags & I2C_MSG_RESTART)) {
-		/* Check clock and data lines for HIGH */
-		if (check_lines_high(dev) == false) {
-			return -EBUSY;
+	if (!(msg.flags & I2C_MSG_RESTART) || (data->error_seen == 1)) {
+		/* Wait till clock and data lines are HIGH */
+		while (check_lines_high(dev) == false) {
+			if (i2c_timer >= WAIT_LINE_HIGH_COUNT) {
+				LOG_DBG("%s: %s not high",
+					__func__, dev->name);
+				data->error_seen = 1;
+				return -EBUSY;
+			}
+			k_busy_wait(WAIT_LINE_HIGH_USEC);
+			i2c_timer++;
+		}
+
+		if (data->error_seen) {
+			LOG_DBG("%s: Recovering %s previously in error",
+				__func__, dev->name);
+			data->error_seen = 0;
+			recover_from_error(dev);
 		}
 
 		/* Wait until bus is free */
 		ret = wait_bus_free(dev);
 		if (ret) {
+			data->error_seen = 1;
+			LOG_DBG("%s: %s wait_bus_free failure",
+				__func__, dev->name);
 			return ret;
 		}
 	}
@@ -457,6 +505,9 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 
 	ret = wait_completion(dev);
 	if (ret) {
+		data->error_seen = 1;
+		LOG_DBG("%s: %s wait_completion error for address send",
+			__func__, dev->name);
 		return ret;
 	}
 
@@ -469,6 +520,9 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 	byte = MCHP_I2C_SMB_DATA(ba);
 	ret = wait_completion(dev);
 	if (ret) {
+		data->error_seen = 1;
+		LOG_DBG("%s: %s wait_completion error for dummy byte",
+			__func__, dev->name);
 		return ret;
 	}
 
@@ -509,7 +563,7 @@ static int i2c_xec_transfer(const struct device *dev, struct i2c_msg *msgs,
 	struct i2c_xec_data *data = dev->data;
 
 	if (data->slave_attached) {
-		LOG_ERR("Device is registered as slave");
+		LOG_ERR("%s Device is registered as slave", dev->name);
 		return -EBUSY;
 	}
 #endif
@@ -519,13 +573,13 @@ static int i2c_xec_transfer(const struct device *dev, struct i2c_msg *msgs,
 		if ((msgs[i].flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
 			ret = i2c_xec_poll_write(dev, msgs[i], addr);
 			if (ret) {
-				LOG_ERR("Write error: %d", ret);
+				LOG_ERR("%s Write error: %d", dev->name, ret);
 				return ret;
 			}
 		} else {
 			ret = i2c_xec_poll_read(dev, msgs[i], addr);
 			if (ret) {
-				LOG_ERR("Read error: %d", ret);
+				LOG_ERR("%s Read error: %d", dev->name, ret);
 				return ret;
 			}
 		}
@@ -704,13 +758,13 @@ static int i2c_xec_init(const struct device *dev)
 
 	data->sda_gpio = device_get_binding(cfg->sda_gpio_label);
 	if (!data->sda_gpio) {
-		LOG_ERR("i2c configure failed to bind SDA GPIO");
+		LOG_ERR("%s configure failed to bind SDA GPIO", dev->name);
 		return -ENXIO;
 	}
 
 	data->scl_gpio = device_get_binding(cfg->scl_gpio_label);
 	if (!data->scl_gpio) {
-		LOG_ERR("i2c configure failed to bind SCL GPIO");
+		LOG_ERR("%s configure failed to bind SCL GPIO", dev->name);
 		return -ENXIO;
 	}
 
@@ -719,7 +773,7 @@ static int i2c_xec_init(const struct device *dev)
 				I2C_MODE_MASTER |
 				I2C_SPEED_SET(I2C_SPEED_STANDARD));
 	if (ret) {
-		LOG_ERR("i2c configure failed %d", ret);
+		LOG_ERR("%s configure failed %d", dev->name, ret);
 		return ret;
 	}
 
-- 
2.17.1


From 6dfa4cdc7eab8733ed060b34bf244a53f774fe51 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Thu, 19 Aug 2021 20:49:02 +0530
Subject: [PATCH 33/36] drivers: i2c: mchp: Fix NAK handling

If NAK is received for an address, it just means the slave is
not present. If NAK is received for data, it means the reader
is done reading and doesn't need anymore data. In either case,
receiving NAK is not an error.

Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 drivers/i2c/i2c_mchp_xec.c | 45 ++++++++++++++++++++++++++++++--------
 1 file changed, 36 insertions(+), 9 deletions(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 115a09a694..87c4973fff 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -416,9 +416,18 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 
 		ret = wait_completion(dev);
 		if (ret) {
-			data->error_seen = 1;
-			LOG_DBG("%s: %s wait_completion error for address send",
-				__func__, dev->name);
+			switch (ret) {
+			case -EIO:
+				LOG_WRN("%s: No Addr ACK from Slave 0x%x on %s",
+					__func__, addr >> 1, dev->name);
+				break;
+
+			default:
+				data->error_seen = 1;
+				LOG_DBG("%s: %s wait_comp error for addr send",
+					__func__, dev->name);
+				break;
+			}
 			return ret;
 		}
 	}
@@ -428,9 +437,18 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 		MCHP_I2C_SMB_DATA(ba) = msg.buf[i];
 		ret = wait_completion(dev);
 		if (ret) {
-			data->error_seen = 1;
-			LOG_DBG("%s: %s wait_completion error for data send",
-				__func__, dev->name);
+			switch (ret) {
+			case -EIO:
+				LOG_DBG("%s: No Data ACK from Slave 0x%x on %s",
+					__func__, addr >> 1, dev->name);
+				break;
+
+			default:
+				data->error_seen = 1;
+				LOG_DBG("%s: %s wait_completion error for data send",
+					__func__, dev->name);
+				break;
+			}
 			return ret;
 		}
 
@@ -505,9 +523,18 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 
 	ret = wait_completion(dev);
 	if (ret) {
-		data->error_seen = 1;
-		LOG_DBG("%s: %s wait_completion error for address send",
-			__func__, dev->name);
+		switch (ret) {
+		case -EIO:
+			LOG_WRN("%s: No Addr ACK from Slave 0x%x on %s",
+				__func__, addr >> 1, dev->name);
+			break;
+
+		default:
+			data->error_seen = 1;
+			LOG_DBG("%s: %s wait_completion error for address send",
+				__func__, dev->name);
+			break;
+		}
 		return ret;
 	}
 
-- 
2.17.1


From 48015b4f3732382ac7ff573ae2148400819bd868 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Thu, 7 Oct 2021 19:51:44 +0530
Subject: [PATCH 34/36] drivers: i2c: microchip: Increase timeout interval

Increase timeout from 10ms to 40ms.

Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 drivers/i2c/i2c_mchp_xec.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 87c4973fff..0adb711b8e 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -23,9 +23,9 @@ LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
 #define RESET_WAIT_US		20
 #define BUS_IDLE_US_DFLT	5
 
-/* I2C timeout is 10 ms (WAIT_INTERVAL * WAIT_COUNT) */
+/* I2C timeout is 40 ms (WAIT_INTERVAL * WAIT_COUNT) */
 #define WAIT_INTERVAL		50
-#define WAIT_COUNT		200
+#define WAIT_COUNT		800
 
 /* Line High Timeout is 2.5 ms (WAIT_LINE_HIGH_USEC * WAIT_LINE_HIGH_COUNT) */
 #define WAIT_LINE_HIGH_USEC	25
-- 
2.17.1


From 05757821c3a6f5575f8065b07699c4a6494d02a4 Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Thu, 21 Oct 2021 14:42:07 +0530
Subject: [PATCH 35/36] Revert "drivers: i2c: microchip: Increase timeout
 interval"

This reverts commit 019d0c27cfe51b6b8d4c4914fe91fa02384b4389.
---
 drivers/i2c/i2c_mchp_xec.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 0adb711b8e..87c4973fff 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -23,9 +23,9 @@ LOG_MODULE_REGISTER(i2c_mchp, CONFIG_I2C_LOG_LEVEL);
 #define RESET_WAIT_US		20
 #define BUS_IDLE_US_DFLT	5
 
-/* I2C timeout is 40 ms (WAIT_INTERVAL * WAIT_COUNT) */
+/* I2C timeout is 10 ms (WAIT_INTERVAL * WAIT_COUNT) */
 #define WAIT_INTERVAL		50
-#define WAIT_COUNT		800
+#define WAIT_COUNT		200
 
 /* Line High Timeout is 2.5 ms (WAIT_LINE_HIGH_USEC * WAIT_LINE_HIGH_COUNT) */
 #define WAIT_LINE_HIGH_USEC	25
-- 
2.17.1


From f28246e79fd5827aa13d5c968291b927933bf33f Mon Sep 17 00:00:00 2001
From: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
Date: Tue, 12 Oct 2021 12:21:53 +0530
Subject: [PATCH 36/36] drivers: i2c: mchp: Fix Timeout errors

When a slave stretches the clock beyond the permissible limit
set in the driver, a timeout occurs post which the master deems
the transaction a failure and aborts. The recovery from this state
was broken (master was holding the clock low forever post this)
and that has been fixed with this commit.

Signed-off-by: Rajavardhan Gundi <rajavardhan.gundi@intel.com>
---
 drivers/i2c/i2c_mchp_xec.c | 211 ++++++++++++++++++++++++++-----------
 1 file changed, 147 insertions(+), 64 deletions(-)

diff --git a/drivers/i2c/i2c_mchp_xec.c b/drivers/i2c/i2c_mchp_xec.c
index 87c4973fff..dac8a0f857 100644
--- a/drivers/i2c/i2c_mchp_xec.c
+++ b/drivers/i2c/i2c_mchp_xec.c
@@ -62,6 +62,8 @@ struct i2c_xec_config {
 struct i2c_xec_data {
 	uint32_t pending_stop;
 	uint32_t error_seen;
+	uint32_t timeout_seen;
+	uint32_t previously_in_read;
 	uint32_t speed_id;
 	const struct device *sda_gpio;
 	const struct device *scl_gpio;
@@ -200,7 +202,6 @@ static void recover_from_error(const struct device *dev)
 	i2c_xec_reset_config(dev);
 }
 
-
 static int wait_bus_free(const struct device *dev)
 {
 	const struct i2c_xec_config *config =
@@ -374,9 +375,44 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 	struct i2c_xec_data *data =
 		(struct i2c_xec_data *const) (dev->data);
 	uint32_t ba = config->base_addr;
-	uint8_t i2c_timer = 0;
+	uint8_t i2c_timer = 0, byte;
 	int ret;
 
+	if (data->timeout_seen == 1) {
+		/* Wait to see if the slave has released the CLK */
+		ret = wait_completion(dev);
+		if (ret) {
+			data->timeout_seen = 1;
+			LOG_ERR("%s: %s wait_completion failure %d\n",
+				__func__, dev->name, ret);
+			return ret;
+		}
+		data->timeout_seen = 0;
+
+		/* If we are here, it means the slave has finally released
+		 * the CLK. The master needs to end that transaction
+		 * gracefully by sending a STOP on the bus.
+		 */
+		LOG_DBG("%s: %s Force Stop", __func__, dev->name);
+		MCHP_I2C_SMB_CTRL_WO(ba) =
+					MCHP_I2C_SMB_CTRL_PIN |
+					MCHP_I2C_SMB_CTRL_ESO |
+					MCHP_I2C_SMB_CTRL_STO |
+					MCHP_I2C_SMB_CTRL_ACK;
+		k_busy_wait(BUS_IDLE_US_DFLT);
+		data->pending_stop = 0;
+
+		/* If the timeout had occurred while the master was reading
+		 * something from the slave, that read needs to be completed
+		 * to clear the bus.
+		 */
+		if (data->previously_in_read == 1) {
+			data->previously_in_read = 0;
+			byte = MCHP_I2C_SMB_DATA(ba);
+		}
+		return -EBUSY;
+	}
+
 	if ((data->pending_stop == 0) || (data->error_seen == 1)) {
 		/* Wait till clock and data lines are HIGH */
 		while (check_lines_high(dev) == false) {
@@ -415,19 +451,19 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 				MCHP_I2C_SMB_CTRL_ACK;
 
 		ret = wait_completion(dev);
-		if (ret) {
-			switch (ret) {
-			case -EIO:
-				LOG_WRN("%s: No Addr ACK from Slave 0x%x on %s",
-					__func__, addr >> 1, dev->name);
-				break;
+		switch (ret) {
+		case 0:	/* Success */
+			break;
 
-			default:
-				data->error_seen = 1;
-				LOG_DBG("%s: %s wait_comp error for addr send",
-					__func__, dev->name);
-				break;
-			}
+		case -EIO:
+			LOG_WRN("%s: No Addr ACK from Slave 0x%x on %s",
+				__func__, addr >> 1, dev->name);
+			return ret;
+
+		default:
+			data->error_seen = 1;
+			LOG_ERR("%s: %s wait_comp error for addr send",
+				__func__, dev->name);
 			return ret;
 		}
 	}
@@ -436,38 +472,43 @@ static int i2c_xec_poll_write(const struct device *dev, struct i2c_msg msg,
 	for (int i = 0U; i < msg.len; i++) {
 		MCHP_I2C_SMB_DATA(ba) = msg.buf[i];
 		ret = wait_completion(dev);
-		if (ret) {
-			switch (ret) {
-			case -EIO:
-				LOG_DBG("%s: No Data ACK from Slave 0x%x on %s",
-					__func__, addr >> 1, dev->name);
-				break;
 
-			default:
-				data->error_seen = 1;
-				LOG_DBG("%s: %s wait_completion error for data send",
-					__func__, dev->name);
-				break;
-			}
+		switch (ret) {
+		case 0:	/* Success */
+			break;
+
+		case -EIO:
+			LOG_ERR("%s: No Data ACK from Slave 0x%x on %s",
+				__func__, addr >> 1, dev->name);
 			return ret;
-		}
 
-		/* Handle stop bit for last byte to write */
-		if (i == (msg.len - 1)) {
-			if (msg.flags & I2C_MSG_STOP) {
-				/* Send stop and ack bits */
-				MCHP_I2C_SMB_CTRL_WO(ba) =
-						MCHP_I2C_SMB_CTRL_PIN |
-						MCHP_I2C_SMB_CTRL_ESO |
-						MCHP_I2C_SMB_CTRL_STO |
-						MCHP_I2C_SMB_CTRL_ACK;
-				data->pending_stop = 0;
-			} else {
-				data->pending_stop = 1;
-			}
+		case -ETIMEDOUT:
+			data->timeout_seen = 1;
+			LOG_ERR("%s: Clk stretch Timeout - Slave 0x%x on %s",
+				__func__, addr >> 1, dev->name);
+			return ret;
+
+		default:
+			data->error_seen = 1;
+			LOG_ERR("%s: %s wait_completion error for data send",
+				__func__, dev->name);
+			return ret;
 		}
 	}
 
+	/* Handle stop bit for last byte to write */
+	if (msg.flags & I2C_MSG_STOP) {
+		/* Send stop and ack bits */
+		MCHP_I2C_SMB_CTRL_WO(ba) =
+				MCHP_I2C_SMB_CTRL_PIN |
+				MCHP_I2C_SMB_CTRL_ESO |
+				MCHP_I2C_SMB_CTRL_STO |
+				MCHP_I2C_SMB_CTRL_ACK;
+		data->pending_stop = 0;
+	} else {
+		data->pending_stop = 1;
+	}
+
 	return 0;
 }
 
@@ -482,6 +523,31 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 	uint8_t byte, ctrl, i2c_timer = 0;
 	int ret;
 
+	if (data->timeout_seen == 1) {
+		/* Wait to see if the slave has released the CLK */
+		ret = wait_completion(dev);
+		if (ret) {
+			data->timeout_seen = 1;
+			LOG_ERR("%s: %s wait_completion failure %d\n",
+				__func__, dev->name, ret);
+			return ret;
+		}
+		data->timeout_seen = 0;
+
+		/* If we are here, it means the slave has finally released
+		 * the CLK. The master needs to end that transaction
+		 * gracefully by sending a STOP on the bus.
+		 */
+		LOG_DBG("%s: %s Force Stop", __func__, dev->name);
+		MCHP_I2C_SMB_CTRL_WO(ba) =
+					MCHP_I2C_SMB_CTRL_PIN |
+					MCHP_I2C_SMB_CTRL_ESO |
+					MCHP_I2C_SMB_CTRL_STO |
+					MCHP_I2C_SMB_CTRL_ACK;
+		k_busy_wait(BUS_IDLE_US_DFLT);
+		return -EBUSY;
+	}
+
 	if (!(msg.flags & I2C_MSG_RESTART) || (data->error_seen == 1)) {
 		/* Wait till clock and data lines are HIGH */
 		while (check_lines_high(dev) == false) {
@@ -522,19 +588,26 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 	MCHP_I2C_SMB_DATA(ba) = (addr | BIT(0));
 
 	ret = wait_completion(dev);
-	if (ret) {
-		switch (ret) {
-		case -EIO:
-			LOG_WRN("%s: No Addr ACK from Slave 0x%x on %s",
-				__func__, addr >> 1, dev->name);
-			break;
+	switch (ret) {
+	case 0:	/* Success */
+		break;
 
-		default:
-			data->error_seen = 1;
-			LOG_DBG("%s: %s wait_completion error for address send",
-				__func__, dev->name);
-			break;
-		}
+	case -EIO:
+		LOG_WRN("%s: No Addr ACK from Slave 0x%x on %s",
+			__func__, addr >> 1, dev->name);
+		return ret;
+
+	case -ETIMEDOUT:
+		data->previously_in_read = 1;
+		data->timeout_seen = 1;
+		LOG_ERR("%s: Clk stretch Timeout - Slave 0x%x on %s",
+			__func__, addr >> 1, dev->name);
+		return ret;
+
+	default:
+		data->error_seen = 1;
+		LOG_ERR("%s: %s wait_completion error for address send",
+			__func__, dev->name);
 		return ret;
 	}
 
@@ -545,20 +618,30 @@ static int i2c_xec_poll_read(const struct device *dev, struct i2c_msg msg,
 
 	/* Read dummy byte */
 	byte = MCHP_I2C_SMB_DATA(ba);
-	ret = wait_completion(dev);
-	if (ret) {
-		data->error_seen = 1;
-		LOG_DBG("%s: %s wait_completion error for dummy byte",
-			__func__, dev->name);
-		return ret;
-	}
 
 	for (int i = 0U; i < msg.len; i++) {
-		while (MCHP_I2C_SMB_STS_RO(ba) & MCHP_I2C_SMB_STS_PIN) {
-			if (MCHP_I2C_SMB_STS_RO(ba) & MCHP_I2C_SMB_STS_BER) {
-				recover_from_error(dev);
-				return -EBUSY;
-			}
+		ret = wait_completion(dev);
+		switch (ret) {
+		case 0:	/* Success */
+			break;
+
+		case -EIO:
+			LOG_ERR("%s: No Data ACK from Slave 0x%x on %s",
+				__func__, addr >> 1, dev->name);
+			return ret;
+
+		case -ETIMEDOUT:
+			data->previously_in_read = 1;
+			data->timeout_seen = 1;
+			LOG_ERR("%s: Clk stretch Timeout - Slave 0x%x on %s",
+				__func__, addr >> 1, dev->name);
+			return ret;
+
+		default:
+			data->error_seen = 1;
+			LOG_ERR("%s: %s wait_completion error for data send",
+				__func__, dev->name);
+			return ret;
 		}
 
 		if (i == (msg.len - 1)) {
-- 
2.17.1

